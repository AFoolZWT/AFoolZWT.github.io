<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《大话数据结构》（线性表） | 愚人のblog</title><meta name="keywords" content="学习读物"><meta name="author" content="愚人"><meta name="copyright" content="愚人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 1 数据结构绪论数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：一个数据">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话数据结构》（线性表）">
<meta property="og:url" content="https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/index.html">
<meta property="og:site_name" content="愚人のblog">
<meta property="og:description" content="Chapter 1 数据结构绪论数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 数据数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项数据项：一个数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://afoolzwt.github.io/img/books/DHSJJG.jpg">
<meta property="article:published_time" content="2022-05-13T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-14T08:26:10.305Z">
<meta property="article:author" content="愚人">
<meta property="article:tag" content="学习读物">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://afoolzwt.github.io/img/books/DHSJJG.jpg"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-HqA81hlzlz&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《大话数据结构》（线性表）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-14 16:26:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="愚人のblog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/headicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: lightblue"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">愚人のblog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《大话数据结构》（线性表）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-13T16:00:00.000Z" title="发表于 2022-05-14 00:00:00">2022-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-14T08:26:10.305Z" title="更新于 2022-05-14 16:26:10">2022-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/">《大话数据结构》</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《大话数据结构》（线性表）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-1-数据结构绪论"><a href="#Chapter-1-数据结构绪论" class="headerlink" title="Chapter 1 数据结构绪论"></a>Chapter 1 数据结构绪论</h1><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象：是性质相同的数据元素的集合，是数据的子集。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p>
<h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构：是指数据对象中数据元素之间的相互关系。逻辑结构分为以下四种：</p>
<ul>
<li>1.集合结构</li>
</ul>
<p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。<br><img src="/img/CSDataStructure/1.jpg"></p>
<ul>
<li>2.线性结构</li>
</ul>
<p>线性结构：线性结构中的数据元素之间是一对一的关系。<br><img src="/img/CSDataStructure/2.jpg"></p>
<ul>
<li>3.树形结构</li>
</ul>
<p>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。<br><img src="/img/CSDataStructure/3.jpg"></p>
<ul>
<li>4.图形结构</li>
</ul>
<p>图形结构：图形结构的数据元素是多对多的关系。<br><img src="/img/CSDataStructure/4.jpg"></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。<br>数据元素的存储结构形式有两种：顺序存储和链式存储。</p>
<ul>
<li>1.顺序存储结构</li>
</ul>
<p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。<br><img src="/img/CSDataStructure/5.jpg"></p>
<ul>
<li>2.链式存储结构</li>
</ul>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。<br><img src="/img/CSDataStructure/6.jpg"></p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。<br>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ul>
<li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。</li>
<li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。<h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。<br>抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/img/CSDataStructure/7.jpg"><br><img src="/img/CSDataStructure/8.jpg"></li>
</ul>
<h1 id="Chapter-2-算法"><a href="#Chapter-2-算法" class="headerlink" title="Chapter 2 算法"></a>Chapter 2 算法</h1><p>算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>算法具有零个或多个输入，算法至少有一个或多个输出。</p>
<h3 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h3><p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p>
<h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
<h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。<br>但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出结果。 3.算法程序对于非法的输入数据能够得出满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p>
<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>可读性：算法设计的另一目的是为了便于阅读、理解和交流。</p>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p>
<h3 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h3><p>时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><h3 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h3><p>事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p>
<h3 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h3><p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</p>
<h2 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h2><p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。<br>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>
<h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p>
<h3 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h3><p>推导大O阶：</p>
<ul>
<li>1．用常数1取代运行时间中的所有加法常数。</li>
<li>2．在修改后的运行次数函数中，只保留最高阶项。</li>
<li>3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是大O阶。<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4>事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。<br>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4>要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  count  =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>  (count  &lt;  n)</span><br><span class="line">&#123;</span><br><span class="line">count  =  count  *  <span class="number">2</span>;</span><br><span class="line"><span class="comment">/*  时间复杂度为O(1)的程序步骤序列  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由2x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table>
<thead>
<tr>
<th>执行次数</th>
<th>函数阶</th>
<th>非正式术语</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>O(1)</td>
<td>常数阶</td>
</tr>
<tr>
<td>2n+3</td>
<td>O(n)</td>
<td>线性阶</td>
</tr>
<tr>
<td>3n2  +2n+1</td>
<td>O(n2)</td>
<td>平方阶</td>
</tr>
<tr>
<td>5log2n+20</td>
<td>O(logn)</td>
<td>对数阶</td>
</tr>
<tr>
<td>2n+3nlog2n+19</td>
<td>O(nlogn)</td>
<td>nlogn阶</td>
</tr>
<tr>
<td>6n3+2n2+3n+4</td>
<td>O(n3  )</td>
<td>立方阶</td>
</tr>
<tr>
<td>2n</td>
<td>O(2n)</td>
<td>指数阶</td>
</tr>
</tbody></table>
</li>
</ul>
<p>常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn)</p>
<h2 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h2><p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>
<h2 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h2><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p>
<h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。<br>如果用数学语言来进行定义。可如下：<br>若将线性表记为（a1，…，ai-1，ai，ai+1，…，an），则表中ai-1领先于ai，ai+1领先于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱。<br>所以线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。<br>在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的位序。<br>线性表的抽象数据类型定义如下：</p>
<ul>
<li>ADT<br>  线性表(List)</li>
<li>Data<br>线性表的数据对象集合为{a1,  a2,  ……,  an}，每个元素的类型均为DataType。<br>其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。<br>数据元素之间的关系是一对一的关系。</li>
<li>Operation<br>InitList(*L):                    初始化操作，建立一个空的线性表L。<br>ListEmpty(L):                    若线性表为空，返回true，否则返回false。<br>ClearList(*L):                  将线性表清空。<br>GetElem(L,  i,  *e):          将线性表L中的第i个位置元素值返回给e。<br>LocateElem(L,  e):            在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将所有的在线性表Lb中但不在La中的数据元素插入到La中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">unionL</span><span class="params">(List  *La,  List  Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  La_len,  Lb_len,  i;</span><br><span class="line">	<span class="comment">/*  声明与La和Lb相同的数据元素e  */</span></span><br><span class="line">	ElemType  e;</span><br><span class="line">	<span class="comment">/*  求线性表的长度  */</span></span><br><span class="line">	La_len  =  ListLength(*La);                 </span><br><span class="line">	Lb_len  =  ListLength(Lb);</span><br><span class="line">	<span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;=  Lb_len;  i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  取Lb中第i个数据元素赋给e  */</span></span><br><span class="line">		GetElem(Lb,  i,  &amp;e);                       </span><br><span class="line">		<span class="comment">/*  La中不存在和e相同数据元素  */</span></span><br><span class="line">		<span class="keyword">if</span>  (!LocateElem(*La,  e))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*  插入  */</span></span><br><span class="line">			ListInsert(La,  ++La_len,  e);</span><br><span class="line">		&#125;                  </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3>线性表的顺序存储的结构代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  存储空间初始分配量  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  20                        </span></span><br><span class="line"><span class="comment">/*  ElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  ElemType;                    </span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  数组存储数据元素，最大值为MAXSIZE  */</span></span><br><span class="line">	ElemType  data[MAXSIZE];        </span><br><span class="line">	<span class="comment">/*  线性表当前长度  */</span></span><br><span class="line">	<span class="keyword">int</span>  length;</span><br><span class="line">&#125;SqList;            </span><br></pre></td></tr></table></figure>
描述顺序存储结构需要三个属性：</li>
<li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li>
<li>线性表的最大存储容量：数组长度MaxSize。</li>
<li>线性表的当前长度：length。<h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。<br>由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。LOC(ai+1)=LOC(ai)+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：LOC(ai)=LOC(a1)+(i-1)*c</li>
</ul>
<p>通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为随机存取结构。</p>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OK  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ERROR  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FALSE  0</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  Status;</span><br><span class="line"><span class="comment">/*  Status是函数的类型，其值是函数结果状态代码，如OK等  */</span></span><br><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：用e返回L中第i个数据元素的值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">GetElem</span><span class="params">(SqList  L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (L.length  ==  <span class="number">0</span>  ||  i  &lt;  <span class="number">1</span>  ||  i  &gt;  L.length)<span class="keyword">return</span>  ERROR;</span><br><span class="line">	*e  =  L.data[i  -  <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入算法的思路：<br>如果插入位置不合理，抛出异常；<br>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>将要插入元素填入位置i处；<br>表长加1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)，  */</span></span><br><span class="line"><span class="comment">/*  操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  k;</span><br><span class="line">	<span class="comment">/*  顺序线性表已经满  */</span></span><br><span class="line">	<span class="keyword">if</span>  (L-&gt;length  ==  MAXSIZE)	<span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  当i不在范围内时  */</span></span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;L-&gt;length  +  <span class="number">1</span>)      <span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  若插入数据位置不在表尾  */</span></span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;=  L-&gt;length)                      </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*将要插入位置后数据元素向后移动一位  */</span></span><br><span class="line">		<span class="keyword">for</span>  (k  =  L-&gt;length  -  <span class="number">1</span>;  k  &gt;=  i  -  <span class="number">1</span>;  k--)</span><br><span class="line">	        L-&gt;data[k  +  <span class="number">1</span>]  =  L-&gt;data[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  将新元素插入  */</span></span><br><span class="line">	L-&gt;data[i  -  <span class="number">1</span>]  =  e;                     </span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：<br>如果删除位置不合理，抛出异常；<br>取出删除元素；<br>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>表长减1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  k;</span><br><span class="line">	<span class="comment">/*  线性表为空  */</span></span><br><span class="line">	<span class="keyword">if</span>  (L-&gt;length  ==  <span class="number">0</span>)	<span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  删除位置不正确  */</span></span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  L-&gt;length)	<span class="keyword">return</span>  ERROR;</span><br><span class="line">	*e  =  L-&gt;data[i  -  <span class="number">1</span>];</span><br><span class="line">	<span class="comment">/*  如果删除不是最后位置  */</span></span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;  L-&gt;length)                     </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  将删除位置后继元素前移  */</span></span><br><span class="line">		<span class="keyword">for</span>  (k  =  i;  k  &lt;  L-&gt;length;  k++)      L-&gt;data[k  -  <span class="number">1</span>]  =  L-&gt;data[k];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。<br><img src="/img/CSDataStructure/9.jpg"></p>
<h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="顺序存储结构不足的解决办法"><a href="#顺序存储结构不足的解决办法" class="headerlink" title="顺序存储结构不足的解决办法"></a>顺序存储结构不足的解决办法</h3><p>为什么当插入和删除时，就要移动大量元素，仔细分析后，发现原因就在于相邻两元素的存储位置也具有邻居关系。它们编号是1，2，3，…，n，它们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速介入，而删除后，当中就会留出空隙，自然需要弥补。问题就出在这里。</p>
<h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。<br>以前在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。<br>因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。<br>我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。<br>n个结点（ai的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。<br>对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p>
<h3 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h3><p><img src="/img/CSDataStructure/10.jpg"></p>
<h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>若线性表为空表，则头结点的指针域为“空”。<br>单链表中，我们在C语言中可用结构指针来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的单链表存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">/*  定义LinkList  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>  *<span class="title">LinkList</span>;</span>    </span><br></pre></td></tr></table></figure>
<p>从这个结构定义中，我们也就知道，结点由存放数据元素的数据域和存放后继结点地址的指针域组成。假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p-&gt;data来表示，p-&gt;data的值是一个数据元素，结点ai的指针域可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向谁呢？当然是指向第i+1个元素，即指向ai+1的指针。也就是说，如果p-&gt;data=ai，那么p-&gt;next-&gt;data=ai+1。</p>
<h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>1.声明一个指针p指向链表第一个结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，返回结点p的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：用e返回L中第i个数据元素的值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">GetElem</span><span class="params">(LinkList  L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j;</span><br><span class="line">	LinkList  p;                        </span><br><span class="line">	<span class="comment">/*  声明一指针p  */</span></span><br><span class="line">	p  =  L-&gt;next;                </span><br><span class="line">	<span class="comment">/*  让p指向链表L的第个结点  */</span></span><br><span class="line">	j  =  <span class="number">1</span>;                                  </span><br><span class="line">	<span class="comment">/*  j为计数器  */</span></span><br><span class="line">	<span class="comment">/*  p不为空且计数器j还没有等于i时，循环继续  */</span></span><br><span class="line">	<span class="keyword">while</span>  (p  &amp;&amp;  j  &lt;  i)</span><br><span class="line">   	&#123;</span><br><span class="line">		p  =  p-&gt;next;        </span><br><span class="line">		<span class="comment">/*  让p指向下一个结点  */</span></span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>  (!p  ||  j  &gt;  i)	<span class="keyword">return</span>  ERROR;            </span><br><span class="line">	<span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line">	</span><br><span class="line">	*e  =  p-&gt;data;              </span><br><span class="line">	<span class="comment">/*  取第i个结点的数据  */</span></span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说白了，就是从头开始找，直到第i个结点为止。由于这个算法的时间复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据了，而当i=n时则遍历n-1次才可以。因此最坏情况的时间复杂度是O(n)。</p>
<h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>单链表第i个数据插入结点的算法思路：<br>1.声明一指针p指向链表头结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，在系统中生成一个空结点s；<br>5.将数据元素e赋值给s-&gt;data；<br>6.单链表的插入标准语句s-&gt;next=p-&gt;next;p-&gt;next=s；<br>7.返回成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)，  */</span></span><br><span class="line"><span class="comment">/*  操作结果：在L中第i个结点位置之前插入新的数据元素e，L的长度加1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j;</span><br><span class="line">	LinkList  p,s;</span><br><span class="line">	p  =  *L;</span><br><span class="line">	j  =  <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/*  寻找第i-1个结点  */</span></span><br><span class="line">	<span class="keyword">while</span>  (p  &amp;&amp;  j  &lt;  i)                     </span><br><span class="line">	&#123;</span><br><span class="line">		p  =  p-&gt;next;++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line">	<span class="keyword">if</span>  (!p  ||  j  &gt;  i)<span class="keyword">return</span>  ERROR;</span><br><span class="line">    <span class="comment">/*  生成新结点（C标准函数）  */</span></span><br><span class="line">	s  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data  =  e;</span><br><span class="line">	<span class="comment">/*  将p的后继结点赋值给s的后继  */</span></span><br><span class="line">	s-&gt;next  =  p-&gt;next;                        </span><br><span class="line">	<span class="comment">/*  将s赋值给p的后继  */</span></span><br><span class="line">	p-&gt;next  =  s;                              </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>单链表第i个数据删除结点的算法思路：<br>1.声明一指针p指向链表头结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，将欲删除的结点p-&gt;next赋值给q；<br>5.单链表的删除标准语句p-&gt;next=q-&gt;next；<br>6.将q结点中的数据赋值给e，作为返回；<br>7.释放q结点；<br>8.返回成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：删除L的第i个结点，并用e返回其值，L的长度减1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j;</span><br><span class="line">	LinkList  p,q;</span><br><span class="line">	p  =  *L;</span><br><span class="line">	j  =  <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/*  遍历寻找第i-1个结点  */</span></span><br><span class="line">	<span class="keyword">while</span>  (p-&gt;next  &amp;&amp;  j  &lt;  i)        </span><br><span class="line">	&#123;p  =  p-&gt;next;++j;&#125;</span><br><span class="line">	<span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line">	<span class="keyword">if</span>  (!(p-&gt;next)  ||  j  &gt;  i)<span class="keyword">return</span>  ERROR;</span><br><span class="line"></span><br><span class="line">    q  =  p-&gt;next;</span><br><span class="line">	<span class="comment">/*  将q的后继赋值给p的后继  */</span></span><br><span class="line">	p-&gt;next  =  q-&gt;next;                    </span><br><span class="line">	<span class="comment">/*  将q结点中的数据给e  */</span></span><br><span class="line">	*e  =  q-&gt;data;                             </span><br><span class="line">	<span class="comment">/*  让系统回收此结点，释放内存  */</span></span><br><span class="line">	<span class="built_in">free</span>(q);                                    </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。<br>从整个算法来说，我们很容易推导出：它们的时间复杂度都是O(n)。如果在我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。<br>但如果，我们希望从第i个位置，插入10个结点，对于顺序存储结构意味着，每一次插入都需要移动n-i个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。<br>显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p>
<h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>回顾一下，顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。<br>而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。<br>所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。</p>
<p>单链表整表创建的算法思路：<br>1.声明一指针p和计数器变量i；<br>2.初始化一空链表L；<br>3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表；<br>4.循环：<br>生成一新结点赋值给p；<br>随机生成一数字赋值给p的数据域p-&gt;data；<br>将p插入到头结点与前一新结点之间。</p>
<ul>
<li>头插法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateListHead</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList  p;</span><br><span class="line">	<span class="keyword">int</span>  i;</span><br><span class="line">	<span class="comment">/*  初始化随机数种子  */</span></span><br><span class="line">	srand(time(<span class="number">0</span>));                             </span><br><span class="line">	*L  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="comment">/*  先建立一个带头结点的单链表  */</span></span><br><span class="line">	(*L)-&gt;next  =  <span class="literal">NULL</span>;                        </span><br><span class="line">	<span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  n;  i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  生成新结点  */</span></span><br><span class="line">		p  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));       </span><br><span class="line">		<span class="comment">/*  随机生成100以内的数字  */</span></span><br><span class="line">		p-&gt;data  =  rand()  %  <span class="number">100</span>  +  <span class="number">1</span>;           </span><br><span class="line">		p-&gt;next  =  (*L)-&gt;next;</span><br><span class="line">		<span class="comment">/*  插入到表头  */</span></span><br><span class="line">		(*L)-&gt;next  =  p;                           </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尾插法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateListTail</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList  p,r;</span><br><span class="line">	<span class="keyword">int</span>  i;</span><br><span class="line">	<span class="comment">/*  初始化随机数种子  */</span></span><br><span class="line">	srand(time(<span class="number">0</span>));                             </span><br><span class="line">	<span class="comment">/*  为整个线性表  */</span></span><br><span class="line">	*L  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      </span><br><span class="line">	<span class="comment">/*  r为指向尾部的结点  */</span></span><br><span class="line">	r  =  *L;                                   </span><br><span class="line">	<span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  n;  i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  生成新结点  */</span></span><br><span class="line">		p  =  (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      </span><br><span class="line">		<span class="comment">/*  随机生成100以内的数字  */</span></span><br><span class="line">		p-&gt;data  =  rand()  %  <span class="number">100</span>  +  <span class="number">1</span>;           </span><br><span class="line">		<span class="comment">/*  将表尾终端结点的指针指向新结点  */</span></span><br><span class="line">		r-&gt;next  =  p;                              </span><br><span class="line">		<span class="comment">/*  将当前的新结点定义为表尾终端结点  */</span></span><br><span class="line">		r  =  p;                                    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  表示当前链表结束  */</span></span><br><span class="line">	r-&gt;next  =  <span class="literal">NULL</span>;                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3>单链表整表删除的算法思路如下：</li>
</ul>
<p>1.声明一指针p和q；<br>2.将第一个结点赋值给p；<br>3.循环：<br>将下一结点赋值给q；<br>释放p；<br>将q赋值给p。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，操作结果：将L重置为空表  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ClearList</span><span class="params">(LinkList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList  p,  q;</span><br><span class="line">	<span class="comment">/*  p指向第一个结点  */</span></span><br><span class="line">	p  =  (*L)-&gt;next;              </span><br><span class="line">	<span class="comment">/*  没到表尾  */</span></span><br><span class="line">	<span class="keyword">while</span>  (p)                          </span><br><span class="line">	&#123;</span><br><span class="line">		q  =  p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  头结点指针域为空  */</span></span><br><span class="line">	(*L)-&gt;next  =  <span class="literal">NULL</span>;       </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p><img src="/img/CSDataStructure/11.jpg"><br>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。<br>若需要频繁插入和删除时，宜采用单链表结构。<br>比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。<br>而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚。<br>当然，这只是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。<br>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。<br>而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。<br>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。</p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>首先我们让数组的元素都是由两个数据域组成，data和cur。<br>也就是说，数组的每个下标都对应一个data和一个cur。<br>数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的静态链表存储结构  */</span></span><br><span class="line"><span class="comment">/*  假设链表的最大长度是1000  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  1000                 </span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="comment">/*  游标（Cursor），为0时表示无指向  */</span></span><br><span class="line">	<span class="keyword">int</span>  cur;                              </span><br><span class="line">&#125;  Component,  </span><br><span class="line"><span class="comment">/*  对于不提供结构struct的程序设计语言，可以使用一对并行数组data和cur来处理。  */</span></span><br><span class="line">StaticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将一维数组space中各分量链成一备用链表，  */</span></span><br><span class="line"><span class="comment">/*  space[0].cur为头指针，&quot;0&quot;表示空指针  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InitList</span><span class="params">(StaticLinkList  space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  i;</span><br><span class="line">	<span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  MAXSIZE  -  <span class="number">1</span>;  i++)</span><br><span class="line">	&#123;</span><br><span class="line">		space[i].cur  =  i  +  <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*  目前静态链表为空，最后一个元素的cur为0  */</span></span><br><span class="line">	space[MAXSIZE  -  <span class="number">1</span>].cur  =  <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。<br>我们通常把未被使用的数组元素称为备用链表。<br>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。<br><img src="/img/CSDataStructure/12.jpg"><br>此时“甲”这里就存有下一元素“乙”的游标2，“乙”则存有下一元素“丁”的下标3。而“庚”是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一有值元素而存有它的下标为1。而第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存有7。<br><img src="/img/CSDataStructure/13.jpg"></p>
<h2 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h2><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。<br>我们前面说过，在动态链表中，结点的申请和释放分别借用malloc()和free()两个函数来实现。<br>在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若备用空间链表非空，则返回分配的结点下标，否则返回0  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Malloc_SLL</span><span class="params">(StaticLinkList  space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  当前数组第一个元素的cur存的值，  */</span></span><br><span class="line">	<span class="comment">/*  就是要返回的第一个备用空闲的下标  */</span></span><br><span class="line">	<span class="keyword">int</span>  i  =  space[<span class="number">0</span>].cur;       </span><br><span class="line">	<span class="comment">/*  由于要拿出一个分量来使用了，所以我们  */</span></span><br><span class="line">	<span class="comment">/*  就得把它的下一个分量用来做备用  */</span></span><br><span class="line">	<span class="keyword">if</span>  (space[<span class="number">0</span>].cur)</span><br><span class="line">	&#123;</span><br><span class="line">		space[<span class="number">0</span>].cur  =  space[i].cur;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span>  i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  在L中第i个元素之前插入新的数据元素e    */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(StaticLinkList  L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j,  k,  l;</span><br><span class="line">	<span class="comment">/*  注意k首先是最后一个元素的下标  */</span></span><br><span class="line">	k  =  MAX_SIZE  -  <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  ListLength(L)  +  <span class="number">1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  获得空闲分量的下标  */</span></span><br><span class="line">	j  =  Malloc_SSL(L);           </span><br><span class="line">	<span class="keyword">if</span>  (j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  将数据赋值给此分量的data  */</span></span><br><span class="line">		L[j].data  =  e;               </span><br><span class="line">		<span class="comment">/*  找到第i个元素之前的位置  */</span></span><br><span class="line">		<span class="keyword">for</span>  (l  =  <span class="number">1</span>;  l  &lt;=  i  -  <span class="number">1</span>;  l++)</span><br><span class="line">		&#123;</span><br><span class="line">			 k  =  L[k].cur;</span><br><span class="line">		&#125;       </span><br><span class="line">		<span class="comment">/*  把第i个元素之前的cur赋值给新元素的cur  */</span></span><br><span class="line">		L[j].cur  =  L[k].cur;         </span><br><span class="line">		<span class="comment">/*  把新元素的下标赋值给第i个元素之前元素的cur  */</span></span><br><span class="line">		L[k].cur  =  j;                </span><br><span class="line">		<span class="keyword">return</span>  OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  ERROR;</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作。<br><img src="/img/CSDataStructure/14.jpg"><h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  删除在L中第i个数据元素e  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(StaticLinkList  L,  <span class="keyword">int</span>  i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j,  k;</span><br><span class="line">	<span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  ListLength(L))<span class="keyword">return</span>  ERROR;</span><br><span class="line">	k  =  MAX_SIZE  -  <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>  (j  =  <span class="number">1</span>;  j  &lt;=  i  -  <span class="number">1</span>;  j++)</span><br><span class="line">	&#123;</span><br><span class="line">		k  =  L[k].cur;</span><br><span class="line">	&#125;</span><br><span class="line">	j  =  L[k].cur;<span class="comment">// 待删除元素i的索引j</span></span><br><span class="line">	L[k].cur  =  L[j].cur;</span><br><span class="line">	Free_SSL(L,  j);</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Free_SSL(L,  j)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将下标为k的空闲结点回收到备用链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Free_SSL</span><span class="params">(StaticLinkList  space,  <span class="keyword">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  把第一个元素cur值赋给要删除的分量cur  */</span></span><br><span class="line">	space[k].cur  =  space[<span class="number">0</span>].cur;     </span><br><span class="line">	<span class="comment">/*  把要删除的分量下标赋值给第一个元素的cur  */</span></span><br><span class="line">	space[<span class="number">0</span>].cur  =  k;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/CSDataStructure/15.jpg"></li>
<li>ListLength<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：静态链表L已存在。操作结果：返回L中数据元素个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">ListLength</span><span class="params">(StaticLinkList  L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  j  =  <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>  i  =  L[MAXSIZE  -  <span class="number">1</span>].cur;</span><br><span class="line">	<span class="keyword">while</span>  (i)</span><br><span class="line">	&#123;</span><br><span class="line">		i  =  L[i].cur;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><img src="/img/CSDataStructure/16.jpg"><br>顺序储存结构随机存取：顺序存储结构的地址在内存中是连续的所以可以通过计算地址实现随机存取，与此相对 链式存储结构的存储地址不一定连续，只能通过第个结点的指针顺序存取。<br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，这并不是说，循环链表一定要头结点，这需要注意。</li>
</ul>
<p>合并两个循环链表<br><img src="/img/CSDataStructure/17.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  保存A表的头结点*/</span></span><br><span class="line">p  =  rearA-&gt;next;                                        </span><br><span class="line"><span class="comment">/*将本是指向B表的第一个结点（不是头结点）  */</span></span><br><span class="line">rearA-&gt;next  =  rearB-&gt;next-&gt;next;        </span><br><span class="line"><span class="comment">/*  赋值给reaA-&gt;next*/</span></span><br><span class="line">q  =  rearB-&gt;next;</span><br><span class="line"><span class="comment">/*  将原A表的头结点赋值给rearB-&gt;next */</span></span><br><span class="line">rearB-&gt;next  =  p;                                        </span><br><span class="line"><span class="comment">/*  释放q  */</span></span><br><span class="line"><span class="built_in">free</span>(q); </span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的双向链表存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">DuLNode</span>  *<span class="title">prior</span>;</span>        </span><br><span class="line">	<span class="comment">/*  直接前驱指针  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">DuLNode</span>  *<span class="title">next</span>;</span>          </span><br><span class="line">	<span class="comment">/*  直接后继指针  */</span></span><br><span class="line">&#125;  DulNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSDataStructure/18.jpg"><br>双向链表既然是比单链表多了如可以反向遍历查找等数据结构，那么也就需要付出一些小的代价：在插入和删除时，需要更改两个指针变量。</p>
<ul>
<li>插入操作</li>
</ul>
<p>插入操作时，其实并不复杂，不过顺序很重要，千万不能写反了。<br><img src="/img/CSDataStructure/19.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  把p赋值给s的前驱，如图中①  */</span></span><br><span class="line">s-&gt;prior  =  p;                    </span><br><span class="line"><span class="comment">/*  把p-&gt;next赋值给s的后继，如图中②  */</span></span><br><span class="line">s-&gt;next  =  p-&gt;next;          </span><br><span class="line"><span class="comment">/*  把s赋值给p-&gt;next的前驱，如图中③  */</span></span><br><span class="line">p-&gt;next-&gt;prior  =  s;        </span><br><span class="line"><span class="comment">/*  把s赋值给p的后继，如图中④  */</span></span><br><span class="line">p-&gt;next  =  s;      </span><br></pre></td></tr></table></figure>
<ul>
<li>删除操作<br><img src="/img/CSDataStructure/20.jpg"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  把p-&gt;next赋值给p-&gt;prior的后继，如图中①  */</span></span><br><span class="line">p-&gt;prior-&gt;next  =  p-&gt;next;          </span><br><span class="line"><span class="comment">/*  把p-&gt;prior赋值给p-&gt;next的前驱，如图中②  */</span></span><br><span class="line">p-&gt;next-&gt;prior  =  p-&gt;prior;       </span><br><span class="line"> <span class="comment">/*  释放结点  */</span></span><br><span class="line"><span class="built_in">free</span>(p);         </span><br></pre></td></tr></table></figure>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。<br>它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。<br>然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br><img src="/img/CSDataStructure/21.jpg"><h1 id="第四章-栈与队列"><a href="#第四章-栈与队列" class="headerlink" title="第四章 栈与队列"></a>第四章 栈与队列</h1>栈是限定仅在表尾进行插入和删除操作的线性表。<br>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2></li>
<li>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</li>
</ul>
<p>我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（LastIn First Out）的线性表，简称LIFO结构。</p>
<ul>
<li>理解栈的定义需要注意：</li>
</ul>
<p>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p>
<p>栈的插入操作，叫作进栈，也称压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</p>
<h3 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h3><p>这个最先进栈的元素，是不是就只能是最后出栈呢？<br>答案是不一定，要看什么情况。<br>栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。</p>
<p>第一种：1、2、3进，再3、2、1出。这是最简单的最好理解的一种，出栈次序为321。<br>第二种：1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出栈次序为123。<br>第三种：1进，2进，2出，1出，3进，3出。出栈次序为213。<br>第四种：1进，1出，2进，3进，3出，2出。出栈次序为132。<br>第五种：1进，2进，2出，3进，3出，1出。出栈次序为231。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>ADT  栈(stack)<br>    Data<br>        同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。<br>    Operation<br>        InitStack(*S):            初始化操作，建立一个空栈S。<br>        DestroyStack(*S):      若栈存在，则销毁它。<br>        ClearStack(*S):          将栈清空。<br>        StackEmpty(S):        若栈为空，返回true，否则返回false。<br>        GetTop(S,  *e):        若栈存在且非空，用e返回S的栈顶元素。<br>        Push(*S,  e):            若栈S存在，插入新元素e到栈S中并成为栈顶元素。<br>        Pop(*S,  *e):            删除栈S中栈顶元素，并用e返回其值。<br>        StackLength(S):      返回栈S的元素个数。<br>endADT</p>
<p>由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。</p>
<h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><p>既然栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除的线性表来说，用数组哪一端来作为栈顶和栈底比较好？<br>对，没错，下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。</p>
<h4 id="栈的结构定义"><a href="#栈的结构定义" class="headerlink" title="栈的结构定义"></a>栈的结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  SElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  SElemType;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType  data[MAXSIZE];</span><br><span class="line">	<span class="comment">/*  用于栈顶指针  */</span></span><br><span class="line">	<span class="keyword">int</span>  top;                           </span><br><span class="line"> &#125;SqStack;</span><br></pre></td></tr></table></figure>
<h3 id="栈的顺序存储结构——进栈操作-push"><a href="#栈的顺序存储结构——进栈操作-push" class="headerlink" title="栈的顺序存储结构——进栈操作(push)"></a>栈的顺序存储结构——进栈操作(push)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(SqStack  *S,  SElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  栈满  */</span></span><br><span class="line">	<span class="keyword">if</span>  (S-&gt;top  ==  MAXSIZE  -  <span class="number">1</span>)   &#123;<span class="keyword">return</span>  ERROR;&#125;</span><br><span class="line">	<span class="comment">/*  栈顶指针增加一  */</span></span><br><span class="line">	S-&gt;top++;                                          </span><br><span class="line">	<span class="comment">/*  将新插入元素赋值给栈顶空间  */</span></span><br><span class="line">	S-&gt;data[S-&gt;top]  =  e;                    </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的顺序存储结构——出栈-pop"><a href="#栈的顺序存储结构——出栈-pop" class="headerlink" title="栈的顺序存储结构——出栈(pop)"></a>栈的顺序存储结构——出栈(pop)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(SqStack  *S,  SElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (S-&gt;top  ==  <span class="number">-1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  将要删除的栈顶元素赋值给e  */</span></span><br><span class="line">	*e  =  S-&gt;data[S-&gt;top];        </span><br><span class="line">	<span class="comment">/*  栈顶指针减一  */</span></span><br><span class="line">	S-&gt;top--;                                </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。</p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。<br>不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。<br>对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。<br><img src="/img/CSDataStructure/22.jpg"><br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两栈共享空间结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType  data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span>  top1;        <span class="comment">/*  栈1栈顶指针  */</span></span><br><span class="line">	<span class="keyword">int</span>  top2;        <span class="comment">/*  栈2栈顶指针  */</span></span><br><span class="line">&#125;  SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(SqDoubleStack  *S,  SElemType  e,  <span class="keyword">int</span>  stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  栈已满，不能再push新元素了  */</span></span><br><span class="line">	<span class="keyword">if</span>  (S-&gt;top1  +  <span class="number">1</span>  ==  S-&gt;top2)        <span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="keyword">if</span>  (stackNumber  ==  <span class="number">1</span>)<span class="comment">/*  栈1有元素进栈  */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  若栈1则先top1+1后给数组元素赋值  */</span></span><br><span class="line">		S-&gt;data[++S-&gt;top1]  =  e; </span><br><span class="line">	&#125;                     </span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>  (stackNumber  ==  <span class="number">2</span>)<span class="comment">/*  栈2有元素进栈  */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  若栈2则先top2-1后给数组元素赋值  */</span></span><br><span class="line">		S-&gt;data[--S-&gt;top2]  =  e;</span><br><span class="line">	&#125;                 </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(SqDoubleStack  *S,  SElemType  *e,  <span class="keyword">int</span>  stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (stackNumber  ==  <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  说明栈1已经是空栈，溢出  */</span></span><br><span class="line">		<span class="keyword">if</span>  (S-&gt;top1  ==  <span class="number">-1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line">	    <span class="comment">/*  将栈1的栈顶元素出栈  */</span></span><br><span class="line">		*e  =  S-&gt;data[S-&gt;top1--];        </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>  (stackNumber  ==  <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  说明栈2已经是空栈，溢出  */</span></span><br><span class="line">		<span class="keyword">if</span>  (S-&gt;top2  ==  MAXSIZE)<span class="keyword">return</span>  ERROR;                      </span><br><span class="line">		<span class="comment">/*  将栈2的栈顶元素出栈  */</span></span><br><span class="line">		*e  =  S-&gt;data[S-&gt;top2++];       </span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><p>栈的链式存储结构，简称为链栈。<br>想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</p>
<p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。<br>链栈的结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">StackNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  StackNode,  *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LinkStackPtr  top;</span><br><span class="line">	<span class="keyword">int</span>  count;</span><br><span class="line">&#125;  LinkStack;</span><br></pre></td></tr></table></figure>
<p>链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。</p>
<h4 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(LinkStack  *S,  SElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStackPtr  s  =  (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">	s-&gt;data  =  e;</span><br><span class="line">	<span class="comment">/*  把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">	s-&gt;next  =  S-&gt;top;        </span><br><span class="line">	<span class="comment">/*  将新的结点s赋值给栈顶指针*/</span></span><br><span class="line">	S-&gt;top  =  s;                    </span><br><span class="line">	S-&gt;count++;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(LinkStack  *S,  SElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStackPtr  p;</span><br><span class="line">	<span class="keyword">if</span>  (StackEmpty(*S))<span class="keyword">return</span>  ERROR;</span><br><span class="line">	*e  =  S-&gt;top-&gt;data;<span class="comment">/*  将栈顶结点赋值给p*/</span></span><br><span class="line">	p  =  S-&gt;top;                              </span><br><span class="line">	<span class="comment">/*  使得栈顶指针下移一位*/</span></span><br><span class="line">	S-&gt;top  =  S-&gt;top-&gt;next;        </span><br><span class="line">	<span class="comment">/*  释放结点p  */</span></span><br><span class="line">	<span class="built_in">free</span>(p);                                    </span><br><span class="line">	S-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。<br>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。<br>所以它们的区别和线性表中讨论的一样，如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p>
<h3 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h3><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p>
<p>迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。<br>递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。<br>迭代则不需要反复调用函数和占用额外的内存。<br>因此我们应该视不同情况选择不同的代码实现方式。</p>
<p>那么我们讲了这么多递归的内容，和栈有什么关系呢？这得从计算机系统的内部说起。</p>
<p>前面我们已经看到递归是如何执行它的前行和退回阶段的。<br>递归过程退回的顺序是它前行顺序的逆序。<br>在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。<br>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。<br>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。<br>在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。<br>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p>
<h3 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h3><h4 id="后缀（逆波兰）表示法定义"><a href="#后缀（逆波兰）表示法定义" class="headerlink" title="后缀（逆波兰）表示法定义"></a>后缀（逆波兰）表示法定义</h4><p>如果让你用C语言或其他高级语言实现对数学表达式的求值，你打算如何做？</p>
<p>这里面的困难就在于乘除在加减的后面，却要先运算，而加入了括号后，就变得更加复杂。不知道该如何处理。</p>
<p>但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。<br>这用栈结构正好合适，只要碰到左括号，就将此左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈。</p>
<p>但对于四则运算，括号也只是当中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？我们伟大的科学家想到了好办法。</p>
<ul>
<li>后缀（逆波兰）表示法定义</li>
</ul>
<p>对于“9+(3-1)×3+10÷2”，如果要用后缀表示法应该是什么样子：“9 3 1-3*+102/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。显然，这里没有了括号。</p>
<h4 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h4><p>9+(3-1)×3+10÷2<br>后缀表达式：9 3 1-3*+10 2/+<br>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。<br>1．初始化一个空栈。此栈用来对要运算的数字进出使用。<br>2．后缀表达式中前三个都是数字，所以9、3、1进栈。<br><img src="/img/CSDataStructure/23.jpg"><br>3．接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈。<br>4．接着是数字3进栈。<br><img src="/img/CSDataStructure/24.jpg"><br>5．后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。<br>6．下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈。<br><img src="/img/CSDataStructure/25.jpg"><br>7．接着是10与2两数字进栈。<br>8．接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。<br><img src="/img/CSDataStructure/26.jpg"><br>9．最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈。<br>10．结果是20出栈，栈变为空。</p>
<h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p>我们把平时所用的标准四则运算表达式，即“9+(3-1)×3+10÷2”叫做中缀表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化。<br>中缀表达式“9+(3-1)×3+10÷2”转化为后缀表达式“9 3 1-3*+10 2/+”。</p>
<p>规则：<br>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；<br>若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<p>1．初始化一空栈，用来对符号进出栈使用。<br>2．第一个字符是数字9，输出9，后面是符号“+”，进栈。<br><img src="/img/CSDataStructure/27.jpg"><br>3．第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈。<br>4．第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈。<br><img src="/img/CSDataStructure/28.jpg"><br>5．接下来是数字1，输出，总表达式为 9 31，后面是符号“)”，此时，我们需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 9 3 1-。<br>6．紧接着是符号“×”，因为此时的栈顶符号为“+”号，优先级低于“×”，因此不输出，“*”进栈。接着是数字3，输出，总的表达式为 9 3 1-3。<br><img src="/img/CSDataStructure/29.jpg"><br>7．之后是符号“+”，此时当前栈顶元素“ * ”比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为9 3 1-3 *+。然后将当前这个符号“+”进栈。也就是说，前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而图4-9-9左图中的栈底（也是栈顶）的“+”是指“9+(3-1)×3+”中的最后一个“+”。<br>8．紧接着数字10，输出，总表达式变为9 31-3 *+10。后是符号“÷”，所以“/”进栈。<br><img src="/img/CSDataStructure/30.jpg"><br>9．最后一个数字2，输出，总的表达式为9 31-3+10 2。<br>10．因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为93 1-3+10 2/+。<br><img src="/img/CSDataStructure/31.jpg"><br>从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步： 1.将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。 2.将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p>
<p>ADT  队列(Queue)<br>    Data    同线性表。<br>        元素具有相同的类型，相邻元素具有前驱和后继关系。<br>    Operation<br>        InitQueue(*Q):        初始化操作，建立一个空队列Q。<br>        DestroyQueue(*Q):  若队列Q存在，则销毁它。<br>        ClearQueue(*Q):      将队列Q清空。<br>        QueueEmpty(Q):        若队列Q为空，返回true，否则返回false。<br>        GetHead(Q,  *e):      若队列Q存在且非空，用e返回队列Q的队头元素。<br>        EnQueue(*Q,  e):      若队列Q存在，插入新元素e到队列Q中并成为队尾元素。<br>        DeQueue(*Q,  *e):    删除队列Q中队头元素，并用e返回其值。<br>        QueueLength(Q):      返回队列Q的元素个数<br>endADT</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p>
<h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)。</p>
<h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。</p>
<p>循环队列的顺序存储结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  QElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  QElemType;        </span><br><span class="line"><span class="comment">/*  循环队列的顺序存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType  data[MAXSIZE];</span><br><span class="line">	<span class="comment">/*  头指针  */</span></span><br><span class="line">	<span class="keyword">int</span>  front;                        </span><br><span class="line">	<span class="comment">/*  尾指针，若队列不空，指向队列尾元素的下一个位置  */</span></span><br><span class="line">	<span class="keyword">int</span>  rear;                          </span><br><span class="line">&#125;  SqQueue;</span><br></pre></td></tr></table></figure>

<p>循环队列的初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始化一个空队列Q  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InitQueue</span><span class="params">(SqQueue  *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q-&gt;front  =  <span class="number">0</span>;</span><br><span class="line">	Q-&gt;rear  =  <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列求队列长度代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  返回Q的元素个数，也就是队列的当前长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">QueueLength</span><span class="params">(SqQueue  Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  (Q.rear  -  Q.front  +  MAXSIZE)  %  MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列的入队列操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列未满，则插入元素e为Q新的队尾元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">EnQueue</span><span class="params">(SqQueue  *Q,  QElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  队列满的判断  */</span></span><br><span class="line">	<span class="keyword">if</span>  ((Q-&gt;rear  +  <span class="number">1</span>)  %  MAXSIZE  ==  Q-&gt;front)        <span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  将元素e赋值给队尾  */</span></span><br><span class="line">	Q-&gt;data[Q-&gt;rear]  =  e;                     </span><br><span class="line">	<span class="comment">/*  rear指针向后移一位置，  */</span></span><br><span class="line">	Q-&gt;rear  =  (Q-&gt;rear  +  <span class="number">1</span>)  %  MAXSIZE;    <span class="comment">/*  若到最后则转到数组头部  */</span></span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列的出队列操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列不空，则删除Q中队头元素，用e返回其值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">DeQueue</span><span class="params">(SqQueue  *Q,  QElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*  队列空的判断  */</span></span><br><span class="line">	<span class="keyword">if</span>  (Q-&gt;front  ==  Q-&gt;rear)                 <span class="keyword">return</span>  ERROR;</span><br><span class="line">	<span class="comment">/*  将队头元素赋值给e  */</span></span><br><span class="line">	*e  =  Q-&gt;data[Q-&gt;front];                   </span><br><span class="line">	<span class="comment">/*  front指针向后移一位置，  */</span></span><br><span class="line">	Q-&gt;front  =  (Q-&gt;front  +  <span class="number">1</span>)  %  MAXSIZE;  </span><br><span class="line">	<span class="comment">/*  若到最后则转到数组头部  */</span></span><br><span class="line">	<span class="keyword">return</span>    OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p>
<p>链队列的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  QElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  QElemType;</span><br><span class="line">              </span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">QNode</span>                  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">QNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  QNode,  *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  队列的链表结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                             </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  队头、队尾指针  */</span></span><br><span class="line">	QueuePtr  front,  rear;        </span><br><span class="line">&#125;  LinkQueue;</span><br></pre></td></tr></table></figure>

<p>队列的链式存储结构——入队操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为Q的新的队尾元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">EnQueue</span><span class="params">(LinkQueue  *Q,  QElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr  s  =  (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="comment">/*  存储分配失败  */</span></span><br><span class="line">	<span class="keyword">if</span>  (!s)	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	s-&gt;data  =  e;</span><br><span class="line">	s-&gt;next  =  <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  把拥有元素e新结点s赋值给原队尾结点的后继,	*/</span></span><br><span class="line">	Q-&gt;rear-&gt;next  =  s;       </span><br><span class="line">	<span class="comment">/*  把当前的s设置为队尾结点，rear指向s,	*/</span></span><br><span class="line">	Q-&gt;rear  =  s;                    </span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列的链式存储结构——出队操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">DeQueue</span><span class="params">(LinkQueue  *Q,  QElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr  p;</span><br><span class="line">	<span class="keyword">if</span>  (Q-&gt;front  ==  Q-&gt;rear)	<span class="keyword">return</span>  ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  将欲删除的队头结点暂存给p	*/</span>p  =  Q-&gt;front-&gt;next;                   </span><br><span class="line">	<span class="comment">/*  将欲删除的队头结点的值赋值给e  */</span></span><br><span class="line">	*e  =  p-&gt;data;                             </span><br><span class="line">	<span class="comment">/*  将原队头结点后继p-&gt;next赋值给头结点后继，  */</span></span><br><span class="line">	Q-&gt;front-&gt;next  =  p-&gt;next;        </span><br><span class="line">	<span class="comment">/*  若队头是队尾，则删除后将rear指向头结点	*/</span></span><br><span class="line">	<span class="keyword">if</span>  (Q-&gt;rear  ==  p)	Q-&gt;rear  =  Q-&gt;front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。<br>对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。<br>而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>
<h2 id="总结回顾-1"><a href="#总结回顾-1" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>我们这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。<br>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愚人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/">https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://afoolzwt.github.io" target="_blank">愚人のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a></div><div class="post_share"><div class="social-share" data-image="/img/books/DHSJJG.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src="/img/books/ZZJBYY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《两周自制脚本语言》</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/"><img class="next-cover" src="/img/books/csharpTJJC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《C#图解教程》</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/" title="《C#图解教程》"><img class="cover" src="/img/books/csharpTJJC.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">《C#图解教程》</div></div></a></div><div><a href="/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" title="《两周自制脚本语言》"><img class="cover" src="/img/books/ZZJBYY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">《两周自制脚本语言》</div></div></a></div><div><a href="/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="《大话设计模式》"><img class="cover" src="/img/books/dhsjms.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="title">《大话设计模式》</div></div></a></div><div><a href="/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/" title="《大话数据结构》（串）"><img class="cover" src="/img/books/DHSJJG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">《大话数据结构》（串）</div></div></a></div><div><a href="/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/" title="Lua程序设计（语言特性18-23）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">Lua程序设计（语言特性18-23）</div></div></a></div><div><a href="/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/" title="Lua程序设计（Lua语言入门1-8）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">Lua程序设计（Lua语言入门1-8）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/headicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">愚人</div><div class="author-info__description">为做出理想游戏而不懈努力。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AFoolZWT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="toc-text">Chapter 1 数据结构绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-text">数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="toc-text">数据元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">逻辑结构与物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">物理结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E7%AE%97%E6%B3%95"><span class="toc-text">Chapter 2 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">算法的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E6%80%A7"><span class="toc-text">有穷性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="toc-text">确定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text">可行性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-text">正确性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-text">可读性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%A3%AE%E6%80%A7"><span class="toc-text">健壮性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E9%AB%98%E5%92%8C%E5%AD%98%E5%82%A8%E9%87%8F%E4%BD%8E"><span class="toc-text">时间效率高和存储量低</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95"><span class="toc-text">算法效率的度量方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">事后统计方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%89%8D%E5%88%86%E6%9E%90%E4%BC%B0%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-text">事前分析估算方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%9B%E5%A2%9E%E9%95%BF"><span class="toc-text">函数的渐进增长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89"><span class="toc-text">算法时间复杂度定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95"><span class="toc-text">推导大O阶方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E9%98%B6"><span class="toc-text">常数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E9%98%B6"><span class="toc-text">线性阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E9%98%B6"><span class="toc-text">对数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E9%98%B6"><span class="toc-text">平方阶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">常见的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5"><span class="toc-text">最坏情况与平均情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">算法空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线性表的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">线性表的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9A%E4%B9%89"><span class="toc-text">顺序存储定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">顺序存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-text">地址计算方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-text">顺序存储结构的插入与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">获得元素操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">线性表的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8D%E8%B6%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">顺序存储结构不足的解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线性表链式存储结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">头指针与头结点的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0"><span class="toc-text">线性表链式存储结构代码描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">单链表的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-text">单链表的插入与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-text">单链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">单链表的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="toc-text">单链表的整表创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-text">单链表的整表删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">单链表结构与顺序存储结构优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">静态链表的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">静态链表的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">静态链表优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE"><span class="toc-text">总结回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">第四章 栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">栈的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-text">进栈出栈变化形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">栈的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈的顺序存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-text">栈的结构定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C-push"><span class="toc-text">栈的顺序存储结构——进栈操作(push)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88-pop"><span class="toc-text">栈的顺序存储结构——出栈(pop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="toc-text">两栈共享空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">栈的链式存储结构——进栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">栈的链式存储结构——出栈操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">栈的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-text">栈的应用——递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89"><span class="toc-text">递归定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">栈的应用——四则运算表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-text">后缀（逆波兰）表示法定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-text">后缀表达式计算结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">中缀表达式转后缀表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">队列的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">队列顺序存储的不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="toc-text">循环队列定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">队列的链式存储结构及实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE-1"><span class="toc-text">总结回顾</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI事件模块剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析">《U3D高级编程》- UGUI事件模块剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI核心源码剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析">《U3D高级编程》- UGUI核心源码剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- Unity3D中C#的底层原理"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理">《U3D高级编程》- Unity3D中C#的底层原理</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 数据表的种类"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类">《U3D高级编程》- 数据表的种类</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 用户界面系统的比较"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较">《U3D高级编程》- 用户界面系统的比较</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 愚人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2L5WFGGosqmMsQkoWAORAVz8-gzGzoHsz',
      appKey: 'Aw2OnjzWeYL9LYdqwpwuVuXI',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>