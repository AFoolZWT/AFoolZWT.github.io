<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《大话数据结构》（树） | 愚人のblog</title><meta name="keywords" content="学习读物"><meta name="author" content="愚人"><meta name="copyright" content="愚人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 6 树树：    树（Tree）是n（n≥0）个结点的有限集。    n&#x3D;0时称为空树。    在任意一棵非空树中：    （1）有且仅有一个特定的称为根（Root）的结点；    （2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。 树的定义之前我们一直在谈的是一对一的线性结构，可">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话数据结构》（树）">
<meta property="og:url" content="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/index.html">
<meta property="og:site_name" content="愚人のblog">
<meta property="og:description" content="Chapter 6 树树：    树（Tree）是n（n≥0）个结点的有限集。    n&#x3D;0时称为空树。    在任意一棵非空树中：    （1）有且仅有一个特定的称为根（Root）的结点；    （2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。 树的定义之前我们一直在谈的是一对一的线性结构，可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://afoolzwt.github.io/img/books/DHSJJG.jpg">
<meta property="article:published_time" content="2022-07-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-21T14:54:19.398Z">
<meta property="article:author" content="愚人">
<meta property="article:tag" content="学习读物">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://afoolzwt.github.io/img/books/DHSJJG.jpg"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-HqA81hlzlz&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《大话数据结构》（树）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-21 22:54:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="愚人のblog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/headicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: lightblue"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">愚人のblog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《大话数据结构》（树）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-20T16:00:00.000Z" title="发表于 2022-07-21 00:00:00">2022-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-21T14:54:19.398Z" title="更新于 2022-07-21 22:54:19">2022-07-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/">《大话数据结构》</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E6%A0%91/">树</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《大话数据结构》（树）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-6-树"><a href="#Chapter-6-树" class="headerlink" title="Chapter 6 树"></a>Chapter 6 树</h1><p>树：<br>    树（Tree）是n（n≥0）个结点的有限集。<br>    n=0时称为空树。<br>    在任意一棵非空树中：<br>    （1）有且仅有一个特定的称为根（Root）的结点；<br>    （2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>之前我们一直在谈的是一对一的线性结构，可现实中，还有很多一对多的情况需要处理，所以我们需要研究这种一对多的数据结构——“树”，考虑它的各种特性，来解决我们在编程中碰到的相关问题。</p>
<p>对于树的定义还需要强调两点： 1.n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。 2.m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</p>
<h2 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。<br>结点拥有的子树数称为结点的度（De-gree）。<br>度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。<br>除根结点之外，分支结点也称为内部结点。<br>树的度是树内各结点的度的最大值。<br>如图所示，因为这棵树结点的度的最大值是结点D的度，为3，所以树的度也为3。<br><img src="/img/CSDataStructure/41.jpg"></p>
<h2 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h2><p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。<br>对于结点来说其父母同体，唯一的一个，所以只能把它称为双亲了。<br>同一个双亲的孩子之间互称兄弟（Sibling）。<br>结点的祖先是从根到该结点所经分支上的所有结点。<br>所以对于H来说，D、B、A都是它的祖先。<br>反之，以某结点为根的子树中的任一结点都称为该结点的子孙。<br>B的子孙有D、G、H、I，如图所示。<br><img src="/img/CSDataStructure/42.jpg"></p>
<h2 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h2><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。<br>若某结点在第 i 层，则其子树就在第 i+1层。<br>其双亲在同一层的结点互为堂兄弟。<br>显然图中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。<br>树中结点的最大层次称为树的深度（Depth）或高度，当前树的深度为4。<br><img src="/img/CSDataStructure/43.jpg"><br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<p>森林（Forest）是m（m≥0）棵互不相交的树的集合。<br>对树中每个结点而言，其子树的集合即为森林。</p>
<p>对比线性表与树的结构，它们有很大的不同，如图所示。<br><img src="/img/CSDataStructure/44.jpg"></p>
<h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT  树(tree)</span><br><span class="line">	Data	树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">	<span class="function">Operation</span></span><br><span class="line"><span class="function">		<span class="title">InitTree</span><span class="params">(*T)</span>:                           构造空树T。</span></span><br><span class="line"><span class="function">		<span class="title">DestroyTree</span><span class="params">(*T)</span>:                       	销毁树T。</span></span><br><span class="line"><span class="function">		<span class="title">CreateTree</span><span class="params">(*T,  definition)</span>:  			按definition中给出树的定义来构造树。</span></span><br><span class="line"><span class="function">		<span class="title">ClearTree</span><span class="params">(*T)</span>:                          若树T存在，则将树T清为空树。</span></span><br><span class="line"><span class="function">		<span class="title">TreeEmpty</span><span class="params">(T)</span>:                           若T为空树，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span></span><br><span class="line"><span class="function">		<span class="title">TreeDepth</span><span class="params">(T)</span>:                           返回T的深度。</span></span><br><span class="line"><span class="function">		<span class="title">Root</span><span class="params">(T)</span>:                                返回T的根结点。</span></span><br><span class="line"><span class="function">		<span class="title">Value</span><span class="params">(T,  cur_e)</span>:                       cur_e是树T中一个结点，返回此结点的值。</span></span><br><span class="line"><span class="function">		<span class="title">Assign</span><span class="params">(T,  cur_e,  value)</span>:        		给树T的结点cur_e赋值为value。</span></span><br><span class="line"><span class="function">		<span class="title">Parent</span><span class="params">(T,  cur_e)</span>:                      若cur_e是树T的非根结点，则返回它的双亲，否则返回空。</span></span><br><span class="line"><span class="function">		<span class="title">LeftChild</span><span class="params">(T,  cur_e)</span>:                	若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。</span></span><br><span class="line"><span class="function">		<span class="title">RightSibling</span><span class="params">(T,  cur_e)</span>:          		若cur_e有右兄弟，则返回它的右兄弟，否则返回空。</span></span><br><span class="line"><span class="function">		<span class="title">InsertChild</span><span class="params">(*T,  *p,  i,  c)</span>:    		其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第												i棵子树。</span></span><br><span class="line"><span class="function">		<span class="title">DeleteChild</span><span class="params">(*T,  *p,  i)</span>:          		其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。</span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></table></figure>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系，你想想看，数据元素挨个的存储，谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现要求的。<br>不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。<br>我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。</p>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。</p>
<p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p>
<p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p>
<p>以下是我们的双亲表示法的结点结构定义代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的双亲表示法结点结构定义  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_TREE_SIZE  100</span></span><br><span class="line"><span class="comment">/*  树结点的数据类型，目前暂定为整型  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  TElemType;                            </span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">PTNode</span>                              </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  结点数据  */</span></span><br><span class="line">	TElemType  data;                                  </span><br><span class="line">	<span class="comment">/*  双亲位置  */</span></span><br><span class="line">	<span class="keyword">int</span>  parent;                                          </span><br><span class="line">&#125;  PTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  树结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  结点数组  */</span></span><br><span class="line">	PTNode  nodes[MAX_TREE_SIZE];        </span><br><span class="line">	<span class="comment">/*  根的位置和结点数  */</span></span><br><span class="line">	<span class="keyword">int</span>  r,  n;                                              </span><br><span class="line">&#125;  PTree;	</span><br></pre></td></tr></table></figure>

<p>有了这样的结构定义，我们就可以来实现双亲表示法了。<br>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。</p>
<p><img src="/img/CSDataStructure/41.jpg"><br>双亲表示法所示为：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
</tr>
</tbody></table>
<p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。<br>可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。<br>这真是麻烦，能不能改进一下呢？<br>当然可以。<br>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。<br>如果没有孩子的结点，这个长子域就设置为-1。</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
<th>firstchild</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
<td>9</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
<td>-1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
<td>-1</td>
</tr>
</tbody></table>
<p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。<br>甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。</p>
<p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？<br>嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。<br>同样的，如果右兄弟不存在，则赋值为-1，如表所示。</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
<th>rightsib</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
<td>-1</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
<td>-1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
<td>-1</td>
</tr>
</tbody></table>
<p>但如果结点的孩子很多，超过了2个。<br>我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<br>存储结构的设计是一个非常灵活的过程。<br>一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。<br>注意也不是越多越好，有需要时再设计相应的结构。</p>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>换一种完全不同的考虑方法。<br>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。<br>不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p>
<p>方案一：<br>一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值。<br><img src="/img/CSDataStructure/45.jpg"><br>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。<br>不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。</p>
<p>方案二：<br>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数。</p>
<p>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。<br><img src="/img/CSDataStructure/46.jpg"><br>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p>
<p>能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。</p>
<p>仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p>
<p>这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图所示。<br><img src="/img/CSDataStructure/47.jpg"></p>
<p>为此，设计两种结点结构，一个是孩子链表的孩子结点。<br>child  next<br>其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。</p>
<p>另一个是表头数组的表头结点。<br>data  firstchild<br>其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。</p>
<p>以下是我们的孩子表示法的结构定义代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的孩子表示法结构定义  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_TREE_SIZE  100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  孩子结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">CTNode</span>                            </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>  child;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">CTNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  表头结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType  data;</span><br><span class="line">	ChildPtr  firstchild;</span><br><span class="line">&#125;  CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  树结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  结点数组  */</span></span><br><span class="line">	CTBox  nodes[MAX_TREE_SIZE];        </span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  根的位置和结点数  */</span></span><br><span class="line">	<span class="keyword">int</span>  r,n;                                              </span><br><span class="line">&#125;  CTree;</span><br></pre></td></tr></table></figure>
<p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p>
<p>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。<br><img src="/img/CSDataStructure/48.jpg"><br>我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。</p>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结点的兄弟的角度考虑又会如何呢？<br>当然，对于树这样的层级结构来说，只研究结点的兄弟是不行的，我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p>
<p>结点结构如下所示。<br>data  firstchild  rightsib</p>
<p>其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，right-sib是指针域，存储该结点的右兄弟结点的存储地址。</p>
<p>结构定义代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的孩子兄弟表示法结构定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">CSNode</span>  *<span class="title">firstchild</span>,  *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;  CSNode,  *CSTree;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSDataStructure/49.jpg"></p>
<p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。<br>当然，如果想找某个结点的双亲，这个表示法也是有缺陷的，那怎么办呢？<br>对，如果真的有必要，完全可以再增加一个parent指针域来解决快速查找双亲的问题，这里就不再细谈了。<br>其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。<br>如图所示。<br><img src="/img/CSDataStructure/50.jpg"></p>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><h2 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h2><p>二叉树的特点有：<br>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。<br>注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。<br>左子树和右子树是有顺序的，次序不能任意颠倒。<br>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p>
<p>二叉树具有五种基本形态：<br>1.空二叉树。<br>2.只有一个根结点。<br>3.根结点只有左子树。<br>4.根结点只有右子树。<br>5.根结点既有左子树又有右子树。</p>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><p>1．斜树</p>
<p>顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。<br>斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。</p>
<p>其实线性表结构就可以理解为是树的一种极其特殊的表现形式。</p>
<p>2．满二叉树</p>
<p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<p>单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。<br>因此，满二叉树的特点有：<br>（1）叶子只能出现在最下一层。出现在其他层就不可能达成平衡。<br>（2）非叶子结点的度一定是2。<br>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。<br><img src="/img/CSDataStructure/51.jpg"></p>
<p>3．完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树，如图所示。<br><img src="/img/CSDataStructure/52.jpg"></p>
<p>这是一种有些理解难度的特殊二叉树。<br>首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。<br>其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。<br>这里有个关键词是按层序编号，像图中的树1，因为5结点没有左子树，却有右子树，那就使得按层序编号的第10个编号空档了。<br>同样道理，图中的树2，由于3结点没有子树，所以使得6、7编号的位置空档了。<br>图中的树3又是因为5编号下没有子树造成第10和第11位置空档。<br>只有上图中的树，尽管它不是满二叉树，但是编号是连续的，所以它是完全二叉树。<br><img src="/img/CSDataStructure/53.jpg"><br>从这里我也可以得出一些完全二叉树的特点：<br>（1）叶子结点只能出现在最下两层。<br>（2）最下层的叶子一定集中在左部连续位置。<br>（3）倒数二层，若有叶子结点，一定都在右部连续位置。<br>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。<br>（5）同样结点数的二叉树，完全二叉树的深度最小。</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p>
<h3 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h3><p>性质1：在二叉树的第i层上至多有2i-1个结点（i≥1）。</p>
<p>第一层是根结点，只有一个，所以21-1=20=1。<br>第二层有两个，22-1=21=2。<br>第三层有四个，23-1=22=4。<br>第四层有八个，24-1=23=8。<br>通过数据归纳法的论证，可以很容易得出在二叉树的第i层上至多有2i-1个结点（i≥1）的结论。</p>
<h3 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h3><p>性质2：深度为k的二叉树至多有2k-1个结点（k≥1）。</p>
<p>注意这里一定要看清楚，是2k后再减去1，而不是2k-1。</p>
<p>深度为k意思就是有k层的二叉树，我们先来看看简单的。<br>如果有一层，至多1=21-1个结点。<br>如果有二层，至多1+2=3=22-1个结点。<br>如果有三层，至多1+2+4=7=23-1个结点。<br>如果有四层，至多1+2+4+8=15=24-1个结点。<br>通过数据归纳法的论证，可以得出，如果有k层，此二叉树至多有2k-1个结点。</p>
<h3 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h3><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</p>
<p>终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。<br>则树T结点总数n=n0+n1+n2。<br>如图的例子，结点总数为10，它是由A、B、C、D等度为2结点，F、G、H、I、J等度为0的叶子结点和E这个度为1的结点组成。总和为4+1+5=10。<br><img src="/img/CSDataStructure/54.jpg"><br>我们换个角度，再数一数它的连接线数，由于根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1。图中就是9个分支。对于A、B、C、D结点来说，它们都有两个分支线出去，而E结点只有一个分支线出去。所以总分支线为4×2+1×1=9。</p>
<p>用代数表达就是分支线总数=n-1=n1＋2n2。因为刚才我们有等式n=n0＋n1＋n2，所以可推导出n0＋n1＋n2-1=n1＋2n2。结论就是n0=n2＋1。</p>
<h3 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h3><p>性质4：具有n个结点的完全二叉树的深度为|log2n+1|。</p>
<p>由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。</p>
<p>完全二叉树我们前面已经提到，它是一棵具有n个结点的二叉树，若按层序编号后其编号与同样深度的满二叉树中编号结点在二叉树中位置完全相同，那它就是完全二叉树。<br>也就是说，它的叶子结点只会出现在最下面的两层。</p>
<p>它的结点数一定少于等于同样深度的满二叉树的结点数2k-1，但一定多于2k-1-1。即满足2k-1-1&lt;n≤2k-1。由于结点数n是整数，n≤2k-1意味着n&lt;2k，n&gt;2k-1-1，意味着n≥2k-1，所以2k-1≤n&lt;2k，不等式两边取对数，得到k-1≤log2n&lt;k，而k作为深度也是整数，因此k=|log2n|+1。</p>
<h3 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h3><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：<br>1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。<br>2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。<br>3．如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</p>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p>
<p>先来看看完全二叉树的顺序存储，一棵完全二叉树如图所示。<br><img src="/img/CSDataStructure/55.jpg"><br>将这棵二叉树存入到数组中，相应的下标对应其同样的位置，如图所示。<br><img src="/img/CSDataStructure/56.jpg"><br>由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。</p>
<p>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“∧”而已。如图，浅色结点表示不存在。<br><img src="/img/CSDataStructure/57.jpg"></p>
<p>考虑一种极端的情况，一棵深度为k的右斜树，它只有k个结点，却需要分配2k-1个存储单元空间，这显然是对存储空间的浪费，如图所示。所以，顺序存储结构一般只用于完全二叉树。<br><img src="/img/CSDataStructure/58.jpg"></p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>既然顺序存储适用性不强，我们就要考虑链式存储结构。<br>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p>
<p>结点结构如下。<br>lchild  data  rchild<br>其中data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。</p>
<p>以下是我们的二叉链表的结点结构定义代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉链表结点结构定义  */</span></span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>                                 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*  结点数据  */</span></span><br><span class="line">	TElemType  data;                                         </span><br><span class="line">	<span class="comment">/*  左右孩子指针  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span>        </span><br><span class="line">&#125;  BiTNode,  *BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/img/CSDataStructure/59.jpg"><br>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。</p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h2 id="二叉树遍历原理"><a href="#二叉树遍历原理" class="headerlink" title="二叉树遍历原理"></a>二叉树遍历原理</h2><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。<br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。</p>
<h2 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如图所示，遍历的顺序为：ABDGH-CEIF。<br><img src="/img/CSDataStructure/60.jpg"></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图所示，遍历的顺序为：GDHBAE-ICF。<br><img src="/img/CSDataStructure/61.jpg"></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图所示，遍历的顺序为：GHDBIEFCA。<br><img src="/img/CSDataStructure/62.jpg"></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图所示，遍历的顺序为：ABCDEFGHI。<br><img src="/img/CSDataStructure/63.jpg"></p>
<p>不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种处理。</p>
<h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的前序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PreOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                    </span><br><span class="line">	<span class="comment">/*  再先序遍历左子树  */</span></span><br><span class="line">	PreOrderTraverse(T-&gt;lchild);        </span><br><span class="line">	<span class="comment">/*  最后先序遍历右子树  */</span></span><br><span class="line">	PreOrderTraverse(T-&gt;rchild);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假设我们现在有如图这样一棵二叉树T。这树已经用二叉链表结构存储在内存当中。<br><img src="/img/CSDataStructure/64.jpg"><br>那么当调用PreOrderTraverse(T)函数时，我们来看看程序是如何运行的。<br>1．调用PreOrderTraverse(T)，T根结点不为null，所以执行printf，打印字母A，如图所示。<br><img src="/img/CSDataStructure/65.jpg"><br>2．调用PreOrderTraverse(T-&gt;lchild);访问了A结点的左孩子，不为null，执行printf显示字母B，如图所示。<br><img src="/img/CSDataStructure/66.jpg"><br>3．此时再次递归调用PreOrderTraverse(T-&gt;lchild);访问了B结点的左孩子，执行printf显示字母D，如图所示。<br><img src="/img/CSDataStructure/67.jpg"><br>4．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了D结点的左孩子，执行printf显示字母H，如图所示。<br><img src="/img/CSDataStructure/68.jpg"><br>5．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了H结点的左孩子，此时因为H结点无左孩子，所以T==null，返回此函数，此时递归调用PreOrderTraverse(T-&gt;rchild);访问了H结点的右孩子，printf显示字母K，如图所示。<br><img src="/img/CSDataStructure/69.jpg"><br>6．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了K结点的左孩子，K结点无左孩子，返回，调用PreOrderTra-verse(T-&gt;rchild);访问了K结点的右孩子，也是null，返回。于是此函数执行完毕，返回到上一级递归的函数（即打印H结点时的函数），也执行完毕，返回到打印结点D时的函数，调用PreOrderTraverse(T-&gt;rchild);访问了D结点的右孩子，不存在，返回到B结点，调用PreOrderTra-verse(T-&gt;rchild);找到了结点E，打印字母E，如图所示。<br><img src="/img/CSDataStructure/70.jpg"><br>7．由于结点E没有左右孩子，返回打印结点B时的递归函数，递归执行完毕，返回到最初的PreOrderTraverse，调用PreOrderTra-verse(T-&gt;rchild);访问结点A的右孩子，打印字母C，如图所示。<br><img src="/img/CSDataStructure/71.jpg"><br>8．之后类似前面的递归调用，依次继续打印F、I、G、J，步骤略。</p>
<p>综上，前序遍历这棵二叉树的节点顺序是：AB-DHKECFIGJ。</p>
<h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的中序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*  中序遍历左子树  */</span></span><br><span class="line">	InOrderTraverse(T-&gt;lchild);        </span><br><span class="line">	<span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                  </span><br><span class="line">	<span class="comment">/*  最后中序遍历右子树  */</span></span><br><span class="line">	InOrderTraverse(T-&gt;rchild);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看当调用InOrder-Traverse(T)函数时，程序是如何运行的。</p>
<p>1．调用InOrderTraverse(T)，T的根结点不为null，于是调用InOrderTraverse(T-&gt;lchild);访问结点B。当前指针不为null，继续调用InOrderTraverse(T-&gt;lchild);访问结点D。不为null，继续调用InOrderTraverse(T-&gt;lchild);访问结点H。继续调用InOrderTraverse(T-&gt;lchild);访问结点H的左孩子，发现当前指针为null，于是返回。打印当前结点H，如图所示。<br><img src="/img/CSDataStructure/72.jpg"><br>2．然后调用InOrderTraverse(T-&gt;rchild);访问结点H的右孩子K，因结点K无左孩子，所以打印K，如图所示。<br><img src="/img/CSDataStructure/73.jpg"><br>3．因为结点K没有右孩子，所以返回。打印结点H函数执行完毕，返回。打印字母D，如图所示。<br><img src="/img/CSDataStructure/74.jpg"><br>4．结点D无右孩子，此函数执行完毕，返回。打印字母B，如图所示。<br><img src="/img/CSDataStructure/75.jpg"><br>5．调用InOrderTraverse(T-&gt;rchild);访问结点B的右孩子E，因结点E无左孩子，所以打印E，如图所示。<br><img src="/img/CSDataStructure/76.jpg"><br>6．结点E无右孩子，返回。结点B的递归函数执行完毕，返回到了最初我们调用In-OrderTraverse的地方，打印字母A，如图所示。<br><img src="/img/CSDataStructure/77.jpg"><br>7．再调用InOrderTraverse(T-&gt;rchild);访问结点A的右孩子C，再递归访问结点C的左孩子F，结点F的左孩子I。因为I无左孩子，打印I，之后分别打印F、C、G、J。步骤省略。</p>
<p>综上，中序遍历这棵二叉树的节点顺序是：HKDBEAIFCGJ。</p>
<h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的后序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PostOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*  先后序遍历左子树  */</span></span><br><span class="line">	PostOrderTraverse(T-&gt;lchild);        </span><br><span class="line">	<span class="comment">/*  再后序遍历右子树  */</span>PostOrderTraverse(T-&gt;rchild);        </span><br><span class="line">	<span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，后序遍历是先递归左子树，由根结点A→B→D→H，结点H无左孩子，再查看结点H的右孩子K，因为结点K无左右孩子，所以打印K，返回。<br><img src="/img/CSDataStructure/78.jpg"><br>最终，后序遍历的结点的顺序就是：KHDEB-IFJGCA。</p>
<h2 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h2><p>有一种题目为了考查你对二叉树遍历的掌握程度，是这样出题的。<br>已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，请问这棵二叉树的后序遍历结果是多少？</p>
<p>三种遍历都是从根结点开始，前序遍历是先打印再递归左和右。所以前序遍历序列为ABCDEF，第一个字母是A被打印出来，就说明A是根结点的数据。</p>
<p>再由中序遍历序列是CBAEDF，可以知道C和B是A的左子树的结点，E、D、F是A的右子树的结点，如图所示。<br><img src="/img/CSDataStructure/79.jpg"></p>
<p>然后我们看前序中的C和B，它的顺序是ABCDEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定。<br>再看中序序列是CBAEDF，C是在B的前面打印，这就说明C是B的左孩子，否则就是右孩子了，如图所示。<br><img src="/img/CSDataStructure/80.jpg"></p>
<p>再看前序中的E、D、F，它的顺序是ABCDEF，那就意味着D是A结点的右孩子，E和F是D的子孙，注意，它们中有一个不一定是孩子，还有可能是孙子的。再来看中序序列是CBAEDF，由于E在D的左侧，而F在右侧，所以可以确定E是D的左孩子，F是D的右孩子。因此最终得到的二叉树如图所示。<br><img src="/img/CSDataStructure/81.jpg"></p>
<p>从这里我们也得到两个二叉树遍历的性质：<br>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。<br>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</p>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  按前序输入二叉树中结点的值（一个字符）  */</span></span><br><span class="line"><span class="comment">/*  #表示空树，构造二叉链表表示二叉树T。  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateBiTree</span><span class="params">(BiTree  *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	TElemType  ch;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,  &amp;ch);</span><br><span class="line">	<span class="keyword">if</span>  (ch  ==  <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*T  =  <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T  =  (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		<span class="keyword">if</span>  (!*T)	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="comment">/*  生成根结点  */</span></span><br><span class="line">		(*T)-&gt;data  =  ch;                             </span><br><span class="line">		<span class="comment">/*  构造左子树  */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;lchild);        </span><br><span class="line">		<span class="comment">/*  构造右子树  */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;rchild);        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h3><p>对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线数，也就是说，其实是存在2n-(n-1)=n＋1个空指针域。<br>这些空间不存储任何事物，白白的浪费着内存的资源。</p>
<p>在二叉链表上，我们只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。<br>要想知道，必须遍历一次。以后每次需要知道时，都必须先遍历一次。为什么不考虑在创建时就记住这些前驱和后继呢，那将是多大的时间上的节省。</p>
<p>综合刚才两个角度的分析后，我们可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址。</p>
<p>我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p>
<p>如图，我们把这棵二叉树进行中序遍历后，将所有的空指针域中的rchild，改为指向它的后继结点。于是我们就可以通过指针知道H的后继是D（图中①），I的后继是B（图中②），J的后继是E（图中③），E的后继是A（图中④），F的后继是C（图中⑤），G的后继因为不存在而指向NULL（图中⑥）。此时共有6个空指针域被利用。<br><img src="/img/CSDataStructure/82.jpg"></p>
<p>再看图，我们将这棵二叉树的所有空指针域中的lchild，改为指向当前结点的前驱。因此H的前驱是NULL（图中①），I的前驱是D（图中②），J的前驱是B（图中③），F的前驱是A（图中④），G的前驱是C（图中⑤）。一共5个空指针域被利用，正好和上面的后继加起来是11个。<br><img src="/img/CSDataStructure/83.jpg"></p>
<p>通过下图（空心箭头实线为前驱，虚线黑箭头为后继），就更容易看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。<br><img src="/img/CSDataStructure/84.jpg"></p>
<p>不过好事总是多磨的，问题并没有彻底解决。<br>我们如何知道某一结点的lchild是指向它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？<br>比如E结点的lchild是指向它的左孩子J，而rchild却是指向它的后继A。<br>显然我们在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继上是需要一个区分标志的。<br>因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。</p>
<p>其中：<br>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。<br>rtag为0时指向该结点的右孩子，为1时指向该结点的后继。<br>因此对于此前的二叉链表图可以修改为下图的样子。<br><img src="/img/CSDataStructure/85.jpg"></p>
<h3 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h3><p>二叉树的线索存储结构定义代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉线索存储结构定义  */</span></span><br><span class="line"><span class="comment">/*  Link==0表示指向左右孩子指针  */</span></span><br><span class="line"><span class="comment">/*  Thread==1表示指向前驱或后继的线索  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">enum</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Link,  </span><br><span class="line">	Thread,</span><br><span class="line">&#125;  PointerTag;        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  二叉线索存储结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiThrNode</span>                                     </span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">	<span class="comment">/*  结点数据  */</span></span><br><span class="line">	TElemType  data;                                               </span><br><span class="line">	<span class="comment">/*  左右孩子指针  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">BiThrNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="comment">/*  左右标志  */</span>         </span><br><span class="line">	PointerTag  LTag;</span><br><span class="line">	PointerTag  RTag;                                             </span><br><span class="line"> &#125;  BiThrNode,  *BiThrTree;</span><br></pre></td></tr></table></figure>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p>
<p>中序遍历线索化的递归函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  全局变量，始终指向刚刚访问过的结点  */</span></span><br><span class="line">BiThrTree  pre;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  中序遍历进行中序线索化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InThreading</span><span class="params">(BiThrTree  p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  (p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  递归左子树线索化  */</span></span><br><span class="line">		InThreading(p-&gt;lchild);        </span><br><span class="line">		<span class="comment">/*  没有左孩子  */</span></span><br><span class="line">		<span class="keyword">if</span>  (!p-&gt;lchild)                        </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*  前驱线索  */</span></span><br><span class="line">			p-&gt;LTag  =  Thread;            </span><br><span class="line">			<span class="comment">/*  左孩子指针指向前驱  */</span></span><br><span class="line">			p-&gt;lchild  =  pre;              </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*  前驱没有右孩子  */</span></span><br><span class="line">		<span class="keyword">if</span>  (!pre-&gt;rchild)                    </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*  后继线索  */</span></span><br><span class="line">			pre-&gt;RTag  =  Thread;        </span><br><span class="line">			<span class="comment">/*  前驱右孩子指针指向后继（当前结点p）  */</span></span><br><span class="line">			pre-&gt;rchild  =  p;              </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*  保持pre指向p的前驱  */</span></span><br><span class="line">		pre  =  p;                                      </span><br><span class="line">		<span class="comment">/*  递归右子树线索化  */</span></span><br><span class="line">		InThreading(p-&gt;rchild);        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if(!p-&gt;lchild)表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lchild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。</p>
<p>后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线索化。</p>
<p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。</p>
<p>和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。<br>反之，令二叉树的中序序列中的第一个结点中，lchild域指针和最后一个结点的rchild域指针均指向头结点（图中的③和④）。<br>这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br><img src="/img/CSDataStructure/86.jpg"></p>
<p>遍历的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的  */</span></span><br><span class="line"><span class="comment">/*  最后一个结点。中序遍历二叉线索链表表示的二叉树T  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiThrTree  p;</span><br><span class="line">	<span class="comment">/*  p指向根结点  */</span></span><br><span class="line">	p  =  T-&gt;lchild;                                  </span><br><span class="line">	<span class="comment">/*  空树或遍历结束时，p==T  */</span></span><br><span class="line">	<span class="keyword">while</span>  (p  !=  T)                                  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*  当LTag==0时循环到中序序列第一个结点  */</span></span><br><span class="line">		<span class="keyword">while</span>  (p-&gt;LTag  ==  Link)        p  =  p-&gt;lchild;</span><br><span class="line">		<span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  p-&gt;data);          </span><br><span class="line">		<span class="keyword">while</span>  (p-&gt;RTag  ==  Thread  &amp;&amp;  p-&gt;rchild  !=  T)</span><br><span class="line">		&#123;</span><br><span class="line">			p  =  p-&gt;rchild;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  p-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*  p进至其右子树根  */</span></span><br><span class="line">		p  =  p-&gt;rchild;                          </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  OK;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>1.代码中，第4行，p=T-&gt;lchild;意思就是图中的①，让p指向根结点开始遍历。</p>
<p>2.第5～16行，while(p!=T)其实意思就是循环直到图中的④的出现，此时意味着p指向了头结点，于是与T相等（T是指向头结点的指针），结束循环，否则一直循环下去进行遍历操作。</p>
<p>3.第7～8行，while(p-&gt;LTag==Link)这个循环，就是由A→B→D→H，此时H结点的LTag不是Link（就是不等于0），所以结束此循环。</p>
<p>4.第9行，打印H。</p>
<p>5.第10～14行，while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)，由于结点H的RTag==Thread（就是等于1），且不是指向头结点。因此打印H的后继D，之后因为D的RTag是Link，因此退出循环。</p>
<p>6.第15行，p=p-&gt;rchild;意味着p指向了结点D的右孩子I。</p>
<p>7.……，就这样不断循环遍历，直到打印出HDIBJEAFCG，结束遍历操作。</p>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。</p>
<p>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。<br>所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>
<h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p>我们前面已经讲过了树的定义和存储结构，对于树来说，在满足树的条件下可以是任意形状，一个结点可以有任意多个孩子，显然对树的处理要复杂得多，去研究关于树的性质和算法，真的不容易。有没有简单的办法解决对树处理的难题呢？</p>
<p>我们前面也讲了二叉树，尽管它也是树，但由于每个结点最多只能有左孩子和右孩子，面对的变化就少很多了。因此很多性质和算法都被研究了出来。如果所有的树都像二叉树一样方便就好了。你还别说，真是可以这样做。</p>
<p>在讲树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的二叉链表也是相同的，只是解释不太一样而已。因此，只要我们设定一定的规则，用二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。<br>我们分别来看看它们之间的转换如何进行。</p>
<h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将树转换为二叉树的步骤如下 ：<br>1.加线。在所有兄弟结点之间加一条连线。<br>2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。<br>3.层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><img src="/img/CSDataStructure/87.jpg"></p>
<h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。<br>步骤如下：<br>1.把每个树转换为二叉树。<br>2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。<br>当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</p>
<p>如图，将森林的三棵树转化为一棵二叉树。<br><img src="/img/CSDataStructure/88.jpg"></p>
<h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。<br>如图所示。步骤如下：<br>1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。<br>2.去线。删除原二叉树中所有结点与其右孩子结点的连线。<br>3.层次调整。使之结构层次分明。<br><img src="/img/CSDataStructure/89.jpg"></p>
<h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>那么如果是转换成森林，步骤如下：<br>1.从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。<br>2.再将每棵分离后的二叉树转换为树即可。<br><img src="/img/CSDataStructure/90.jpg"></p>
<h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历分为两种方式：<br>1.一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。<br>2.另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。<br>比如图【二叉树转换为树】中右下方的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</p>
<p>森林的遍历也分为两种方式：<br>1.前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图【二叉树转换为森林】下面三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。<br>2.后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图【二叉树转换为森林】下面三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</p>
<p>可如果我们对图【二叉树转换为森林】的左侧二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p>
<p>这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。<br>这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。</p>
<h2 id="赫夫曼数及其应用"><a href="#赫夫曼数及其应用" class="headerlink" title="赫夫曼数及其应用"></a>赫夫曼数及其应用</h2><p>压缩而不出错是如何做到的呢？<br>简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。<br>尽管现在最新技术在编码上已经很好很强大，但这一切都来自于曾经的技术积累，我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。</p>
<h3 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h3><p>我们先把这两棵二叉树简化成叶子结点带权的二叉树（注：树结点间的边相关的数叫做权Weight），如图所示。<br>其中A表示不及格、B表示及格、C表示中等、D表示良好、E表示优秀。<br>每个叶子的分支线上的数字就是刚才我们提到的五级分制的成绩所占百分比。<br><img src="/img/CSDataStructure/91.jpg"><br>赫夫曼大叔说，从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。<br>    二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到结点D的路径长度为2。</p>
<p>树的路径长度就是从树根到每一结点的路径长度之和。<br>    二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16。</p>
<p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。<br>树的带权路径长度为树中所有叶子结点的带权路径长度之和。</p>
<p>假设有n个权值{w1,w2,…,wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称做赫夫曼树。</p>
<p>有了赫夫曼对带权路径长度的定义，我们来计算一下图中这两棵树的WPL值。<br>    二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>    注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>    二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>这样的结果意味着什么呢？<br>如果我们现在有10000个学生的百分制成绩需要计算五级分制成绩，用二叉树a的判断方法，需要做31500次比较，而二叉树b的判断方法，只需要22000次比较，差不多少了三分之一量，在性能上提高不是一点点。</p>
<p>那么现在的问题就是，图中的二叉树b这样的树是如何构造出来的，这样的二叉树是不是就是最优的赫夫曼树呢？<br>别急，赫夫曼大叔给了我们解决的办法。</p>
<ul>
<li>1．先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li>
<li>2．取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图所示。新结点的权值为两个叶子权值的和5+10=15。<br><img src="/img/CSDataStructure/92.jpg"></li>
<li>3．将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B 15，D 30，C 40。</li>
<li>4．重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图所示。N2的权值=15+15=30。<br><img src="/img/CSDataStructure/93.jpg"></li>
<li>5．将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N230，D30，C40。</li>
<li>6．重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图所示。N3的权值=30+30=60。<br><img src="/img/CSDataStructure/94.jpg"></li>
<li>7．将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N360。</li>
<li>8．重复步骤2。将C与N3作为一个新节点T的两个子结点，如图所示。由于T即是根结点，完成赫夫曼树的构造。<br><img src="/img/CSDataStructure/95.jpg"></li>
</ul>
<p>此时的图二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与之前的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。</p>
<p>不过现实总是比理想要复杂得多，图虽然是赫夫曼树，但由于每次判断都要两次比较（如根结点就是a&lt;80&amp;&amp;a&gt;=70，两次比较才能得到y或n的结果），所以总体性能上，反而不如图的二叉树性能高。当然这并不是我们要讨论的重点了。</p>
<p>通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p>
<ul>
<li>1.根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F={T1,T2,…,Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li>
<li>2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>3.在F中删除这两棵树，同时将新得到的二叉树加入F中。</li>
<li>4.重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。<h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3>赫夫曼研究这种最优树的目的不是为了我们可以转化一下成绩。他的更大目的是为了解决当年远距离通信（主要是电报）的数据传输的最优化问题。</li>
</ul>
<p>比如我们有一段文字内容为“BADCADFEED”要网络传输给别人，显然用二进制的数字（0和1）来表示是很自然的想法。我们现在这段文字只有六个字母ABCDEF，那么我们可以用相应的二进制数据表示，如表所示。<br><img src="/img/CSDataStructure/96.jpg"><br>这样真正传输的数据就是编码后的“001000011010000011101100100011”，对方接收时可以按照3位一分来译码。<br>如果一篇文章很长，这样的二进制串也将非常的可怕。<br>而且事实上，不管是英文、中文或是其他语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母“ae i o u”，中文中的“的 了 有 在”等汉字都是频率极高。<br>假设六个字母的频率为A 27，B 8，C 15，D15，E 30，F 5，合起来正好是100%。<br>那就意味着，我们完全可以重新按照赫夫曼树来规划它们。</p>
<p><img src="/img/CSDataStructure/97.jpg"><br>左图为构造赫夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的赫夫曼树。</p>
<p><img src="/img/CSDataStructure/98.jpg"><br>此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如表所示这样的定义。</p>
<p>我们将文字内容为“BADCADFEED”再次编码，对比可以看到结果串变小了。<br>原编码二进制串：001000011010000011101100100011（共30个字符）<br>新编码二进制串：1001010010101001000111100（共25个字符）</p>
<p>也就是说，我们的数据被压缩了，节约了大约17%的存储或传输成本。随着字符的增加和多字符权重的不同，这种压缩会更加显出其优势。<br>当我们接收到1001010010101001000111100这样压缩过的新编码时，我们应该如何把它解码出来呢？</p>
<p>编码中非0即1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。<br>你仔细观察就会发现，上表中的编码就不存在容易与1001、1000混淆的“10”和“100”编码。</p>
<p>可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。</p>
<p>当我们接收到1001010010101001000111100时，由约定好的赫夫曼树可知，1001得到第一个字母是B，接下来01意味着第二个字符是A，如图6-12-10所示，其余的也相应的可以得到，从而成功解码。<br><img src="/img/CSDataStructure/99.jpg"><br>一般地，设需要编码的字符集为{d1,d2,…,dn}，各个字符在电文中出现的次数或频率集合为{w1,w2,…,wn}，以d1,d2,…,dn作为叶子结点，以w1,w2,…,wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>
<h1 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h1><p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。<br>即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>开头我们提到了树的定义，讲到了递归在树定义中的应用。<br>提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>二叉树的建立自然也是可以通过递归来实现。<br>研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愚人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/">https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://afoolzwt.github.io" target="_blank">愚人のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a></div><div class="post_share"><div class="social-share" data-image="/img/books/DHSJJG.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/"><img class="prev-cover" src="/img/books/DHSJJG.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《大话数据结构》（串）</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/21/CSDataStructure/DataStructure5(%E6%9F%A5%E6%89%BE)/"><img class="next-cover" src="/img/books/DHSJJG.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《大话数据结构》（查找）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/" title="《C#图解教程》"><img class="cover" src="/img/books/csharpTJJC.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">《C#图解教程》</div></div></a></div><div><a href="/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" title="《两周自制脚本语言》"><img class="cover" src="/img/books/ZZJBYY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">《两周自制脚本语言》</div></div></a></div><div><a href="/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="《大话设计模式》"><img class="cover" src="/img/books/dhsjms.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="title">《大话设计模式》</div></div></a></div><div><a href="/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/" title="《大话数据结构》（串）"><img class="cover" src="/img/books/DHSJJG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">《大话数据结构》（串）</div></div></a></div><div><a href="/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/" title="Lua程序设计（语言特性18-23）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">Lua程序设计（语言特性18-23）</div></div></a></div><div><a href="/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/" title="Lua程序设计（Lua语言入门1-8）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">Lua程序设计（Lua语言入门1-8）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/headicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">愚人</div><div class="author-info__description">为做出理想游戏而不懈努力。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AFoolZWT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-%E6%A0%91"><span class="toc-text">Chapter 6 树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB"><span class="toc-text">结点分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-text">结点间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">树的其他相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">树的抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">孩子表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9"><span class="toc-text">二叉树特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">特殊二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A81"><span class="toc-text">二叉树的性质1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A82"><span class="toc-text">二叉树的性质2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A83"><span class="toc-text">二叉树的性质3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A84"><span class="toc-text">二叉树的性质4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A85"><span class="toc-text">二叉树的性质5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二叉树顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">遍历二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86"><span class="toc-text">二叉树遍历原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text">二叉树遍历方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">前序遍历算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">中序遍历算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">后序遍历算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C"><span class="toc-text">推导遍历结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">二叉树的建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8E%9F%E7%90%86"><span class="toc-text">线索二叉树原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">线索二叉树结构实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">树转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">森林转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-text">二叉树转换为树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-text">二叉树转换为森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">树与森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-text">赫夫曼数及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">赫夫曼树定义与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">赫夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE"><span class="toc-text">总结回顾</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI事件模块剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析">《U3D高级编程》- UGUI事件模块剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI核心源码剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析">《U3D高级编程》- UGUI核心源码剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- Unity3D中C#的底层原理"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理">《U3D高级编程》- Unity3D中C#的底层原理</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 数据表的种类"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类">《U3D高级编程》- 数据表的种类</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 用户界面系统的比较"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较">《U3D高级编程》- 用户界面系统的比较</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 愚人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2L5WFGGosqmMsQkoWAORAVz8-gzGzoHsz',
      appKey: 'Aw2OnjzWeYL9LYdqwpwuVuXI',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>