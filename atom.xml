<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愚人のblog</title>
  
  <subtitle>你好啊</subtitle>
  <link href="https://afoolzwt.github.io/atom.xml" rel="self"/>
  
  <link href="https://afoolzwt.github.io/"/>
  <updated>2023-03-22T15:47:23.037Z</updated>
  <id>https://afoolzwt.github.io/</id>
  
  <author>
    <name>愚人</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《大话设计模式》</title>
    <link href="https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2023-03-22T15:47:23.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter3-单一职责原则"><a href="#Chapter3-单一职责原则" class="headerlink" title="Chapter3 单一职责原则"></a>Chapter3 单一职责原则</h1><ul><li>单一职责原则(SRP):就一个类而言，应该仅有一个引起它变化的原因。<h1 id="Chapter4-开放-封闭原则"><a href="#Chapter4-开放-封闭原则" class="headerlink" title="Chapter4 开放-封闭原则"></a>Chapter4 开放-封闭原则</h1></li><li>开放-封闭原则:软件实体(类、模块、函数等)应该可以扩展，但是不可修改。<h1 id="Chapter5-依赖倒转原则"><a href="#Chapter5-依赖倒转原则" class="headerlink" title="Chapter5 依赖倒转原则"></a>Chapter5 依赖倒转原则</h1></li><li>依赖倒转原则:</li></ul><p>1.高层模块不应该依赖底层模块。两个都应该依赖抽象。<br>2.抽象不应该依赖细节，细节应该依赖于抽象。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ul><li>里氏替换原则(LSP):子类型必须能够替换掉他们的父类型。<h1 id="Chapter6-装饰模式"><a href="#Chapter6-装饰模式" class="headerlink" title="Chapter6 装饰模式"></a>Chapter6 装饰模式</h1></li><li>装饰模式(Decorater):动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</li></ul><p>Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。<br>至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p><p>Component类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Operation（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteComponent类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Operation（）</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine（<span class="string">&quot;具体对象的操作&quot;</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decorator类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Decorator</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">protect Component component;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetComponent</span>(<span class="params">Component component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(component != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">component.Operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorA类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//本类的独有功能，以区别于ConcreteDecoratorB</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> addedState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先运行原Component的Operation()，再执行本类的功能，</span></span><br><span class="line"><span class="comment">//如addedState,相当于对原Component进行了装饰。</span></span><br><span class="line"><span class="keyword">base</span>.operation();</span><br><span class="line">addedState = <span class="string">&quot;New State&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;具体装饰对象A的操作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">base</span>.operation();</span><br><span class="line">AddedBehavior();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;具体装饰对象B的操作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddedBehavior</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ConcreteComponent c = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">ConcreteDecoratorA d1 = <span class="keyword">new</span> ConcreteDecoratorA();</span><br><span class="line">ConcreteDecoratorB d2 = <span class="keyword">new</span> ConcreteDecoratorB();</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰的方法是：首先用ConcreteComponent实例化对象c,</span></span><br><span class="line"><span class="comment">//然后用ConcreteDecoratorA的实例化对象d1来包装c,</span></span><br><span class="line"><span class="comment">//再用ConcreteDecoratorB的对象d2包装d1,</span></span><br><span class="line"><span class="comment">//最终执行d2的Operation()</span></span><br><span class="line">d1.SetComponent(c);</span><br><span class="line">d2.SetComponent(d1);</span><br><span class="line">d2.operation();</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter7-代理模式"><a href="#Chapter7-代理模式" class="headerlink" title="Chapter7 代理模式"></a>Chapter7 代理模式</h1><p>代理模式(Proxy):为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png"><br>Subject类，定义了 RealSubject 和 Proxy 的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Request（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealSubject类，定义Proxy所代表的真实实体。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RealSubject</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Request（）</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine（<span class="string">&quot;真实的请求&quot;</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Proxy</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    RealSubject realSubject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Request（）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>（realSubject == <span class="literal">null</span>）</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject（）;</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.Request（）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main（<span class="built_in">string</span>[] args）</span><br><span class="line">&#123;</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy（）;</span><br><span class="line">    proxy.Request（）;</span><br><span class="line"></span><br><span class="line">    Console.Read（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>1.远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</li><li>2.虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。</li><li>3.安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</li><li>4.智能指引，是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。<h1 id="Chapter8-工厂方法模式"><a href="#Chapter8-工厂方法模式" class="headerlink" title="Chapter8 工厂方法模式"></a>Chapter8 工厂方法模式</h1></li><li>工厂方法模式（Factory Method）: 定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png"><h2 id="简单工厂vs-工厂方法"><a href="#简单工厂vs-工厂方法" class="headerlink" title="简单工厂vs.工厂方法"></a>简单工厂vs.工厂方法</h2></li><li>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</li><li>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//雷锋工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学雷锋的大学生工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">UndergraduateFactory</span>:<span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Undergraduate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//社区志愿者工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">VolunteerFactory</span>:<span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Volunteer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter9-原型模式"><a href="#Chapter9-原型模式" class="headerlink" title="Chapter9 原型模式"></a>Chapter9 原型模式</h1>原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.png"><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2></li><li>原型类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span>(<span class="params"><span class="built_in">string</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体原型类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span>:<span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span>(<span class="params"><span class="built_in">string</span> id</span>) : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建当前对象的浅表副本。</span></span><br><span class="line">        <span class="comment">//方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。</span></span><br><span class="line">        <span class="comment">//如果字段是值类型的，则对该字段执行逐位复制。</span></span><br><span class="line">        <span class="comment">//如果字段是引用类型，则复制引用但不复制引用的对象；</span></span><br><span class="line">        <span class="comment">//因此，原始对象及其副本引用同一对象。</span></span><br><span class="line">        <span class="keyword">return</span> (Prototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端代码<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcretePrototype1 p1 = <span class="keyword">new</span> ConcretePrototype1(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">ConcretePrototype1 c1 = (ConcretePrototype1)p1.Clone();</span><br><span class="line"><span class="comment">//克隆类ConcretePrototype1的对象p1就能得到新的实例c1</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Cloned : &#123;0&#125;&quot;</span>,c1.Id);</span><br></pre></td></tr></table></figure><h1 id="Chapter10-模板方法模式"><a href="#Chapter10-模板方法模式" class="headerlink" title="Chapter10 模板方法模式"></a>Chapter10 模板方法模式</h1>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.png"><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2></li><li>AbstractClass</li></ul><p>AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模版方法。<br>这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。<br>顶级逻辑也有可能调用一些具体方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一些抽象行为，放到子类去实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法，给出了逻辑的骨架，而逻辑的组成是一些相应的抽象操作，它们都推迟到子类实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrimitiveOperation1();</span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> ConcreteClass</li></ul><p>实现父类所定义的一个或多个抽象方法。<br>每一个AbstractClass都可以有任意多个ConcreteClass。<br>与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConCreteClassA</span> : <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类A方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类A方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConCreteClassB</span> : <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类B方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类B方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter11-迪米特法则"><a href="#Chapter11-迪米特法则" class="headerlink" title="Chapter11 迪米特法则"></a>Chapter11 迪米特法则</h1><p>迪米特法则（LoD）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h1 id="Chapter12-外观模式"><a href="#Chapter12-外观模式" class="headerlink" title="Chapter12 外观模式"></a>Chapter12 外观模式</h1><p>外观模式（Facade）：为子系统中的一组接口提供一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.png"></p><h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><ul><li>四个子系统的类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SubSystemOne</span> </span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodOne</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法一&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemTwo</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodTwo</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法二&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemThree</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodThree</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法三&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemFour</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodFour</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法四&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>外观类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外观类，它需要了解所有的子系统的方法和属性，进行组合，以备外界调用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Facade</span></span><br><span class="line">&#123;</span><br><span class="line">    SubSystemOne one;</span><br><span class="line">    SubSystemTwo two;</span><br><span class="line">    SubSystemThree three;</span><br><span class="line">    SubSystemFour four;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = <span class="keyword">new</span> SubSystemOne();</span><br><span class="line">        two = <span class="keyword">new</span> SubSystemTwo();</span><br><span class="line">        three = <span class="keyword">new</span> SubSystemThree();</span><br><span class="line">        four = <span class="keyword">new</span> SubSystemFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法组A（）&quot;</span>);</span><br><span class="line">        one.MethodOne();</span><br><span class="line">        two.MethodTwo();</span><br><span class="line">        four.MethodFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法组B（）&quot;</span>);</span><br><span class="line">        two.MethodTwo();</span><br><span class="line">        three.MethodThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端调用<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">facade.MethodA();</span><br><span class="line">facade.MethodB();</span><br></pre></td></tr></table></figure><h1 id="Chapter13-建造者模式"><a href="#Chapter13-建造者模式" class="headerlink" title="Chapter13 建造者模式"></a>Chapter13 建造者模式</h1>建造者模式(Builder)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.png"><h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2></li><li>Product类——产品类，由多个部件组成。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span> </span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; parts = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">string</span> part</span>)<span class="comment">//添加产品部件</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        parts.Add(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)<span class="comment">//列举所有的产品部件</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n 产品 创建 ----&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> part <span class="keyword">in</span> parts)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(part);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Builder类——抽象建造者类，确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Builder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> : <span class="title">Builder</span><span class="comment">//创建具体的两个部件是部件A和部件B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            product.Add(<span class="string">&quot;部件A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            product.Add(<span class="string">&quot;部件B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder2</span> : <span class="title">Builder</span><span class="comment">//创建具体的两个部件是部件X和部件Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        product.Add(<span class="string">&quot;部件X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        product.Add(<span class="string">&quot;部件Y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Director类——指挥者类。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Director</span><span class="comment">//用来指挥建造过程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span>(<span class="params">Builder builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.BuildPartA();</span><br><span class="line">        builder.BuildPartB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端代码，客户不需知道具体的建造过程。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Director director = <span class="keyword">new</span> Director();</span><br><span class="line">            Builder b1 = <span class="keyword">new</span> ConcreteBuilder1();</span><br><span class="line">            Builder b2 = <span class="keyword">new</span> ConcreteBuilder2();</span><br><span class="line"></span><br><span class="line">            director.Construct(b1);</span><br><span class="line">            Product p1 = b1.GetResult();</span><br><span class="line">            p1.Show();</span><br><span class="line"></span><br><span class="line">            director.Construct(b2);</span><br><span class="line">            Product p2 = b2.GetResult();</span><br><span class="line">            p2.Show();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">产品 创建 ----</span><br><span class="line">部件A</span><br><span class="line">部件B</span><br><span class="line"></span><br><span class="line">产品 创建 ----</span><br><span class="line">部件X</span><br><span class="line">部件Y</span><br></pre></td></tr></table></figure><h1 id="Chapter14-观察者模式"><a href="#Chapter14-观察者模式" class="headerlink" title="Chapter14 观察者模式"></a>Chapter14 观察者模式</h1>观察者模式（Observer）：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同事监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.png"></li><li>Subject类，可翻译为主题或抽象通知者，一般用一个抽象类或者一个接口实现。</li></ul><p>它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">Observer</span>&gt; observers</span> = <span class="keyword">new</span> List&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Observer observer</span>)</span> &#123; observers.Add(observer); &#125;</span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">Observer observer</span>)</span> &#123; observers.Remove(observer);&#125;</span><br><span class="line">    <span class="comment">//通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Observer o <span class="keyword">in</span> observers)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。</li></ul><p>这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update（）方法，这个方法叫做更新方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</li></ul><p>具体主题角色通常用一个具体子类实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> : <span class="title">Subject</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> subjectState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体被观察者状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> SubjectState</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> subjectState; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; subjectState = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。</li></ul><p>具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> : <span class="title">Observer</span> </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> observerState;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ConcreteSubject subject;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span>(<span class="params">ConcreteSubject subject,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.subject = subject;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           observerState = subject.SubjectState;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;观察者&#123;0&#125;的新状态是&#123;1&#125;&quot;</span>,name,observerState);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> ConcreteSubject Subject</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span> &#123; <span class="keyword">return</span> subject; &#125;</span><br><span class="line">           <span class="keyword">set</span> &#123; subject = <span class="keyword">value</span>; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteSubject s = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;X&quot;</span>));</span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;Y&quot;</span>));</span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;Z&quot;</span>));</span><br><span class="line"></span><br><span class="line">            s.SubjectState = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">            s.Notify();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">观察者X的新状态是ABC</span><br><span class="line">观察者Y的新状态是ABC</span><br><span class="line">观察者Z的新状态是ABC</span><br></pre></td></tr></table></figure><h1 id="Chapter15-抽象工厂模式"><a href="#Chapter15-抽象工厂模式" class="headerlink" title="Chapter15 抽象工厂模式"></a>Chapter15 抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory）：提供一个创建一个系列相关或互相依赖对象的接口，而无需指定他们具体的类。</p><h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><ul><li>1.最大的好处便是易于交换产品系列，由于具体工厂类 ，例如IFactory factory = new AccessFactory（），在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置 。我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库访问，我们只需要更改具体工厂就可以做到。</li><li>2.第二大好处是，它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。<h1 id="Chapter16-状态模式"><a href="#Chapter16-状态模式" class="headerlink" title="Chapter16 状态模式"></a>Chapter16 状态模式</h1>状态模式（State）：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</li></ul><p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。<br>把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.png"></p><ul><li>State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class State</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void Handle(Context context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ConcreteState类，具体状态，每一个子类实现一个与Context的一个状态相关的行为。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置ConcreteStateA的下一状态是ConcreteStateB</span></span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置ConcreteStateB的下一状态是ConcreteStateA</span></span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义Context的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">State state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可读写的状态属性,用于读取当前状态和设置新状态</span></span><br><span class="line">    <span class="keyword">public</span> State State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line">            state = <span class="keyword">value</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;当前状态:&quot;</span>+state.GetType().Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对请求做处理,并设置下一状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">//设置Context的初始状态为ConcreteStateA</span></span><br><span class="line">            Context c = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line"></span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">当前状态:ConcreteStateB</span><br><span class="line">当前状态:ConcreteStateA</span><br><span class="line">当前状态:ConcreteStateB</span><br><span class="line">当前状态:ConcreteStateA</span><br></pre></td></tr></table></figure><h2 id="状态模式好处与用处"><a href="#状态模式好处与用处" class="headerlink" title="状态模式好处与用处"></a>状态模式好处与用处</h2><p>状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来[DP]。</p><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。</p><p>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。</p><h1 id="Chapter17-适配器模式"><a href="#Chapter17-适配器模式" class="headerlink" title="Chapter17 适配器模式"></a>Chapter17 适配器模式</h1><p>适配器模式（Adapter）：将一个类的接口转换成成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP]<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.png"></p><h1 id="Chapter18-备忘录模式"><a href="#Chapter18-备忘录模式" class="headerlink" title="Chapter18 备忘录模式"></a>Chapter18 备忘录模式</h1><p>备忘录（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png"></p><ul><li>Originator（发起人）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Originator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; state = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建备忘录,将当前需要保存的信息导入并实例化出一个Memento对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">CreateMemento</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复备忘录,将Memento导入并将相关数据恢复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMemento</span>(<span class="params">Memento memento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        state = memento.State;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;State = &quot;</span>+state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。</li><li>Memento（备忘录）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Memento</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> state;</span><br><span class="line">    <span class="comment">//构造方法,将相关数据导入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span>(<span class="params"><span class="built_in">string</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要保存的数据，可以是多个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</li><li>Caretaker（管理者）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">    <span class="keyword">public</span> Memento Memento</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> memento; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; memento = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。</li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            Originator o = <span class="keyword">new</span> Originator();</span><br><span class="line">            o.State = <span class="string">&quot;On&quot;</span>;</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            Caretaker c = <span class="keyword">new</span> Caretaker();</span><br><span class="line">            c.Memento = o.CreateMemento();</span><br><span class="line"></span><br><span class="line">            o.State = <span class="string">&quot;Off&quot;</span>;</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            o.SetMemento(c.Memento);</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">State = On</span><br><span class="line">State = Off</span><br><span class="line">State = On</span><br></pre></td></tr></table></figure><h1 id="Chapter19-组合模式"><a href="#Chapter19-组合模式" class="headerlink" title="Chapter19 组合模式"></a>Chapter19 组合模式</h1><p>组合模式（Composite）：将对象组合成树形结构以表示’部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png"></p><ul><li><p>Component</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通常都用Add和Remove方法来提供增加或移除树叶或树枝的功能。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Component为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。</p></li><li><p>Leaf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Leaf : Component</span><br><span class="line">&#123;</span><br><span class="line">    public Leaf(string name) : base(name)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //由于叶子节点没有再增加分枝和树叶,所以Add和Remove方法实现没有它没有意义。</span><br><span class="line">    //</span><br><span class="line">    public override void Add(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Cannot add to a leaf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Remove(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Cannot remove form a leaf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //叶节点的具体方法,此处是显示其名称和级别。</span><br><span class="line">    public override void Display(int depth)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;-&quot; + depth + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leaf在组合中表示叶节点对象，叶节点没有子节点。</p></li><li><p>Composite</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Composite</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一个子对象集合用来存储其下属的枝节点和叶节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Component</span>&gt; children</span> = <span class="keyword">new</span> List&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        children.Add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        children.Remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示其枝节点名称,并对其下级进行遍历。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-&quot;</span> + depth + name);</span><br><span class="line">        <span class="keyword">foreach</span> (Component component <span class="keyword">in</span> children)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Display(depth + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Composite定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove。</p></li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">            Composite root = <span class="keyword">new</span> Composite(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf A&quot;</span>));</span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf B&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Composite comp = <span class="keyword">new</span> Composite(<span class="string">&quot;Composite X&quot;</span>);</span><br><span class="line">            comp.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XA&quot;</span>));</span><br><span class="line">            comp.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XB&quot;</span>));</span><br><span class="line">            root.Add(comp);</span><br><span class="line"></span><br><span class="line">            Composite comp2 = <span class="keyword">new</span> Composite(<span class="string">&quot;Composite XY&quot;</span>);</span><br><span class="line">            comp2.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XYA&quot;</span>));</span><br><span class="line">            comp2.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XYB&quot;</span>));</span><br><span class="line">            root.Add(comp2);</span><br><span class="line"></span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf C&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Leaf leaf = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf D&quot;</span>);</span><br><span class="line">            root.Add(leaf);</span><br><span class="line">            root.Remove(leaf);</span><br><span class="line"></span><br><span class="line">            root.Display(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="number">-1</span>root</span><br><span class="line"><span class="number">-3L</span>eaf A</span><br><span class="line"><span class="number">-3L</span>eaf B</span><br><span class="line"><span class="number">-3</span>Composite X</span><br><span class="line"><span class="number">-5L</span>eaf XA</span><br><span class="line"><span class="number">-5L</span>eaf XB</span><br><span class="line"><span class="number">-3</span>Composite XY</span><br><span class="line"><span class="number">-5L</span>eaf XYA</span><br><span class="line"><span class="number">-5L</span>eaf XYB</span><br><span class="line"><span class="number">-3L</span>eaf C</span><br></pre></td></tr></table></figure><h2 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h2><ul><li><p>当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。</p><h1 id="Chapter20-迭代器模式"><a href="#Chapter20-迭代器模式" class="headerlink" title="Chapter20 迭代器模式"></a>Chapter20 迭代器模式</h1><p>迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png"></p></li><li><p>Iterator</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到开始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">First</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//得到下一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">Next</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//判断是否到结尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">IsDone</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//当前对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器抽象类</p></li><li><p>Aggregate</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">CreateIterator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚集抽象类</p></li><li><p>ConcreteIterator</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义了一个具体聚集对象</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate aggregate;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化时将具体的聚集对象传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span>(<span class="params">ConcreteAggregate aggregate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到聚集的第一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">First</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到聚集的下一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> ret = <span class="literal">null</span>;</span><br><span class="line">        current++;</span><br><span class="line">        <span class="keyword">if</span> (current &lt; aggregate.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = aggregate[current];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前是否遍历到结尾,到结尾返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsDone</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> current &gt;= aggregate.Count ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前的聚集对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate[current];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体迭代器类，继承Iterator</p></li><li><p>ConcreteAggregate</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> : <span class="title">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个IList泛型变量,用于存放聚合对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">object</span>&gt; items</span> = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Iterator <span class="title">CreateIterator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回聚集总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> items.Count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个索引器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> items[index]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; items.Insert(index, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体聚集类 继承Aggregate</p></li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteAggregate a = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">            a[<span class="number">0</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">            a[<span class="number">2</span>] = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">            a[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            a[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"></span><br><span class="line">            Iterator i = <span class="keyword">new</span> ConcreteIterator(a);</span><br><span class="line">            <span class="built_in">object</span> item = i.First();</span><br><span class="line">            <span class="keyword">while</span> (!i.IsDone())</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i.CurrentItem());</span><br><span class="line">                i.Next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br></pre></td></tr></table></figure><p>总地来说，迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h1 id="Chapter21-单例模式"><a href="#Chapter21-单例模式" class="headerlink" title="Chapter21 单例模式"></a>Chapter21 单例模式</h1><p>单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png"></p><ul><li>Singleton类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//构造方法让其private，这就堵死了外界利用new创建此类实例的可能。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//此方法是获得本类实例的唯一全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若实例不存在，则new一个新实例，否则返回已有的实例。</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>定义一个GetInstance操作，允许客户访问它的唯一实例。<br>GetInstance是一个静态方法，主要负责创建自己的唯一实例。<h2 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h2>lock语句：lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> syncRoot = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">//构造方法让其private，这就堵死了外界利用new创建此类实例的可能。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//此方法是获得本类实例的唯一全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">        <span class="keyword">lock</span> (syncRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若实例不存在，则new一个新实例，否则返回已有的实例。</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止发生派生，而派生可能会增加实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在第一次引用类的任何成员时创建实例。</span></span><br><span class="line">    <span class="comment">//公共语言运行库负责处理变量初始化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样的实现与前面的示例类似，也是解决了单例模式试图解决的两个基本问题：全局访问和实例化控制，公共静态属性为访问实例提供了一个全局访问点。<br>不同之处在于它依赖公共语言运行库来初始化变量。由于构造方法是私有的，因此不能在类本身以外实例化Singleton类；因此，变量引用的是可以在系统中存在的唯一的实例。<br>不过要注意，instance变量标记为readonly，这意味着只能在静态初始化期间或在类构造函数中分配变量。由于这种静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为饿汉式单例类，原先的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以就被称为懒汉式单例类。</p><p>由于饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。所以到底使用哪一种方式，取决于实际的需求。</p><h1 id="Chapter22-桥接模式"><a href="#Chapter22-桥接模式" class="headerlink" title="Chapter22 桥接模式"></a>Chapter22 桥接模式</h1><h2 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成/聚合复用原则"></a>合成/聚合复用原则</h2><ul><li>合成/聚合复用原则（CARP）：尽量使用合成/聚合，尽量不要使用类继承。</li></ul><p>合成（Composition）和聚合（Aggregation）都是关联的特殊种类。<br>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；<br>合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>合成/聚合复用原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><p>桥接模式（Bridge）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png"></p><ul><li><p>Implementor类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ConcreteImplementorA和ConcreteImplementorB等派生类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span>:<span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体实现A的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> : <span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体实现B的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Abstraction类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor implementor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetImplementor</span>(<span class="params">Implementor implementor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        implementor.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RefinedAbstraction类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> : <span class="title">Abstraction</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        implementor.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            Abstraction ab = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line">            ab.SetImplementor(<span class="keyword">new</span> ConcreteImplementorA());</span><br><span class="line">            ab.Operation();</span><br><span class="line">            ab.SetImplementor(<span class="keyword">new</span> ConcreteImplementorB());</span><br><span class="line">            ab.Operation();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">具体实现A的方法执行</span><br><span class="line">具体实现B的方法执行</span><br></pre></td></tr></table></figure><h1 id="Chapter23-命令模式"><a href="#Chapter23-命令模式" class="headerlink" title="Chapter23 命令模式"></a>Chapter23 命令模式</h1><p>命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png"></p></li><li><p>Command类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来声明执行操作的接口。</p></li><li><p>ConcreteCommand类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span>(<span class="params">Receiver receiver</span>) : <span class="title">base</span>(<span class="params">receiver</span>)</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        receiver.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。</p></li><li><p>Invoker类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params">Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteCommand</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求该命令执行这个请求。</p></li><li><p>Receiver类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行请求！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p></li><li><p>客户端</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            Receiver r = <span class="keyword">new</span> Receiver();</span><br><span class="line">            Command c = <span class="keyword">new</span> ConcreteCommand(r);</span><br><span class="line">            Invoker i = <span class="keyword">new</span> Invoker();</span><br><span class="line"></span><br><span class="line">            i.SetCommand(c);</span><br><span class="line">            i.ExecuteCommand();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">执行请求！</span><br></pre></td></tr></table></figure></li></ul><h1 id="Chapter24-职责链模式"><a href="#Chapter24-职责链模式" class="headerlink" title="Chapter24 职责链模式"></a>Chapter24 职责链模式</h1><p>职责链模式（Chain of Responsibility）：使多个对象都有机会来处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png"></p><ul><li><p>Handler类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="comment">//设置继任者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSuccessor</span>(<span class="params">Handler successor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个处理请示的接口。</p></li><li><p>ConcreteHandler类 具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。</p></li></ul><p>ConcreteHandler1，当请求数在0到10之间则有权处理，否则转到下一位。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> : <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//0到10，处理此请求</span></span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>, <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">null</span>)<span class="comment">//转移到下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteHandler2，当请求数在10到20之间则有权处理，否则转到下一位。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> : <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//10到20，处理此请求</span></span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>, <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">null</span>)<span class="comment">//转移到下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteHandler3，当请求数在20到30之间则有权处理，否则转到下一位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteHandler3 : Handler</span><br><span class="line">&#123;</span><br><span class="line">    public override void HandleRequest(int request)</span><br><span class="line">    &#123;</span><br><span class="line">        //20到30，处理此请求</span><br><span class="line">        if (request &gt;= 20 &amp;&amp; request &lt; 30)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;, this.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (successor != null)//转移到下一位</span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">            Handler h1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">            Handler h2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">            Handler h3 = <span class="keyword">new</span> ConcreteHandler3();</span><br><span class="line">            h1.SetSuccessor(h2);</span><br><span class="line">            h2.SetSuccessor(h3);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] requests = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">20</span> &#125;;</span><br><span class="line">            <span class="comment">//循环给最小处理者提交请求，不同的数额，由不同权限处理者处理。</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> request <span class="keyword">in</span> requests)</span><br><span class="line">            &#123;</span><br><span class="line">                h1.HandleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">ConcreteHandler1处理请求<span class="number">2</span></span><br><span class="line">ConcreteHandler1处理请求<span class="number">5</span></span><br><span class="line">ConcreteHandler2处理请求<span class="number">14</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">22</span></span><br><span class="line">ConcreteHandler2处理请求<span class="number">18</span></span><br><span class="line">ConcreteHandler1处理请求<span class="number">3</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">27</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="职责链的好处"><a href="#职责链的好处" class="headerlink" title="职责链的好处"></a>职责链的好处</h2><p>这当中最关键的是当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p><p>这就使得接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。这也就大大降低了耦合度了。</p><h1 id="Chapter25-中介者模式"><a href="#Chapter25-中介者模式" class="headerlink" title="Chapter25 中介者模式"></a>Chapter25 中介者模式</h1><p>中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png"></p><ul><li><p>Mediator类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象的发送消息方法，得到同事对象和发送信息</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message, Colleague colleague</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象中介者类</p></li><li><p>Colleague类 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="comment">//构造方法，得到中介者对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span>(<span class="params">Mediator mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象同事类</p></li></ul><p>ConcreteColleague1和ConcreteColleague2等各种同事对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> : <span class="title">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span>(<span class="params">Mediator mediator</span>)</span></span><br><span class="line"><span class="function">    : <span class="title">base</span>(<span class="params">mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mediator.Send(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;同事1得到信息：&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteMediator类 具体中介者类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> : <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague1 Colleague1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; colleague1 = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague2 Colleague2</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; colleague2 = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message, Colleague colleague</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleague1)</span><br><span class="line">        &#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteMediator m = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">            <span class="comment">//让两个具体同事类认识中介者对象</span></span><br><span class="line">            ConcreteColleague1 c1 = <span class="keyword">new</span> ConcreteColleague1(m);</span><br><span class="line">            ConcreteColleague2 c2 = <span class="keyword">new</span> ConcreteColleague2(m);</span><br><span class="line">            <span class="comment">//让中介者认识各个具体通识类对象</span></span><br><span class="line">            m.Colleague1 = c1;</span><br><span class="line">            m.Colleague2 = c2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//具体同事类对象的发送消息都是通过中介者转发</span></span><br><span class="line">            c1.Send(<span class="string">&quot;吃过饭了吗?&quot;</span>);</span><br><span class="line">            c2.Send(<span class="string">&quot;没有呢，你打算请客?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">同事<span class="number">2</span>得到信息：吃过饭了吗?</span><br><span class="line">同事<span class="number">1</span>得到信息：没有呢，你打算请客?</span><br></pre></td></tr></table></figure><h1 id="Chapter26-享元模式"><a href="#Chapter26-享元模式" class="headerlink" title="Chapter26 享元模式"></a>Chapter26 享元模式</h1><p>享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png"></p><ul><li><p>Flyweight类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。</p></li><li><p>ConcreteFlyweight类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> : <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体Flyweight:&quot;</span> + extrinsicstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间。</p></li><li><p>UnsharedConcreteFlyweight类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> : <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不共享的具体Flyweight:&quot;</span> + extrinsicstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指那些不需要共享的Flyweight子类。<br>因为Flyweight接口共享成为可能，但它并不强制共享。</p></li><li><p>FlyweightFactory类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable flyweights = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化工厂时，先生成三个实例。</span></span><br><span class="line">        flyweights.Add(<span class="string">&quot;X&quot;</span>,<span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.Add(<span class="string">&quot;Y&quot;</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.Add(<span class="string">&quot;Z&quot;</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据客户端请求，获得已经生成的实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">GetFlyweight</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Flyweight)flyweights[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个享元工厂，用来创建并管理Flyweight对象。<br>它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</p></li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            <span class="built_in">int</span> extrinsicstate = <span class="number">22</span>;<span class="comment">//代码外部状态</span></span><br><span class="line"></span><br><span class="line">            FlyweightFactory f = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line"></span><br><span class="line">            Flyweight fx = f.GetFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">            fx.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight fy = f.GetFlyweight(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">            fy.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight fz = f.GetFlyweight(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">            fz.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight uf = <span class="keyword">new</span> UnsharedConcreteFlyweight();</span><br><span class="line">            uf.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">具体Flyweight:<span class="number">21</span></span><br><span class="line">具体Flyweight:<span class="number">20</span></span><br><span class="line">具体Flyweight:<span class="number">19</span></span><br><span class="line">不共享的具体Flyweight:<span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h2><p>在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。<br>事实上，享元模式可以避免大量非常相似类的开销。<br>在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。<br>如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p><p>也就是说，享元模式Flyweight执行时所需的状态是有内部的也可能有外部的，内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端对象存储或计算，当调用Flyweight对象的操作时，将该状态传递给它。</p><h1 id="Chapter27-解释器模式"><a href="#Chapter27-解释器模式" class="headerlink" title="Chapter27 解释器模式"></a>Chapter27 解释器模式</h1><p>解释器模式（interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。<br>这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png"></p><ul><li><p>AbstractExpression（抽象表达式）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractExpression</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</p></li><li><p>TerminalExpression（终结符表达式）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TerminalExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;终端解释器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现与文法中的终结符相关联的解释操作。<br>实现抽象表达式中所要求的接口，主要是一个interpret（）方法。<br>文法中每一个终结符都有一个具体终结表达式与之相对应。</p></li><li><p>NonterminalExpression（非终结符表达式）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">NontermianlExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;非终端解释器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为文法中的非终结符实现解释操作。<br>对文法中每一条规则R1、R2……Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的interpret（）方法实现解释操作。<br>解释操作以递归方式调用上面所提到的代表R1、R2……Rn中各个符号的实例变量。</p></li><li><p>Context</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Input &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> input; &#125; <span class="keyword">set</span> &#123; input = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> output;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Output &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> output; &#125; <span class="keyword">set</span> &#123; output = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含解释器之外的一些全局信息。</p></li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            Interpreter.Context context = <span class="keyword">new</span> Interpreter.Context();</span><br><span class="line">            IList&lt;AbstractExpression&gt; list = <span class="keyword">new</span> List&lt;AbstractExpression&gt;();</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> NontermianlExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (AbstractExpression exp <span class="keyword">in</span> list)</span><br><span class="line">            &#123;</span><br><span class="line">                exp.Interpret(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">终端解释器</span><br><span class="line">非终端解释器</span><br><span class="line">终端解释器</span><br><span class="line">终端解释器</span><br></pre></td></tr></table></figure><h2 id="解释器模式好处"><a href="#解释器模式好处" class="headerlink" title="解释器模式好处"></a>解释器模式好处</h2><p>用了解释器模式，就意味着可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</p><p>解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。</p><h1 id="Chapter28-访问者模式"><a href="#Chapter28-访问者模式" class="headerlink" title="Chapter28 访问者模式"></a>Chapter28 访问者模式</h1><p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png"></p><p>访问者模式的目的是要把处理从数据结构分离出来。<br>很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。<br>反之，如果这样的系统的数据结构对象易于变化，经常要有新的数据对象增加进来，就不适合使用访问者模式。</p><ul><li>Visitor类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Visitor</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为该对象结构中ConcreteElement的每一个类声明一个Visit操作。</li></ul><p>ConcreteVisitor1和ConcreteVisitor2类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor1</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>,concreteElementA.GetType().Name,<span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementB.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor2</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementA.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementB.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。</p><ul><li>Element类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Element</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>定义一个Accept操作，它以一个访问者为参数。</li></ul><p>ConcreteElementA和ConcreteElementB类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> : <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//充分利用双分派技术，实现处理与数据结构的分离。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitConcreteElementA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他的相关方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationA</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> : <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitConcreteElementB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationA</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体元素，实现Accept操作。</p><ul><li>ObjectStructure类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">Element</span>&gt; elements</span> = <span class="keyword">new</span> List&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        elements.Add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        elements.Remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> elements)</span><br><span class="line">        &#123;</span><br><span class="line">            e.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。</li></ul><p>客户端代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ObjectStructure o = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">            o.Attach(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">            o.Attach(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line"></span><br><span class="line">            ConcreteVisitor1 v1 = <span class="keyword">new</span> ConcreteVisitor1();</span><br><span class="line">            ConcreteVisitor2 v2 = <span class="keyword">new</span> ConcreteVisitor2();</span><br><span class="line">            o.Accept(v1);</span><br><span class="line">            o.Accept(v2);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">ConcreteElementA被ConcreteVisitor1访问</span><br><span class="line">ConcreteElementB被ConcreteVisitor1访问</span><br><span class="line">ConcreteElementA被ConcreteVisitor2访问</span><br><span class="line">ConcreteElementB被ConcreteVisitor2访问</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter3-单一职责原则&quot;&gt;&lt;a href=&quot;#Chapter3-单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;Chapter3 单一职责原则&quot;&gt;&lt;/a&gt;Chapter3 单一职责原则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;单一职责原则(SRP):</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话设计模式》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>Lua程序设计（语言特性18-23）</title>
    <link href="https://afoolzwt.github.io/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/"/>
    <id>https://afoolzwt.github.io/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/</id>
    <published>2022-11-01T16:00:00.000Z</published>
    <updated>2022-11-02T12:48:04.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter18-迭代器和泛型for"><a href="#Chapter18-迭代器和泛型for" class="headerlink" title="Chapter18 迭代器和泛型for"></a>Chapter18 迭代器和泛型for</h1><h2 id="18-1-迭代器和闭包"><a href="#18-1-迭代器和闭包" class="headerlink" title="18.1 迭代器和闭包"></a>18.1 迭代器和闭包</h2><p>迭代器（iterator）是一种可以让我们遍历一个集合中所有元素的代码结构。</p><p>所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。<br>对于函数io.read而言，C语言会将状态保存在流的结构体中。<br>对于我们自己的迭代器而言，闭包则为保存状态提供了一种良好的机制。<br>请注意，一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。<br>当然，要创建一个新的闭包，我们还必须创建非局部变量。<br>因此，一个闭包结构通常涉及两个函数：闭包本身和一个用于创建该闭包及其封装变量的工厂（factory）。</p><p>作为示例，让我们来为列表编写一个简单的迭代器。<br>与ipairs不同的是，该迭代器并不是返回每个元素的索引而是返回元素的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function values(t)</span><br><span class="line">    local i = 0;</span><br><span class="line"></span><br><span class="line">    return function ()</span><br><span class="line">        i = i + 1;</span><br><span class="line">        return t[i];</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，values就是工厂。<br>每当调用这个工厂时，它就会创建一个新的闭包（即迭代器本身）。<br>这个闭包将它的状态保存在其外部的变量t和i中，这两个变量也是由values创建的。<br>每次调用这个迭代器时，它就从列表t中返回下一个值。<br>在遍历完最后一个元素后，迭代器返回nil，表示迭代结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;10,20,30&#125;;</span><br><span class="line"></span><br><span class="line">iter = values(t);--创建迭代器</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local element = iter();--调用迭代器</span><br><span class="line"></span><br><span class="line">    if element == nil then</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    print(element);</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过，使用泛型for更简单。毕竟，泛型for正是为了这种迭代而设计的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for element in values(t) do</span><br><span class="line">    print(element);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>泛型for为一次迭代循环做了所有的记录工作：它在内部保存了迭代函数，因此不需要变量iter；它在每次做新的迭代时都会再次调用迭代器，并在迭代器返回nil时结束循环。</p><h2 id="18-2-泛型for的语法"><a href="#18-2-泛型for的语法" class="headerlink" title="18.2 泛型for的语法"></a>18.2 泛型for的语法</h2><p>泛型for在循环过程中在其内部保存了迭代函数。<br>实际上，泛型for保存了三个值：一个迭代函数、一个不可变状态（invariant state）和一个控制变量（control variable）。</p><p>下面让我们进行进一步学习。<br>泛型for的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var-list in exp-list do</span><br><span class="line">body</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。<br>通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。</p><p>例如，在如下代码中，变量列表是k,v，表达式列表只有一个元素pairs（t）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for k,v in pairs(t) do</span><br><span class="line">print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们把变量列表的第一个（或唯一的）变量称为控制变量（ control variable），其值在循环过程中永远不会是nil，因为当其值为nil时循环就结束了。<br>for做的第一件事情是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。</p><p>因此，假设迭代函数为f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值依次为a1=f（s,a0）,a2=f（s,a1），依此类推，直至ai为nil。<br>如果for还有其他变量，那么这些变量只是简单地在每次调用f后得到额外的返回值。</p><h2 id="18-3-无状态迭代器"><a href="#18-3-无状态迭代器" class="headerlink" title="18.3 无状态迭代器"></a>18.3 无状态迭代器</h2><p>顾名思义，无状态迭代器（stateless iterator）就是一种自身不保存任何状态的迭代器。<br>因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。</p><p>正如刚刚所看到的，for循环会以不可变状态和控制变量为参数调用迭代函数。<br>一个无状态迭代器只根据这两个值来为迭代生成下一个元素。<br>这类迭代器的一个典型例子就是ipairs，它可以迭代一个序列中的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;</span><br><span class="line">for index, value in ipairs(a) do</span><br><span class="line">print(index,value);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>迭代的状态由正在被遍历的表（一个不可变状态，它不会在循环中改变）及当前的索引值（控制变量）组成。<br>ipairs（工厂）和迭代器都非常简单，我们可以在Lua语言中将其编写出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local function iter(t,i)</span><br><span class="line">i = i + 1;</span><br><span class="line">local v = t[i];</span><br><span class="line">if v then</span><br><span class="line">return i,v;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function ipairs(t)</span><br><span class="line">return iter,t,0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当调用for循环中的ipairs（t）时，ipairs（t）会返回三个值，即迭代函数iter、不可变状态表t和控制变量的初始值0。<br>然后，Lua语言调用iter（t,0），得到1,t[1]（除非t[1]已经变成了nil）。<br>在第二次迭代中，Lua语言调用iter（t,1），得到2,t[2]，依此类推，直至得到第一个为nil的元素。</p><p>函数pairs与函数ipairs类似，也用于遍历一个表中的所有元素。<br>不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function pairs(t)</span><br><span class="line">return next,t,nil</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在调用next（t,k）时，k是表t的一个键，该函数会以随机次序返回表中的下一个键及k对应的值（作为第二个返回值）。<br>调用next（t,nil）时，返回表中的第一个键值对。<br>当所有元素被遍历完时，函数next返回nil。</p><p>我们可以不调用pairs而直接使用next：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value in next,t do</span><br><span class="line">loop body</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>请注意，for循环会把表达式列表的结果调整为三个值，因此上例中得到的是next、t和nil，这也正与pairs（t）的返回值完全一致。</p><h2 id="18-4-按顺序遍历表"><a href="#18-4-按顺序遍历表" class="headerlink" title="18.4 按顺序遍历表"></a>18.4 按顺序遍历表</h2><p>一个常见的困惑发生在开发人员想要对表中的元素进行排序时。<br>由于一个表中的元素没有顺序，所以如果想对这些元素排序，就不得不先把键值对拷贝到一个数组中，然后再对数组进行排序。</p><p>假设我们要读取一个源文件，然后构造一个表来保存每个函数的名称及其声明所在的行数，形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lines = &#123;</span><br><span class="line">[&quot;luaH_set&quot;] = 10,</span><br><span class="line">[&quot;luaH_get&quot;] = 24,</span><br><span class="line">[&quot;luaH_present&quot;] = 48,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想按照字母顺序输出这些函数名。<br>如果使用pairs遍历表，那么函数名会按照随机的顺序出现。<br>由于这些函数名是表的键，所以我们无法直接对其进行排序。<br>不过，如果我们把它们放到数组中，那么就可以对它们进行排序了。</p><p>首先，我们必须创建一个包含函数名的数组，然后对其排序，再最终输出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lines = &#123;</span><br><span class="line">[&quot;luaH_set&quot;] = 10,</span><br><span class="line">[&quot;luaH_get&quot;] = 24,</span><br><span class="line">[&quot;luaH_present&quot;] = 48,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for n in pairs(lines) do</span><br><span class="line">a[#a + 1] = n;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">table.sort(a);</span><br><span class="line"></span><br><span class="line">for _,n in ipairs(a) do</span><br><span class="line">print(n);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>有些人可能会困惑。毕竟，对于Lua语言来说，数组也没有顺序（毕竟它们是表）。<br>但是我们知道如何数数！因此，当我们使用有序的索引访问数组时，就实现了有序。<br>这正是应该总是使用ipairs而不是pairs来遍历数组的原因。<br>第一个函数通过有序的键1、2等来实现有序，然而后者使用的则是天然的随机顺序（虽然大多数情况下顺序随机也无碍，但有时可能并非我们想要的）。</p><p>现在，我们已经准备好写一个按照键的顺序来遍历表的迭代器了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function pairsByKeys(t,f)</span><br><span class="line">local a = &#123;&#125;;</span><br><span class="line">for n in pairs(t) do --创建一个包含所有键的表</span><br><span class="line">a[#n + 1] = n;</span><br><span class="line">end</span><br><span class="line">table.sort(a,f);--对列表排序</span><br><span class="line">local i = 0;--迭代变量</span><br><span class="line">returnfunction ()--迭代函数</span><br><span class="line">i = i + 1;</span><br><span class="line">return a[i],t[a[i]]--返回键和值</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="Chapter19-小插曲：马尔可夫链算法"><a href="#Chapter19-小插曲：马尔可夫链算法" class="headerlink" title="Chapter19 小插曲：马尔可夫链算法"></a>Chapter19 小插曲：马尔可夫链算法</h1><p>马尔可夫链算法根据哪个单词能出现在基础文本中由 n个前序单词组成的序列之后，来生成伪随机（pseudo-random）文本。<br>对于本例中的实现，我们假定n为2。</p><p>程序的第一部分读取原始文本并创建一个表，该表的键为每两个单词组成的前缀，值为紧跟这个前缀的单词所组成的列表。<br>当这个表构建好后，程序就利用它来生成随机文本，随机文本中每个单词出现在它之前两个单词后的概率与其出现在基础文本中相同两个前序单词后的概率相同。<br>最终，我们会得到一串相对比较随机的文本。例如，以本书的英文原版作为基础文本，那么该程序的输出形如“Constructorscan also traverse a table constructor,thenthe parentheses in the following line does the whole file in a field n to store the contents of each function,but to show its only argument.If you want to find the maximum element in an array can return both the maximum value and continues showing the prompt and running the code.The following words are reserved and cannot be used to convert between degrees and radians.”</p><p>要将由两个单词组成的前缀作为表的键，需要使用空格来连接两个单词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function prefix(w1,w2)</span><br><span class="line">return w1 ..&quot; &quot;..w2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们使用字符串NOWORD（换行符）初始化前缀单词及标记文本的结尾。例如，对于文本”the more we try the more we do”而言，构造出的表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[&quot;\n \n&quot;] = &#123;&quot;the&quot;&#125;,</span><br><span class="line">[&quot;\n the&quot;] = &#123;&quot;more&quot;&#125;,</span><br><span class="line">[&quot;the more&quot;] = &#123;&quot;we&quot;,&quot;we&quot;&#125;,</span><br><span class="line">[&quot;we try&quot;] = &#123;&quot;the&quot;&#125;,</span><br><span class="line">[&quot;try the&quot;] = &#123;&quot;more&quot;&#125;,</span><br><span class="line">[&quot;we do&quot;] = &#123;&quot;\n&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将表保存在变量statetab中。如果要向表中的某个前缀所对应的列表中插入一个新单词，可以使用如下的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function insert(prefix,value)</span><br><span class="line">local list = statetab[prefix];</span><br><span class="line">if list == nil then</span><br><span class="line">statetab[prefix] = &#123;value&#125;;</span><br><span class="line">else</span><br><span class="line">list[#list+1] = value;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>为了构造表statetab，我们使用两个变量w1和w2来记录最后读取的两个单词。<br>我们使用18.1节中的allwords迭代器读取单词，只不过修改了其中“单词”的定义以便将可选的诸如逗号和句号等标点符号包括在内（参见示例19.1）。<br>对于新读取的每一个单词，把它添加到与w1–w2相关联的列表中，然后更新w1和w2。</p><p>在构造完表后，程序便开始生成具有MAXGEN个单词的文本。<br>首先，程序重新初始化变量w1和w2。<br>然后，对于每个前缀，程序从其对应的单词列表中随机地选出一个单词，输出这个单词，并更新w1和w2。</p><p>示例19.1和示例19.2给出了完整的程序。</p><h2 id="19-1-马尔可夫链程序的辅助定义"><a href="#19-1-马尔可夫链程序的辅助定义" class="headerlink" title="19.1 马尔可夫链程序的辅助定义"></a>19.1 马尔可夫链程序的辅助定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function allwords()</span><br><span class="line">local line = io.read()--当前行</span><br><span class="line">local pos = 1--当前行的当前位置</span><br><span class="line"></span><br><span class="line">return function ()--迭代函数</span><br><span class="line">while line do--当还有行时循环</span><br><span class="line">local w,e = string.match(line,&quot;(%w+[,;.:]?)()&quot;,pos)</span><br><span class="line">if w then--发现一个单词</span><br><span class="line">pos = e--更新位置</span><br><span class="line">return w--返回该单词</span><br><span class="line">else</span><br><span class="line">line = io.read() --没找到单词;尝试下一行</span><br><span class="line">pos = 1--从第一个位置重新开始</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return nil;--没有行了：迭代结束</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function prefix(w1,w2)</span><br><span class="line">return w1 ..&quot; &quot;..w2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local statetab = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function insert(prefix,value)</span><br><span class="line">local list = statetab[prefix];</span><br><span class="line">if list == nil then</span><br><span class="line">statetab[prefix] = &#123;value&#125;;</span><br><span class="line">else</span><br><span class="line">list[#list+1] = value;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="19-2-马尔可夫链程序"><a href="#19-2-马尔可夫链程序" class="headerlink" title="19.2　马尔可夫链程序"></a>19.2　马尔可夫链程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local MAXGEN = 200</span><br><span class="line">local NOWORD = &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">--创建表</span><br><span class="line">local w1,w2 = NOWORD,NOWORD</span><br><span class="line">for nextword in allwords() do</span><br><span class="line">insert(prefix(w1,w2),nextword);</span><br><span class="line">w1 = w2;w2 = nextword;</span><br><span class="line">end</span><br><span class="line">insert(prefix(w1,w2),NOWORD);</span><br><span class="line"></span><br><span class="line">--生成文本</span><br><span class="line">w1 = NOWORD;w2 = NOWORD--重新初始化</span><br><span class="line">for i = 1, MAXGEN, 1 do</span><br><span class="line">local list = statetab[prefix(w1,w2)]</span><br><span class="line">--从列表中随机挑选出一个元素</span><br><span class="line">local r = math.random(#list)</span><br><span class="line">local nextword = list[r]</span><br><span class="line">if nextword == NOWORD then</span><br><span class="line">return;</span><br><span class="line">end</span><br><span class="line">io.write(nextword,&quot; &quot;)</span><br><span class="line">w1 = w2;w2 = nextword</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="Chapter20-元表和元方法"><a href="#Chapter20-元表和元方法" class="headerlink" title="Chapter20 元表和元方法"></a>Chapter20 元表和元方法</h1><p>通常，Lua语言中的每种类型的值都有一套可预见的操作集合。</p><p>元表可以修改一个值在面对一个未知操作时的行为。<br>例如，假设a和b都是表，那么可以通过元表定义Lua语言如何计算表达式a+b。<br>当Lua语言试图将两个表相加时，它会先检查两者之一是否有元表（metatable）且该元表中是否有__add字段。<br>如果Lua语言找到了该字段，就调用该字段对应的值，即所谓的元方法（metamethod）（是一个函数），在本例中就是用于计算表的和的函数。</p><p>可以认为，元表是面向对象领域中的受限制类。<br>像类一样，元表定义的是实例的行为。<br>不过，由于元表只能给出预先定义的操作集合的行为，所以元表比类更受限；同时，元表也不支持继承。</p><p>Lua语言中的每一个值都可以有元表。<br>每一个表和用户数据类型都具有各自独立的元表，而其他类型的值则共享对应类型所属的同一个元表。<br>Lua语言在创建新表时不带元表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line">print(getmetatable(t))--&gt; nil</span><br></pre></td></tr></table></figure><p>可以使用函数setmetatable来设置或修改任意表的元表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line">setmetatable(t,t1)</span><br><span class="line">print(getmetatable(t) == t1);--&gt; true</span><br></pre></td></tr></table></figure><p>在Lua语言中，我们只能为表设置元表；如果要为其他类型的值设置元表，则必须通过C代码或调试库完成<br>（该限制存在的主要原因是为了防止过度使用对某种类型的所有值生效的元表。Lua语言老版本中的经验表明，这样的全局设置经常导致不可重用的代码）。<br>字符串标准库为所有的字符串都设罝了同一个元表，而其他类型在默认情况中都没有元表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(getmetatable(&quot;hi&quot;))--&gt; table:0x80772e0</span><br><span class="line">print(getmetatable(&quot;xuxu&quot;))--&gt; table:0x80772e0</span><br><span class="line">print(getmetatable(10))--&gt; nil</span><br><span class="line">print(getmetatable(print))--&gt; nil</span><br></pre></td></tr></table></figure><p>一个表可以成为任意值的元表；一组相关的表也可以共享一个描述了它们共同行为的通用元表；一个表还可以成为它自己的元表，用于描述其自身特有的行为。<br>总之，任何配置都是合法的。</p><h2 id="20-1-算术运算相关的元方法"><a href="#20-1-算术运算相关的元方法" class="headerlink" title="20.1 算术运算相关的元方法"></a>20.1 算术运算相关的元方法</h2><p>假设有一个用表来表示集合的模块，该模块还有一些用来计算集合并集和交集等的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">local Set = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- 使用指定的列表创建一个新的集合</span><br><span class="line">function Set.new(l)</span><br><span class="line">local set = &#123;&#125;</span><br><span class="line">for _,v in ipairs(l) do</span><br><span class="line">set[v] = true;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return set;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--并集</span><br><span class="line">function Set.union(a,b)</span><br><span class="line">local res = Set.new(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">for k in pairs(a) do</span><br><span class="line">res[k] = true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k in pairs(b) do</span><br><span class="line">res[k] = true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--交集</span><br><span class="line">function Set.intersection(a,b)</span><br><span class="line">local res = Set.new(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">for k in pairs(a) do</span><br><span class="line">res[k] = b[k]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return res</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--将集合表示为字符串</span><br><span class="line">function Set.tostring(set)</span><br><span class="line">local l = &#123;&#125;--保存集合中所有元素的列表</span><br><span class="line"></span><br><span class="line">for e in pairs(set) do</span><br><span class="line">l[#l + 1] = tostring(e)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return &quot;&#123;&quot;..table.concat(l,&quot;,&quot;)..&quot;&#125;&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return Set</span><br></pre></td></tr></table></figure><p>现在，假设想使用加法操作符来计算两个集合的并集，那么可以让所有表示集合的表共享一个元表。<br>这个元表中定义了这些表应该如何执行加法操作。<br>首先，我们创建一个普通的表，这个表被用作集合的元表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local mt = &#123;&#125;--集合的元表</span><br></pre></td></tr></table></figure><p>然后，修改用于创建集合的函数Set.new。<br>在新版本中只多了一行，即将mt设置为函数Set.new所创建的表的元表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Set.new(l)</span><br><span class="line">local set = &#123;&#125;</span><br><span class="line">setmetatable(set,mt)</span><br><span class="line">for _,v in ipairs(l) do</span><br><span class="line">set[v] = true;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return set;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在此之后，所有由Set.new创建的集合都具有了一个相同的元表。</p><p>最后，向元表中加入元方法（metamethod）__add，也就是用于描述如何完成加法的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.__add = Set.union</span><br></pre></td></tr></table></figure><p>此后，只要Lua语言试图将两个集合相加，它就会调用函数Set.union，并将两个操作数作为参数传入。</p><p>类似地，还可以使用乘法运算符来计算集合的交集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.__mul = Set.intersection</span><br></pre></td></tr></table></figure><p>每种算术运算符都有一个对应的元方法。<br>除了加法和乘法外，还有减法（__sub）、除法（__div）、floor除法（__idiv）、负数（__unm）、取模（__mod）和幂运算（__pow）。<br>类似地，位操作也有元方法：按位与（__band）、按位或（__bor）、按位异或（__bxor）、按位取反（__bnot）、向左移位（__shl）和向右移位（__shr）。<br>我们还可以使用字段__concat来定义连接运算符的行为。</p><p>当我们把两个集合相加时，使用哪个元表是确定的。<br>然而，当一个表达式中混合了两种具有不同元表的值时，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set.new(&#123;1,2,3&#125;)</span><br><span class="line">s = s + 8</span><br></pre></td></tr></table></figure><p>Lua语言会按照如下步骤来查找元方法：<br>如果第一个值有元表且元表中存在所需的元方法，那么Lua语言就使用这个元方法，与第二个值无关；<br>如果第二个值有元表且元表中存在所需的元方法，Lua语言就使用这个元方法；<br>否则，Lua语言就抛出异常。<br>因此，上例会调用Set.union，而表达式10+s和”hello”+s同理（由于数值和字符串都没有元方法__add）。</p><p>Lua语言不关心这些混合类型，但我们在实现中需要关心混合类型。<br>如果我们执行了s=s+8，那么在Set.union内部就会发生错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad argument #1 to &#x27;pairs&#x27;(table expected,got number)</span><br></pre></td></tr></table></figure><p>如果想要得到更明确的错误信息，则必须在试图进行操作前显式地检查操作数的类型，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Set.union(a,b)</span><br><span class="line">local res = Set.new(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">if getmetatable(a) ~= mt or getmetatable(b) ~= mt then</span><br><span class="line">error(&quot;attempt to &#x27;add&#x27; a set with a non-set value&quot;,2)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k in pairs(a) do</span><br><span class="line">0res[k] = true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k in pairs(b) do</span><br><span class="line">res[k] = true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>请注意，函数error的第二个参数（上例中的2）说明了出错的原因位于调用该函数的代码中。</p><h2 id="20-2-关系运算相关的元方法"><a href="#20-2-关系运算相关的元方法" class="headerlink" title="20.2 关系运算相关的元方法"></a>20.2 关系运算相关的元方法</h2><p>元表还允许我们指定关系运算符的含义，其中的元方法包括等于（__eq）、小于（__lt）和小于等于（__le）。<br>其他三个关系运算符没有单独的元方法，Lua语言会将a～=b转换为not（a==b），a&gt;b转换为b&lt;a，a&gt;=b转换为b&lt;=a。</p><p>在Lua语言的老版本中，Lua语言会通过将a&lt;=b转换为not（b&lt;a）来把所有的关系运算符转化为一个关系运算符。<br>不过，这种转化在遇到部分有序（partial order）时就会不正确。所谓部分有序是指，并非所有类型的元素都能够被正确地排序。<br>例如，由于Not a Number（NaN）的存在，大多数计算机中的浮点数就不是完全可以排序的。<br>根据IEEE 754标准，NaN代表未定义的值，例如0/0的结果就是NaN。<br>标准规定任何涉及NaN的比较都应返回假，这就意味着NaN&lt;=x永远为假，x&lt;NaN也为假。因此，在这种情况下，a&lt;=b到not（b&lt;a）的转化也就不合法了。</p><p>相等比较有一些限制。如果两个对象的类型不同，那么相等比较操作不会调用任何元方法而直接返回false。</p><h2 id="20-3-库定义相关的元方法"><a href="#20-3-库定义相关的元方法" class="headerlink" title="20.3 库定义相关的元方法"></a>20.3 库定义相关的元方法</h2><p>Lua语言虚拟机（virtual machine）会检测一个操作中涉及的值是否有存在对应元方法的元表。<br>不过，由于元表是一个普通的表，所以任何人都可以使用它们。<br>因此，程序库在元表中定义和使用它们自己的字段也是一种常见的实践。</p><p>函数tostring就是一个典型的例子。<br>正如我们此前所看到的，函数tostring能将表表示为一种简单的文本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#123;&#125;)--&gt; table:0x8062ac0</span><br></pre></td></tr></table></figure><p>函数print总是调用tostring来进行格式化输出。<br>不过，当对值进行格式化时，函数tostring会首先检查值是否有一个元方法__tostring。<br>如果有，函数tostring就调用这个元方法来完成工作，将对象作为参数传给该函数，然后把元方法的返回值作为函数tostring的返回值。</p><p>函数setmetatable和getmetatable也用到了元方法，用于保护元表。<br>假设想要保护我们的集合，就要使用户既不能看到也不能修改集合的元表。<br>如果在元表中设置__metatable字段，那么getmetatable会返回这个字段的值，而setmetatable则会引发一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = Set.new(&#123;&#125;)</span><br><span class="line">print(getmetatable(s1))--&gt; not your business</span><br><span class="line">setmetatable(s1,&#123;&#125;)</span><br><span class="line">--stdin:1: cannot change protected metatable</span><br></pre></td></tr></table></figure><p>从Lua 5.2开始，函数pairs也有了对应的元方法，因此我们可以修改表被遍历的方式和为非表的对象增加遍历行为。<br>当一个对象拥有__pairs元方法时，pairs会调用这个元方法来完成遍历。</p><h2 id="20-4-表相关的元方法"><a href="#20-4-表相关的元方法" class="headerlink" title="20.4 表相关的元方法"></a>20.4 表相关的元方法</h2><p>算术运算符、位运算符和关系运算符的元方法都定义了各种错误情况的行为，但它们都没有改变语言的正常行为。<br>Lua语言还提供了一种改变表在两种正常情况下的行为的方式，即访问和修改表中不存在的字段。</p><h3 id="20-4-1-index元方法"><a href="#20-4-1-index元方法" class="headerlink" title="20.4.1 __index元方法"></a>20.4.1 __index元方法</h3><p>正如我们此前所看到的，当访问一个表中不存在的字段时会得到nil。这是正确的，但不是完整的真相。<br>实际上，这些访问会引发解释器查找一个名为__index的元方法。<br>如果没有这个元方法，那么像一般情况下一样，结果就是nil；否则，则由这个元方法来提供最终结果。</p><p>在Lua语言中，使用元方法__index来实现继承是很普遍的方法。<br>虽然被叫作方法，但元方法__index不一定必须是一个函数，它还可以是一个表。<br>当元方法是一个函数时，Lua语言会以表和不存在的键为参数调用该函数，正如我们刚刚所看到的。当元方法是一个表时，Lua语言就访问这个表。</p><p>如果我们希望在访问一个表时不调用__index元方法，那么可以使用函数rawget。<br>调用rawget（t,i）会对表t进行原始（raw）的访问，即在不考虑元表的情况下对表进行简单的访问。<br>进行一次原始访问并不会加快代码的执行（一次函数调用的开销就会抹杀用户所做的这些努力），但是，我们后续会看到，有时确实会用到原始访问。</p><h3 id="20-4-2-newindex元方法"><a href="#20-4-2-newindex元方法" class="headerlink" title="20.4.2　__newindex元方法"></a>20.4.2　__newindex元方法</h3><p>元方法__newindex与__index类似，不同之处在于前者用于表的更新而后者用于表的查询。<br>当对一个表中不存在的索引赋值时，解释器就会查找__newindex元方法：如果这个元方法存在，那么解释器就调用它而不执行赋值。<br>像元方法__index一样，如果这个元方法是一个表，解释器就在此表中执行赋值，而不是在原始的表中进行赋值。</p><p>此外，还有一个原始函数允许我们绕过元方法：调用rawset（t,k,v）来等价于t[k]=v，但不涉及任何元方法。</p><h3 id="20-4-3-具有默认值的表"><a href="#20-4-3-具有默认值的表" class="headerlink" title="20.4.3　具有默认值的表"></a>20.4.3　具有默认值的表</h3><p>一个普通表中所有字段的默认值都是nil。通过元表，可以很容易地修改这个默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setDefault(t,d)</span><br><span class="line">local mt = &#123;__index == function () return d end&#125;</span><br><span class="line">setmetatable(t,mt)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在调用setDefault后，任何对表tab中不存在字段的访问都将调用它的__index元方法，而这个元方法会返回零（这个元方法中的值是d）。</p><p>函数setDefault为所有需要默认值的表创建了一个新的闭包和一个新的元表。如果我们有很多需要默认值的表，那么开销会比较大。<br>然而，由于具有默认值d的元表是与元方法关联在一起的，所以我们不能把同一个元表用于具有不同默认值的表。<br>为了能够使所有的表都使用同一个元表，可以使用一个额外的字段将每个表的默认值存放到表自身中。<br>如果不担心命名冲突的话，我们可以使用形如”___”这样的键作为额外的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local mt = &#123;__index == function (t) return t.___ end&#125;</span><br><span class="line">function setDefault(t,d)</span><br><span class="line">t.___ = d</span><br><span class="line">setmetatable(t,mt)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>请注意，这里我们只在setDefault外创建了一次元表mt及对应的元方法。</p><p>如果担心命名冲突，要确保这个特殊键的唯一性也很容易，只需要创建一个新的排除表，然后将它作为键即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local key = &#123;&#125;--唯一的键</span><br><span class="line">local mt = &#123;__index == function (t) return t[key] end&#125;</span><br><span class="line">function setDefault(t,d)</span><br><span class="line">t[key] = d</span><br><span class="line">setmetatable(t,mt)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="20-4-4-跟踪对表的访问"><a href="#20-4-4-跟踪对表的访问" class="headerlink" title="20.4.4　跟踪对表的访问"></a>20.4.4　跟踪对表的访问</h3><p>假设我们要跟踪对某个表的所有访问。<br>由于__index和__newindex元方法都是在表中的索引不存在时才有用，因此，捕获对一个表所有访问的唯一方式是保持表是空的。<br>如果要监控对一个表的所有访问，那么需要为真正的表创建一个代理（proxy）。<br>这个代理是一个空的表，具有用于跟踪所有访问并将访问重定向到原来的表的合理元方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function track(t)</span><br><span class="line">local proxy = &#123;&#125;--&#x27;t&#x27;的代理表</span><br><span class="line"></span><br><span class="line">--为代理创建元表</span><br><span class="line">local mt = &#123;</span><br><span class="line">__index = function (_,k)</span><br><span class="line">print(&quot;*access to element&quot;..tostring(k));</span><br><span class="line">return t[k]--访问原来的表</span><br><span class="line">end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__newindex = function (_,k,v)</span><br><span class="line">print(&quot;*update of element&quot;..tostring(k)..&quot;to&quot;..tostring(v));\</span><br><span class="line">t[k] = v --更新原来的表</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">__pairs = function ()</span><br><span class="line">return function (_,k)--迭代函数</span><br><span class="line">local nextkey,nextvalue = next(t,k)</span><br><span class="line">if nextkey ~= nil then--避免最后一个值</span><br><span class="line">print(&quot;*traversing element&quot;..tostring(nextkey))</span><br><span class="line">end</span><br><span class="line">return nextkey,nextvalue</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">__len = function ()</span><br><span class="line">return #t</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果想要同时监控几个表，并不需要为每个表创建不同的元表。<br>相反，只要以某种形式将每个代理与其原始表映射起来，并且让所有的代理共享一个公共的元表即可。<br>这个问题与上节所讨论的把表与其默认值关联起来的问题类似，因此可以采用相同的解决方式。<br>例如，可以把原来的表保存在代理表的一个特殊的字段中，或者使用一个对偶表示建立代理与相应表的映射。</p><h3 id="20-4-5-只读的表"><a href="#20-4-5-只读的表" class="headerlink" title="20.4.5　只读的表"></a>20.4.5　只读的表</h3><p>使用代理的概念可以很容易地实现只读的表，需要做的只是跟踪对表的更新操作并抛出异常即可。<br>对于元方法__index，由于我们不需要跟踪查询，所以可以直接使用原来的表来代替函数。这样做比把所有的查询重定向到原来的表上更简单也更有效率。<br>不过，这种做法要求为每个只读代理创建一个新的元表，其中__index元方法指向原来的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function readOnly(t)</span><br><span class="line">local proxy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">local mt = &#123;</span><br><span class="line">__index = t,</span><br><span class="line">__newindex = function (_,k,v)</span><br><span class="line">error(&quot;attempt to update a read-only table&quot;,2)</span><br><span class="line">end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setmetatable(t,mt)</span><br><span class="line">return proxy</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="Chapter21-面向对象（Object-Oriented）编程"><a href="#Chapter21-面向对象（Object-Oriented）编程" class="headerlink" title="Chapter21 面向对象（Object-Oriented）编程"></a>Chapter21 面向对象（Object-Oriented）编程</h1><p>从很多意义上讲，Lua语言中的一张表就是一个对象。<br>首先，表与对象一样，可以拥有状态。<br>其次，表与对象一样，拥有一个与其值无关的的标识（self）；<br>特别地，两个具有相同值的对象（表）是两个不同的对象，而一个对象可以具有多个不同的值；<br>最后，表与对象一样，具有与创建者和被创建位置无关的生命周期。</p><p>使用参数self是所有面向对象语言的核心点。<br>大多数面向对象语言都向程序员隐藏了这个机制，从而使得程序员不必显式地声明这个参数（虽然程序员仍然可以在方法内使用self或者this）。<br>Lua语言同样可以使用冒号操作符（colon operator）隐藏该参数。</p><p>冒号的作用是在一个方法调用中增加一个额外的实参，或在方法的定义中增加一个额外的隐藏形参。<br>冒号只是一种语法机制，虽然很便利，但没有引入任何新的东西。<br>我们可以使用点分语法来定义一个函数，然后用冒号语法调用它，反之亦然，只要能够正确地处理好额外的参数即可。</p><h2 id="21-1-类（Class）"><a href="#21-1-类（Class）" class="headerlink" title="21.1　类（Class）"></a>21.1　类（Class）</h2><p>大多数面向对象语言提供了类的概念，类在对象的创建中扮演了模子（mold）的作用。在这些语言中，每个对象都是某个特定类的实例（instance）。<br>Lua语言中没有类的概念；虽然元表的概念在某种程度上与类的概念相似，但是把元表当作类使用在后续会比较麻烦。<br>相反，我们可以参考基于原型的语言（prototype-based language）中的一些做法来在Lua语言中模拟类，例如Self语言（JavaScript采用的也是这种方式）。在这些语言中，对象不属于类。<br>相反，每个对象可以有一个原型（prototype）。<br>原型也是一种普通的对象，当对象（类的实例）遇到一个未知操作时会首先在原型中查找。<br>要在这种语言中表示一个类，我们只需要创建一个专门被用作其他对象（类的实例）的原型对象即可。<br>类和原型都是一种组织多个对象间共享行为的方式。</p><p>继承不仅可以作用于方法，还可以作用于其他在新账户中没有的字段。<br>因此，一个类不仅可以提供方法，还可以为实例中的字段提供常量和默认值。</p><h2 id="21-2-继承（Inheritance）"><a href="#21-2-继承（Inheritance）" class="headerlink" title="21.2　继承（Inheritance）"></a>21.2　继承（Inheritance）</h2><p>Lua语言中的对象有一个有趣的特性，就是无须为了指定一种新行为而创建一个新类。<br>如果只有单个对象需要某种特殊的行为，那么我们可以直接在该对象中实现这个行为。</p><h2 id="21-3-多重继承（Multiple-Inheritance）"><a href="#21-3-多重继承（Multiple-Inheritance）" class="headerlink" title="21.3　多重继承（Multiple Inheritance）"></a>21.3　多重继承（Multiple Inheritance）</h2><p>这种实现的关键在于把一个函数用作__index元方法。<br>请注意，当一个表的元表中的__index字段为一个函数时，当Lua不能在原来的表中找到一个键时就会调用这个函数。基于这一点，就可以让__index元方法在其他期望的任意数量的父类中查找缺失的键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--一种多重继承的实现</span><br><span class="line"></span><br><span class="line">--在表&#x27;plist&#x27;的列表中查找&#x27;k&#x27;</span><br><span class="line">local function search(k,plist)</span><br><span class="line">for i = 1, #plist, 1 do</span><br><span class="line">local v = plist[i][k]</span><br><span class="line">if v then</span><br><span class="line">return v</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function createClass(...)</span><br><span class="line">local c = &#123;&#125;--新类</span><br><span class="line">local parents = &#123;...&#125;--父类列表</span><br><span class="line"></span><br><span class="line">--在父类列表中查找类缺失的方法</span><br><span class="line">setmetatable(c,&#123;__index = function (t,k)</span><br><span class="line">return search(k,parents)</span><br><span class="line">end&#125;)0</span><br><span class="line"></span><br><span class="line">--将&#x27;c&#x27;作为其实例的元表</span><br><span class="line">c.__index = c</span><br><span class="line"></span><br><span class="line">--为新类定义一个新的构造函数</span><br><span class="line">function c:new(o)</span><br><span class="line">o = o or &#123;&#125;</span><br><span class="line">setmetatable(o,c)</span><br><span class="line">return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return c--返回新类</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="21-4-私有性（Privacy）"><a href="#21-4-私有性（Privacy）" class="headerlink" title="21.4　私有性（Privacy）"></a>21.4　私有性（Privacy）</h2><p>这种做法的基本思想是通过两个表来表示一个对象：一个表用来保存对象的状态，另一个表用于保存对象的操作（或接口）。<br>我们通过第二个表来访问对象本身，即通过组成其接口的操作来访问。<br>为了避免未授权的访问，表示对象状态的表不保存在其他表的字段中，而只保存在方法的闭包中。</p><h2 id="21-5-单方法对象（Single-method-Object）"><a href="#21-5-单方法对象（Single-method-Object）" class="headerlink" title="21.5　单方法对象（Single-method Object）"></a>21.5　单方法对象（Single-method Object）</h2><p>单方法对象的另一种有趣情况是，这个方法其实是一个根据不同的参数完成不同任务的分发方法（dispatch method）。<br>这种对象的一种原型实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function newObject(value)</span><br><span class="line">return function (action,v)</span><br><span class="line">if action == &quot;get&quot; then</span><br><span class="line">return value</span><br><span class="line">elseif action == &quot;set&quot; then</span><br><span class="line">value = v</span><br><span class="line">else</span><br><span class="line">error(&quot;invalid action&quot;)</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>每个对象使用一个闭包，要比使用一个表的开销更低。<br>虽然使用这种方式不能实现继承，但我们却可以拥有完全的私有性：访问单方法对象中某个成员只能通过该对象所具有的唯一方法进行。</p><h2 id="21-6-对偶表示（Dual-Representation）"><a href="#21-6-对偶表示（Dual-Representation）" class="headerlink" title="21.6　对偶表示（Dual Representation）"></a>21.6　对偶表示（Dual Representation）</h2><p>这里的关键在于：我们不仅可以通过数值和字符串来索引一个表，还可以通过任何值来索引一个表，尤其是可以使用其他的表来索引一个表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Account.withdraw(self,v)</span><br><span class="line">balance[self] = balance[self] - v</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样做的好处在于私有性。<br>即使一个函数可以访问一个账户，但是除非它能够同时访问表balance，否则也不能访问余额。<br>如果表balance是一个在模块Account内部保存的局部变量，那么只有模块内部的函数才能访问它。<br>因此，只有这些函数才能操作账户余额。</p><p>在我们继续学习前，必须讨论一下这种实现的一个大的缺陷。<br>一旦我们把账户作为表balance中的键，那么这个账户对于垃圾收集器而言就永远也不会变成垃圾，这个账户会留在表中直到某些代码将其从表中显式地移除。<br>这对于银行账户而言可能不是问题（除非销户，否则一个账户通常需要一直有效），但对于其他场景来说则可能是一个较大的缺陷。<br>我们会在23.3节中学习如何解决这个问题，但现在我们先忽略它。</p><p>对偶表示无须修改即可实现继承。<br>这种实现方式与标准实现方式在内存和时间开销方面基本相同。<br>新对象需要一个新表，而且在每一个被使用的私有表中需要一个新的元素。<br>访问balance[self]会比访问self.balance稍慢，这是因为后者使用了局部变量而前者使用了外部变量。通常，这种区别是可以忽略的。<br>正如我们后面会看到的，这种实现对于垃圾收集器来说也需要一些额外的工作。</p><h2 id="Chapter22-环境（Environment）"><a href="#Chapter22-环境（Environment）" class="headerlink" title="Chapter22 环境（Environment）"></a>Chapter22 环境（Environment）</h2><p>全局变量在大多数编程语言中是让人爱恨交织又不可或缺的。<br>一方面，使用全局变量会明显地使无关的代码部分纠缠在一起，容易导致代码复杂。<br>另一方面，谨慎地使用全局变量又能更好地表达程序中真正的全局概念；<br>此外，虽然全局常量看似无害，但像Lua语言这样的动态语言是无法区分常量和变量的。<br>像Lua这样的嵌入式语言更复杂：虽然全局变量是在整个程序中均可见的变量，但由于Lua语言是由宿主应用调用代码段（chunk）的，因此“程序”的概念不明确。</p><p>Lua语言通过不使用全局变量的方法来解决这个难题，但又不遗余力地在Lua语言中对全局变量进行模拟。<br>在第一种近似的模拟中，我们可以认为Lua语言把所有的全局变量保存在一个称为全局环境（global environment）的普通表中。</p><h2 id="22-1-具有动态名称的全局变量"><a href="#22-1-具有动态名称的全局变量" class="headerlink" title="22.1　具有动态名称的全局变量"></a>22.1　具有动态名称的全局变量</h2><h2 id="22-2-全局变量的声明"><a href="#22-2-全局变量的声明" class="headerlink" title="22.2　全局变量的声明"></a>22.2　全局变量的声明</h2><h2 id="22-3-非全局环境"><a href="#22-3-非全局环境" class="headerlink" title="22.3　非全局环境"></a>22.3　非全局环境</h2><p>在Lua语言中，全局变量并不一定非得是真正全局的。<br>正如笔者此前所提到的，Lua语言甚至根本没有全局变量。<br>由于我们在本书中不断地使用全局变量，所以一开始听上去这可能很诡异。<br>正如笔者所说，Lua语言竭尽全力地让程序员有全局变量存在的幻觉。现在，让我们看看Lua语言是如何构建这种幻觉的。</p><p>首先，让我们忘掉全局变量而从自由名称的概念开始讨论。<br>一个自由名称（free name）是指没有关联到显式声明上的名称，即它不出现在对应局部变量的范围内。<br>例如，在下面的代码段中，x和y是自由名称，而z则不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local z = 10</span><br><span class="line">x = y + z</span><br></pre></td></tr></table></figure><p>接下来就到了关键的部分：Lua语言编译器将代码段中的所有自由名称x转换为_ENV.x。<br>因此，此前的代码段完全等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local z = 10</span><br><span class="line">_ENV.x = _ENV.y + z</span><br></pre></td></tr></table></figure><p>但是这里新出现的_ENV变量又究竟是什么呢？<br>我们刚才说过，Lua语言中没有全局变量。因此，_ENV不可能是全局变量。</p><p>在这里，编译器实际上又进行了一次巧妙的工作。<br>笔者已经提到过，Lua语言把所有的代码段都当作匿名函数。<br>所以，Lua语言编译器实际上将原来的代码段编译为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local _ENV = some value(某些值)</span><br><span class="line">return function(...)</span><br><span class="line">local z = 10</span><br><span class="line">_ENV.x = _ENV.y + z</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>也就是说，Lua语言是在一个名为_ENV的预定义上值（一个外部的局部变量，upvalue）存在的情况下编译所有的代码段的。<br>因此，所有的变量要么是绑定到了一个名称的局部变量，要么是_ENV中的一个字段，而_ENV本身是一个局部变量（一个上值）。</p><p>_ENV的初始值可以是任意的表（实际上也不用一定是表，我们会在后续讨论）。任何一个这样的表都被称为一个环境。<br>为了维持全局变量存在的幻觉，Lua语言在内部维护了一个表来用作全局环境（global environment）。<br>通常，当加载一个代码段时，函数load会使用预定义的上值来初始化全局环境。<br>因此，原始的代码段等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local _ENV = the global environment(全局环境)</span><br><span class="line">return function(...)</span><br><span class="line">local z = 10</span><br><span class="line">_ENV.x = _ENV.y + z</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述赋值的结果是，全局环境中的字段x得到全局环境中字段y加10的结果。</p><p>乍一看，这可能像是操作全局变量的一种相当拐弯抹角的方式。笔者也不会去争辩说这是最简单的方式，但是，这种方式比那些更简单的实现方法具有更多的灵活性。<br>在继续学习前，让我们总结一下Lua语言中处理全局变量的方式：</p><ul><li>编译器在编译所有代码段前，在外层创建局部变量_ENV；</li><li>编译器将所有自由名称var变换为_ENV.var；</li><li>函数load（或函数loadfile）使用全局环境初始化代码段的第一个上值，即Lua语言内部维护的一个普通的表。实际上，这也不是太复杂。</li></ul><p>有些人由于试图从这些规则中引申出额外的“魔法”而感到困惑；其实，这些规则并没有额外的含义。<br>尤其是，前两条规则完全是由编译器进行的。<br>除了是由编译器预先定义的，_ENV只是一个单纯的普通变量。<br>抛开编译器，名称_ENV对于Lua语言来说根本没有特殊含义。<br>类似地，从x到_ENV.x的转换是纯粹的语法转换，没有隐藏的含义。<br>尤其是，在转换后，按照标准的可见性规则，_ENV引用的是其所在位置所有可见的_ENV变量。</p><h2 id="22-4-使用-ENV"><a href="#22-4-使用-ENV" class="headerlink" title="22.4　使用_ENV"></a>22.4　使用_ENV</h2><h1 id="Chapter23-垃圾收集"><a href="#Chapter23-垃圾收集" class="headerlink" title="Chapter23　垃圾收集"></a>Chapter23　垃圾收集</h1><p>Lua语言使用自动内存管理。<br>程序可以创建对象（表、闭包等），但却没有函数来删除对象。<br>Lua语言通过垃圾收集（garbage collection）自动地删除成为垃圾的对象，从而将程序员从内存管理的绝大部分负担中解放出来。</p><p>弱引用表（weak table）、析构器（finalizer）和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。<br>弱引用表允许收集Lua语言中还可以被程序访问的对象；<br>析构器允许收集不在垃圾收集器直接控制下的外部对象；<br>函数collectgarbage则允许我们控制垃圾收集器的步长。</p><h2 id="23-1-弱引用表"><a href="#23-1-弱引用表" class="headerlink" title="23.1　弱引用表"></a>23.1　弱引用表</h2><p>弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的机制。所谓弱引用（weak reference）是一种不在垃圾收集器考虑范围内的对象引用。<br>如果对一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。<br>Lua用语言通过弱引用表实现弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。</p><p>表由键值对组成，其两者都可以容纳任意类型的对象。<br>在正常情况下，垃圾收集器不会回收一个在可访问的表中作为键或值的对象。也就是说，键和值都是强（strong）引用，它们会阻止对其所指向对象的回收。<br>在一个弱引用表中，键和值都可以是弱引用的。<br>这就意味着有三种类型的弱引用表，即具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。<br>不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">mt = &#123;__mode = &quot;k&quot;&#125;</span><br><span class="line">setmetatable(a,mt)--现在&#x27;a&#x27;的键是弱引用的了</span><br><span class="line">key = &#123;&#125;--创建第一个键</span><br><span class="line">a[key] = 1</span><br><span class="line">key = &#123;&#125;--创建第二个键</span><br><span class="line">a[key] = 2</span><br><span class="line">collectgarbage()--强制进行垃圾回收</span><br><span class="line"></span><br><span class="line">for key, value in pairs(a) do</span><br><span class="line">print(value)--&gt; 2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在本例中，第二句赋值key={}覆盖了指向第一个键的索引。<br>调用collectgarbage强制垃圾收集器进行一次完整的垃圾收集。<br>由于已经没有指向第一个键的其他引用，因此Lua语言会回收这个键并从表中删除对应的元素。<br>然而，由于第二个键仍然被变量key所引用，因此Lua不会回收它。</p><p>请注意，只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。<br>例如，如果我们在表a（之前的示例）中插入一个数值类型的键，那么垃圾收集器永远不会回收它。<br>当然，如果在一个值为弱引用的弱引用表中，一个数值类型键相关联的值被回收了，那么整个元素都会从这个弱引用表中被删除。</p><p>字符串在这里表现了一些细微的差别，虽然从实现的角度看字符串是可回收的，但字符串又与其他的可回收对象不同。<br>其他的对象，例如表和闭包，都是被显式创建的。例如，当Lua语言对表达式{}求值时会创建一个新表。然而，当对表达式”a”..”b”求值时，Lua语言会创建一个新字符串么？<br>如果当前系统中已有了一个字符串”ab”会怎么样？Lua语言会创建一个新的字符串么？编译器会在运行程序前先创建这个字符串吗？其实，这些都无关紧要，因为它们都是实现上的细节。<br>从程序员的角度看，字符串是值而不是对象。<br>所以，字符串就像数值和布尔值一样，对于一个字符串类型的键来说，除非它对应的值被回收，否则是不会从弱引用表中被移除的。</p><h2 id="23-2-记忆函数（Memorize-Function）"><a href="#23-2-记忆函数（Memorize-Function）" class="headerlink" title="23.2　记忆函数（Memorize Function）"></a>23.2　记忆函数（Memorize Function）</h2><p>空间换时间是一种常见的编程技巧。<br>我们可以通过记忆（memorize）函数的执行结果，在后续使用相同参数再次调用该函数时直接返回之前记忆的结果，来加快函数的运行速度。 </p><p>记忆技术（memorization technique）还可以用来确保某类对象的唯一性。</p><h2 id="23-3-对象属性（Object-Attribute）"><a href="#23-3-对象属性（Object-Attribute）" class="headerlink" title="23.3　对象属性（Object Attribute）"></a>23.3　对象属性（Object Attribute）</h2><h2 id="23-4-回顾具有默认值的表"><a href="#23-4-回顾具有默认值的表" class="headerlink" title="23.4　回顾具有默认值的表"></a>23.4　回顾具有默认值的表</h2><h2 id="23-5-瞬表（Ephemeron-Table）"><a href="#23-5-瞬表（Ephemeron-Table）" class="headerlink" title="23.5　瞬表（Ephemeron Table）"></a>23.5　瞬表（Ephemeron Table）</h2><p>在Lua语言中，一个具有弱引用键和强引用值的表是一个瞬表。<br>在一个瞬表中，一个键的可访问性控制着对应值的可访问性。<br>更确切地说，考虑瞬表中的一个元素（k,v），指向的v的引用只有当存在某些指向k的其他外部引用存在时才是强引用，否则，即使v（直接或间接地）引用了k，垃圾收集器最终会收集k并把元素从表中移除。</p><h2 id="23-6-析构器（Finalizer）"><a href="#23-6-析构器（Finalizer）" class="headerlink" title="23.6　析构器（Finalizer）"></a>23.6　析构器（Finalizer）</h2><p>Lua语言中，析构器的一个微妙之处在于“将一个对象标记为需要析构”的概念。<br>通过给对象设置一个具有非空__gc元方法的元表，就可以把一个对象标记为需要进行析构处理。<br>如果不标记对象，那么对象就不会被析构。</p><p>有关析构器的另一个微妙之处是复苏（resurrection）。<br>当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃的。笔者把这称为临时复苏（transient resurrection）。<br>在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可访问，笔者把这称为永久复苏（permanent resurrection）。</p><p>由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。<br>当垃圾收集器首次发现某个具有析构器的对象不可达时，垃圾收集器就把这个对象复苏并将其放入等待被析构的队列中。<br>一旦析构器开始执行，Lua语言就将该对象标记为已被析构。<br>当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。<br>如果想保证我们程序中的所有垃圾都被真正地释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。</p><h2 id="23-7-垃圾收集器"><a href="#23-7-垃圾收集器" class="headerlink" title="23.7　垃圾收集器"></a>23.7　垃圾收集器</h2><p>一直到Lua 5.0，Lua语言使用的都是一个简单的标记-清除（mark-and-sweep）式垃圾收集器（Garbage Collector，GC）。<br>这种收集器又被称为“stop-the-world（全局暂停）”式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期（garbagecollection cycle）。</p><p>每一个垃圾收集周期由四个阶段组成：标记（mark）、清理（cleaning）、清除（sweep）和析构（finalization）。</p><p>标记阶段把根结点集合（ root set）标记为活跃，根结点集合由Lua语言可以直接访问的对象组成。<br>在Lua语言中，这个集合只包括C注册表（在30.3.1节中我们会看到，主线程和全局环境都是在这个注册表中预定义的元素）。<br>保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（当然，在弱引用表中的元素不遵循这个规则）。<br>当所有可达对象都被标记为活跃后，标记阶段完成。</p><p>在开始清除阶段前，Lua语言先执行清理阶段，在这个阶段中处理析构器和弱引用表。<br>首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。<br>这些没有被标记为活跃状态的对象会被标记为活跃（复苏，resurrected），并被放在一个单独的列表中，这个列表会在析构阶段用到。<br>然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。</p><p>清除阶段遍历所有对象（为了实现这种遍历，Lua语言把所有创建的对象放在一个链表中）。<br>如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。</p><p>最后，在析构阶段，Lua语言调用清理阶段被分离出的对象的析构器。<br>使用真正的垃圾收集器意味着Lua语言能够处理对象引用之间的环。<br>在使用环形数据结构时，我们不需要花费额外的精力，它们会像其他数据一样被回收。</p><p>Lua 5.1使用了增量式垃圾收集器（incremental collector）。<br>这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行。相反，它与解释器一起交替运行。<br>每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步（这意味着，在垃圾收集器工作期间，解释器可能会改变一个对象的可达性。为了保证垃圾收集器的正确性，垃圾收集器中的有些操作具有发现危险改动和纠正所涉及对象标记的内存屏障[barrier]）。</p><p>Lua 5.2引入了紧急垃圾收集（emergency collection）。<br>当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。<br>这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。</p><h2 id="23-8-控制垃圾收集的步长（Pace）"><a href="#23-8-控制垃圾收集的步长（Pace）" class="headerlink" title="23.8　控制垃圾收集的步长（Pace）"></a>23.8　控制垃圾收集的步长（Pace）</h2><p>通过函数collectgarbage可以对垃圾收集器进行一些额外的控制，该函数实际上是几个函数的集合体：第一个参数是一个可选的字符串，用来说明进行何种操作；有些选项使用一个整型作为第二个参数，称为data。<br>第一个参数的选项包括如下七个。<br>“stop”：停止垃圾收集器，直到使用选项”restart”再次调用collectgarbage。<br>“restart”：重启垃圾收集器。<br>“collect”：执行一次完整的垃圾收集，回收和析构所有不可达的对象。这是默认的选项。<br>“step”：执行某些垃圾收集工作，第二个参数data指明工作量，即在分配了data个字节后垃圾收集器应该做什么。<br>“count”：以KB为单位返回当前已用内存数，该结果是一个浮点数，乘以1024得到的就是精确的字节数。该值包括了尚未被回收的死对象。<br>“setpause”：设置收集器的pause参数（间歇率）。参数data以百分比为单位给出要设定的新值：当data为100时，参数被设为1（100%）。<br>“setstepmul”：设置收集器的stepmul参数（步进倍率，step multiplier）。参数data给出新值，也是以百分比为单位。</p><p>两个参数pause和stepmul控制着垃圾收集器的角色。任何垃圾收集器都是使用CPU时间换内存空间。<br>在极端情况下，垃圾收集器可能根本不会运行。但是，不耗费CPU时间是以巨大的内存消耗为代价的。<br>在另外一种极端的情况下，收集器可能每进行一次赋值就得运行一次完整的垃圾收集。程序能够使用尽可能少的内存，但是是以巨大的CPU消耗为代价的。<br>pause和stepmul的默认值正是试图在这两个极端之间找到的对大多数应用来说足够好的平衡点。不过，在某些情况下，还是值得试着对它们进行优化。</p><p>参数pause用于控制垃圾收集器在一次收集完成后等待多久再开始新的一次收集。<br>当值为零时表示Lua语言在上一次垃圾回收结束后立即开始一次新的收集。当值为200%时表示在重启垃圾收集器前等待内存使用翻番。<br>如果想使消耗更多的CPU时间换取更低的内存消耗，那么可以把这个值设得小一点。<br>通常，我们应该把这个值设在0到200%之间。</p><p>参数stepmul控制对于每分配1KB内存，垃圾收集器应该进行多少工作。这个值越高，垃圾收集器使用的增量越小。<br>一个像100000000%一样巨大的值会让收集器表现得像一个非增量的垃圾收集器。<br>默认值是200%。低于100%的值会让收集器运行得很慢，以至于可能一次收集也完不成。</p><p>函数collectgarbage的另外一些参数用来在垃圾收集器运行时控制它的行为。<br>同样，对于大多数程序员来说，默认值已经足够好了，但是对于一些特殊的应用，用手工控制可能更好，游戏就经常需要这种类型的控制。<br>例如，如果我们不想让垃圾收集在某些阶段运行，那么可以通过调用函数collectgarbage（”stop”）停止垃圾收集器，然后再调用collectgarba ge（”restart”）重新启动垃圾收集器。<br>在一些具有周期性休眠阶段的程序中，可以让垃圾收集器停止，然后在程序休眠期间调用collectgarbage（”step”,n）。<br>要设置在每一个休眠期间进行多少工作，要么为n实验性地选择一个恰当的值，要么把n设成零（意为最小的步长），然后在一个循环中调用函数collectgarbage直到休眠结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter18-迭代器和泛型for&quot;&gt;&lt;a href=&quot;#Chapter18-迭代器和泛型for&quot; class=&quot;headerlink&quot; title=&quot;Chapter18 迭代器和泛型for&quot;&gt;&lt;/a&gt;Chapter18 迭代器和泛型for&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《Lua程序设计》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
    <category term="语言特性" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>Lua程序设计（编程实操9-17）</title>
    <link href="https://afoolzwt.github.io/2022/11/01/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%93%8D9-17%EF%BC%89/"/>
    <id>https://afoolzwt.github.io/2022/11/01/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%93%8D9-17%EF%BC%89/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2022-11-02T12:47:24.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter9-闭包"><a href="#Chapter9-闭包" class="headerlink" title="Chapter9 闭包"></a>Chapter9 闭包</h1><p>在Lua语言中，函数是严格遵循词法定界（lexicalscoping）的第一类值（first-classvalue）。</p><p>“第一类值”意味着Lua语言中的函数与其他常见类型的值（例如数值和字符串）具有同等权限：一个程序可以将某个函数保存到变量中（全局变量和局部变量均可）或表中，也可以将某个函数作为参数传递给其他函数，还可以将某个函数作为其他函数的返回值返回。</p><p>“词法定界”意味着Lua语言中的函数可以访问包含其自身的外部函数中的变量（也意味着Lua语言完全支持Lambda演算）。<br>【<br>    此处原文大致为”Lexical scoping means that functions can access variables of their enclosing functions”，实际上是指Lua语言中的一个函数A可以嵌套在另一个函数B中，内部的函数A可以访问外部函数B中声明的<br>    变量。<br>    定界是计算机科学中的专有名词，指变量与变量所对应实体之间绑定关系的有效范围，在部分情况下也常与可见性（visibility）混用。<br>    词法定界也被称为静态定界（static scoping），常常与动态定界（dynamic scoping）比较，其中前者被大多数现代编程语言采用，后者常见于Bash等Shell语言。<br>    使用静态定界时，一个变量的可见性范围仅严格地与组成程序的静态具体词法上下文有关，而与运行时的具体堆栈调用无关；<br>    使用动态定界时，一个变量的可见性范围在编译时无法确定，依赖于运行时的实际堆栈调用情况。<br> 】</p><p>上述两个特性联合起来为Lua语言带来了极大的灵活性。<br>例如，一个程序可以通过重新定义函数来增加新功能，也可以通过擦除函数来为不受信任的代码（例如通过网络接收到的代码）创建一个安全的运行时环境。<br>【<br>    通常通过网络等方式动态加载的代码只应该具有访问其自身代码和数据的能力，而不应该具有访问除其自身代码和数据外其他固有代码和数据的能力，否则就可能出现越权或各种溢出类风险，因此可以通过在使用完成后    将这些动态加载的代码擦除的方式消除由于动态加载了非受信任代码而可能导致的安全风险。<br> 】<br>更重要的是，上述两个特性允许我们在Lua语言中使用很多函数式语言（functional-language）的强大编程技巧。即使对函数式编程毫无兴趣，也不妨学习一下如何探索这些技巧，因为这些技巧可以使程序变得更加小巧和简单。</p><h2 id="9-1-函数是第一类值"><a href="#9-1-函数是第一类值" class="headerlink" title="9.1 函数是第一类值"></a>9.1 函数是第一类值</h2><p>如前所述，Lua语言中的函数是第一类值。以下的示例演示了第一类值的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; p = print &#125;-- &#x27;a.p&#x27;指向&#x27;print&#x27;函数</span><br><span class="line">a.p(&quot;Hello world&quot;)--&gt; Hello world</span><br><span class="line">print = math.sin-- &#x27;print&#x27;现在指向math.sin函数</span><br><span class="line">a.p(print(1))--&gt; 0.8414709848079</span><br><span class="line">math.sin = a.p-- &#x27;sin&#x27;现在指向print函数</span><br><span class="line">math.sin(10,20)--&gt; 10 20</span><br></pre></td></tr></table></figure><p>如果函数也是值的话，那么是否有创建函数的表达式呢？答案是肯定的。事实上，Lua语言中常见的函数定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)</span><br><span class="line">return 2*x</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>就是所谓的语法糖（syntactic sugar）的例子，它只是下面这种写法的一种美化形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = function(x) return 2*x end</span><br></pre></td></tr></table></figure><p>赋值语句右边的表达式（function（x）body end）就是函数构造器，与表构造器{}相似。因此，函数定义实际上就是创建类型为”function”的值并把它赋值给一个变量的语句。</p><p>请注意，在Lua语言中，所有的函数都是匿名的（anonymous）。<br>像其他所有的值一样，函数并没有名字。当讨论函数名时，比如print，实际上指的是保存该函数的变量。虽然我们通常会把函数赋值给全局变量，从而看似给函数起了一个名字，但在很多场景下仍然会保留函数的匿名性。下面来看几个例子。</p><p>表标准库提供了函数table.sort，该函数以一个表为参数并对其中的元素排序。<br>这种函数必须支持各种各样的排序方式：升序或降序、按数值顺序或按字母顺序、按表中的键等。<br>函数sort并没有试图穷尽所有的排序方式，而是提供了一个可选的参数，也就是所谓的排序函数（ order function ），排序函数接收两个参数并根据第一个元素是否应排在第二个元素之前返回不同的值。</p><p>例如，假设有一个如下所示的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network = &#123;</span><br><span class="line">&#123;name = &quot;grauna&quot;,IP = &quot;210.26.30.34&quot;&#125;,</span><br><span class="line">&#123;name = &quot;arraial&quot;,IP = &quot;210.26.30.34&quot;&#125;,</span><br><span class="line">&#123;name = &quot;lua&quot;,IP = &quot;210.26.30.34&quot;&#125;,</span><br><span class="line">&#123;name = &quot;derain&quot;,IP = &quot;210.26.30.34&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想针对name字段、按字母顺序逆序对这个表排序，只需使用如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.sort(network,function(a,b) return (a.name &gt; b.name) end)</span><br></pre></td></tr></table></figure><p>可见，匿名函数在这条语句中显示出了很好的便利性。</p><p>像函数sort这样以另一个函数为参数的函数，我们称之为高阶函数（higher-order function）。<br>高阶函数是一种强大的编程机制，而利用匿名函数作为参数正是其灵活性的主要来源。不过尽管如此，请记住高阶函数也并没有什么特殊的，它们只是Lua语言将函数作为第一类值处理所带来结果的直接体现。</p><h2 id="9-2-非全局函数"><a href="#9-2-非全局函数" class="headerlink" title="9.2 非全局函数"></a>9.2 非全局函数</h2><p>由于函数是一种“第一类值”，因此一个显而易见的结果就是：函数不仅可以被存储在全局变量中，还可以被存储在表字段和局部变量中。</p><p>我们已经在前面的章节中见到过几个将函数存储在表字段中的示例，大部分Lua语言的库就采用了这种机制（例如io.read和math.sin）。<br>如果要在Lua语言中创建这种函数，只需将到目前为止我们所学到的知识结合起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lib =  &#123;&#125;</span><br><span class="line">Lib.foo = function (x,y) return x+y end</span><br><span class="line">Lib.goo = function (x,y) return x-y end</span><br></pre></td></tr></table></figure><p>当然，也可以使用表构造器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123;</span><br><span class="line">foo = function (x,y) return x+y end</span><br><span class="line">goo = function (x,y) return x-y end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此以外，Lua语言还提供了另一种特殊的语法来定义这类函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lib =  &#123;&#125;</span><br><span class="line">function Lib.foo(x,y) return x+y end</span><br><span class="line">function Lib.goo(x,y) return x-y end</span><br></pre></td></tr></table></figure><p>正如我们将在第21章中看到的，在表字段中存储函数是Lua语言中实现面向对象编程的关键要素。</p><p>当把一个函数存储到局部变量时，就得到了一个局部函数（local function），即一个被限定在指定作用域中使用的函数。<br>局部函数对于包（package）而言尤其有用：由于Lua语言将每个程序段（chunk）作为一个函数处理，所以在一段程序中声明的函数就是局部函数，这些局部函数只在该程序段中可见。<br>词法定界保证了程序段中的其他函数可以使用这些局部函数。</p><p>对于这种局部函数的使用，Lua语言提供了一种语法糖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local function f(params)</span><br><span class="line">boby</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在定义局部递归函数（recursive local function）时，由于原来的方法不适用，所以有一点是极易出错的。<br>考虑如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local fact = function(n)</span><br><span class="line">if n == 0 then</span><br><span class="line">return 1</span><br><span class="line">else</span><br><span class="line">return n * fact(n - 1)-- Error!</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当Lua语言编译函数体中的fact（n-1）调用时，局部的fact尚未定义。因此，这个表达式会尝试调用全局的fact而非局部的fact。</p><p>我们可以通过先定义局部变量再定义函数的方式来解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local fact</span><br><span class="line"></span><br><span class="line">fact = function(n)</span><br><span class="line">if n == 0 then</span><br><span class="line">return 1</span><br><span class="line">else</span><br><span class="line">return n * fact(n - 1)-- Error!</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样，函数内的fact指向的是局部变量。尽管在定义函数时，这个局部变量的值尚未确定，但到了执行函数时，fact肯定已经有了正确的赋值。</p><p>当Lua语言展开局部函数的语法糖时，使用的并不是之前的基本函数定义。相反，形如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local function foo(params)</span><br><span class="line">boby</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>的定义会被展开成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local foo</span><br><span class="line">foo = function (params)</span><br><span class="line">boby</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>因此，使用这种语法来定义递归函数不会有问题。</p><p>当然，这个技巧对于间接递归函数（indirect recursive function）是无效的。<br>在间接递归的情况下，必须使用与明确的前向声明（explicit forward declaration）等价的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local f-- &quot;向前&quot;声明</span><br><span class="line"></span><br><span class="line">local function g()</span><br><span class="line">some code</span><br><span class="line">f()</span><br><span class="line">some code</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function f()</span><br><span class="line">some code</span><br><span class="line">g()</span><br><span class="line">some code</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>请注意，不能在最后一个函数定义前加上local。否则，Lua语言会创建一个全新的局部变量f，从而使得先前声明的f（函数g中使用的那个）变为未定义状态。</p><h2 id="9-3-词法定界"><a href="#9-3-词法定界" class="headerlink" title="9.3 词法定界"></a>9.3 词法定界</h2><p>当编写一个被其他函数B包含的函数A时，被包含的函数A可以访问包含其的函数B的所有局部变量，我们将这种特性称为词法定界（lexical scoping）。<br>虽然这种可见性规则听上去很明确，但实际上并非如此。词法定界外加嵌套的第一类值函数可以为编程语言提供强大的功能，但很多编程语言并不支持将这两者组合使用。</p><p>先看一个简单的例子。<br>假设有一个表，其中包含了学生的姓名和对应的成绩，如果我们想基于分数对学生姓名排序，分数高者在前，那么可以使用如下的代码完成上述需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = &#123;&quot;Peter&quot;,&quot;Paul&quot;,&quot;Mary&quot;&#125;</span><br><span class="line">grades = &#123;Mary = 10,Paul = 7,Peter = 8&#125;</span><br><span class="line"></span><br><span class="line">table.sort(names,function(n1,n2)</span><br><span class="line">return grades[n1] &gt; grades[n2]</span><br><span class="line">end)</span><br></pre></td></tr></table></figure><p>现在，假设我们想创建一个函数来完成这个需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sortbygrade(names,grade)</span><br><span class="line">table.sort(names,function(n1,n2)</span><br><span class="line">return grades[n1] &gt; grades[n2]</span><br><span class="line">end)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在后一个示例中，有趣的一点就在于传给函数sort的匿名函数可以访问grades，而grades是包含匿名函数的外层函数sortbygrade的形参。<br>在该匿名函数中，grades既不是全局变量也不是局部变量，而是我们所说的非局部变量（non-local variable）（由于历史原因，在Lua语言中非局部变量也被称为上值）。</p><p>这一点之所以如此有趣是因为，函数作为第一类值，能够逃逸（escape）出它们变量的原始定界范围。<br>考虑如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function newCounter()</span><br><span class="line">local count = 0</span><br><span class="line">return function()-- 匿名函数</span><br><span class="line">count = count + 1</span><br><span class="line">return count</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line">print(c1())--&gt; 1</span><br><span class="line">print(c1())--&gt; 2</span><br></pre></td></tr></table></figure><p>在上述代码中，匿名函数访问了一个非局部变量（count）并将其当作计数器。<br>然而，由于创建变量的函数（newCounter）己经返回，因此当我们调用匿名函数时，变量count似乎已经超出了作用范围。<br>但其实不然，由于闭包（closure）概念的存在，Lua语言能够正确地应对这种情况。<br>简单地说，一个闭包就是一个函数外加能够使该函数正确访问非局部变量所需的其他机制。<br>如果我们再次调用newCounter，那么一个新的局部变量count和一个新的闭包会被创建出来，这个新的闭包针对的是这个新变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c2 = newCounter()</span><br><span class="line">print(c2())--&gt; 1</span><br><span class="line">print(c1())--&gt; 3</span><br><span class="line">print(c2())--&gt; 2</span><br></pre></td></tr></table></figure><p>因此，c1和c2是不同的闭包。它们建立在相同的函数之上，但是各自拥有局部变量count的独立实例。</p><p>从技术上讲，Lua语言中只有闭包而没有函数。函数本身只是闭包的一种原型。不过尽管如此，只要不会引起混淆，我们就仍将使用术语“函数”来指代闭包。</p><p>闭包在许多场合中均是一种有价值的工具。<br>正如我们之前已经见到过的，闭包在作为诸如sort这样的高阶函数的参数时就非常有用。<br>同样，闭包对于那些创建了其他函数的函数也很有用，例如我们之前的newCounter示例及求导数的示例；这种机制使得Lua程序能够综合运用函数式编程世界中多种精妙的编程技巧。<br>另外，闭包对于回调（callback）函数来说也很有用。<br>对于回调函数而言，一个典型的例子就是在传统GUI工具箱中创建按钮。每个按钮通常都对应一个回调函数，当用户按下按钮时，完成不同的处理动作的回调函数就会被调用。<br>例如，假设有一个具有10个类似按钮的数字计算器（每个按钮代表一个十进制数字），我们就可以使用如下的函数来创建这些按钮：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function digitButton(digit)</span><br><span class="line">return Button&#123;</span><br><span class="line">label = tostring(digit),</span><br><span class="line">action = function()</span><br><span class="line">add_to_display(digit)</span><br><span class="line">end,</span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在上述示例中，假设Button是一个创建新按钮的工具箱函数，label是按钮的标签，action是当按钮按下时被调用的回调函数。回调可能发生在函数digitButton早已执行完后，那时变量digit已经超出了作用范围，但闭包仍可以访问它。</p><p>闭包在另一种很不一样的场景下也非常有用。<br>由于函数可以被保存在普通变量中，因此在Lua语言中可以轻松地重新定义函数，甚至是预定义函数。<br>这种机制也正是Lua语言灵活的原因之一。通常，当重新定义一个函数的时候，我们需要在新的实现中调用原来的那个函数。<br>例如，假设要重新定义函数sin以使其参数以角度为单位而不是以弧度为单位。那么这个新函数就可以先对参数进行转换，然后再调用原来的sin函数进行真正的计算。<br>代码可能形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local oldSin = math.sin</span><br><span class="line">math.sin = function(x)</span><br><span class="line">return oldSin(x * (math.pi / 180))</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>另一种更清晰一点的完成重新定义的写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">local oldSin = math.sin</span><br><span class="line">local k = math.pi / 180</span><br><span class="line">math.sin = function(x)</span><br><span class="line">return oldSin(x * k)</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述代码使用了do代码段来限制局部变量oldSin的作用范围；根据可见性规则，局部变量oldSin只在这部分代码段中有效。<br>因此，只有新版本的函数sin才能访问原来的sin函数，其他部分的代码则访问不了。</p><p>我们可以使用同样的技巧来创建安全的运行时环境（secure environment），即所谓的沙盒（sandbox）。<br>当执行一些诸如从远程服务器上下载到的未受信任代码（untrusted code）时，安全的运行时环境非常重要。<br>例如，我们可以通过使用闭包重定义函数io.open来限制一个程序能够访问的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">local oldOpen = io.open</span><br><span class="line">local access_ok = function(filename,mode)</span><br><span class="line">check access</span><br><span class="line">end</span><br><span class="line">io.open = function(filename,mode)</span><br><span class="line">if access_ok (filename,mode) then</span><br><span class="line">return oldOpen(filename,mode)</span><br><span class="line">else</span><br><span class="line">return nil,&quot;access denied&quot; </span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述示例的巧妙之处在于，在经过重新定义后，一个程序就只能通过新的受限版本来调用原来未受限版本的io.open函数。<br>示例代码将原来不安全的版本保存为闭包的一个私有变量，该变量无法从外部访问。<br>通过这一技巧，就可以在保证简洁性和灵活性的前提下在Lua语言本身上构建Lua沙盒。<br>相对于提供一套大而全（one-size-fits-all）的解决方案，Lua语言提供的是一套“元机制（meta-mechanism）”，借助这种机制可以根据特定的安全需求来裁剪具体的运行时环境（真实的沙盒除了保护外部文件外还有更多的功能，我们会在25.4节中再次讨论这个话题）。</p><h3 id="补充：闭包的实现原理"><a href="#补充：闭包的实现原理" class="headerlink" title="补充：闭包的实现原理"></a>补充：闭包的实现原理</h3><p>当Lua编译一个函数时，它会生成一个原型（prototype），原型中包括函数的虚拟机指令、函数中的常量（数值和字符串等）和一些调试信息。<br>在任何时候只要Lua执行一个function … end表达时，它都会创建一个新的闭包（closure）。每个闭包都有一个相应函数原型的引用以及一个数组，数组中每个元素都是一个对upvalue的引用，可以通过该数组来访问外部的局部变量（outer local variables）。<br>值得注意的是，在Lua 5.2之前，闭包中还包括一个对环境（environment）的引用，环境实质就是一个table，函数可以在该表中索引全局变量，从Lua 5.2开始，取消了闭包中的环境，而引入一个变量_ENV来设置闭包环境。<br>由此可见，函数是编译期概念，是静态的，而闭包是运行期概念，是动态的。</p><p>作用域（生成期）规则下的嵌套函数给如何实现内存函数存储外部函数的局部变量是一个众所周知的难题（The combination of lexical scoping with first-class functions creates a well-known difficulty for accessing outer local variables）。<br>比如例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add (x) </span><br><span class="line">return function (y) </span><br><span class="line">return x+y</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add2 = add(2)</span><br><span class="line">print(add2(5))</span><br></pre></td></tr></table></figure><p>当add2被调用时，其函数体访问了外部的局部变量x（在Lua中，函数参数也是局部变量）。<br>然而，当调用add2函数时，创建add2的add函数已经返回了，如果x在栈中创建，则当add返回时，x已经不存在了（即x的存储空间被回收了）。<br>为了解决上面的问题，不同语言有不同的方法，比如python通过限定作用域、Pascal限制函数嵌套以及C语言则两者都不允许。<br>在Lua中，使用一种称为upvalue结构来实现闭包。任何外部的局部变量都是通过upvalue来间接访问。<br>upvalue初始值是指向栈中，即变量在栈中的位置。如下图左边。<br>当运行时，离开变量作用域时（即超过变量生命周期），则会把变量复制到upvalue结构中（注意也只是在此刻才执行这个操作），如下图右边。<br>由于对变量的访问都是通过upvalue结构中指针间接进行的，因此复制操作对任何读或写变量的代码来说都是没有影响的。<br>与内部函数（inner functions）不同的是，声明该局部变量的函数都是直接在栈中操作它的。<br><img src="LuaProgramDesign/1.png"><br>通过为每个变量最多创建一个upvalue并按需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量（pending vars）能够在闭包之间正确地共享。<br>为了保证这种唯一性，Lua维护这一条链表，该链表中每个节点对应一个打开的upvalue（opend upvalue）结构，打开的upvalue是指当前正指向栈局部变量的upvalue，如上图的未决状态的局部变量链表（the pending vars list）。<br>当Lua创建一个新的闭包时，Lua会遍历当前函数所有的外部的局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则重复使用该打开的upvalue，否则，Lua会创建一个新的打开的upvalue，并把它插入链表中。<br>当局部变量离开作用域时（即超过变量生命周期），这个打开的upvalue就会变成关闭的upvalue（closed upvalue），并把它从链表中删除，如上图右图所示意。<br>一旦某个关闭的upvalue不再被任何闭包所引用，那么它的存储空间就会被回收。</p><p>一个函数有可能存取其更外层函数而非直接外层函数的局部变量。在这种情况下，当创建闭包时，这个局部变量可能不在栈中。<br>Lua使用flat 闭包(flat closures)来处理这种情况。使用flat闭包，无论何时一个函数访问一个外部的局部变量并且该变量不在直接外部函数中，该变量也会进入直接外部函数的闭包中。<br>当一个函数被实例化时，其对应闭包的所有变量要么在直接外部函数的栈中要么在直接外部函数的闭包中。</p><h1 id="Chapter10-模式匹配"><a href="#Chapter10-模式匹配" class="headerlink" title="Chapter10 模式匹配"></a>Chapter10 模式匹配</h1><p>与其他几种脚本语言不同，Lua语言既没有使用POSIX正则表达式，也没有使用Perl正则表达式来进行模式匹配（pattern matching）。<br>之所以这样做的主要原因在于大小问题：一个典型的POSIX正则表达式实现需要超过4000行代码，这比所有Lua语言标准库总大小的一半还大。相比之下，Lua语言模式匹配的实现代码只有不到600行。<br>尽管Lua语言的模式匹配做不到完整POSIX实现的所有功能，但是Lua语言的模式匹配仍然非常强大，同时还具有一些与标准POSIX不同但又可与之媲美的功能。</p><h2 id="10-1-模式匹配的相关函数"><a href="#10-1-模式匹配的相关函数" class="headerlink" title="10.1 模式匹配的相关函数"></a>10.1 模式匹配的相关函数</h2><p>字符串标准库提供了基于模式（pattern）的4个函数。</p><h3 id="10-1-1-函数string-find"><a href="#10-1-1-函数string-find" class="headerlink" title="10.1.1 函数string.find"></a>10.1.1 函数string.find</h3><p>函数string.find用于在指定的目标字符串中搜索指定的模式。</p><p>最简单的模式就是一个单词，它只会匹配到这个单词本身。<br>函数string.find找到一个模式后，会返回两个值：匹配到模式开始位置的索引和结束位置的索引。如果没有找到任何匹配，则返回nil。</p><p>函数string.find具有两个可选参数。<br>第3个参数是一个索引，用于说明从目标字符串的哪个位置开始搜索。<br>第4个参数是一个布尔值，用于说明是否进行简单搜索（plain search）。<br>字如其名，所谓简单搜索就是忽略模式而在目标字符串中进行单纯的“查找子字符串”的动作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; string.find(&quot;a [word]&quot;,&quot;[&quot;)</span><br><span class="line">stdin:1: malformed pattern (missing &#x27;]&#x27;)</span><br><span class="line"></span><br><span class="line">&gt; string.find(&quot;a [word]&quot;,&quot;[&quot;,1,true)--&gt; 3 3</span><br></pre></td></tr></table></figure><p>由于’[‘在模式中具有特殊含义，因此第1个函数调用会报错。在第2个函数调用中，函数只是把’[‘当作简单字符串。请注意，如果没有第3个参数，是不能传入第4个可选参数的。</p><h3 id="10-1-2-函数string-match"><a href="#10-1-2-函数string-match" class="headerlink" title="10.1.2 函数string.match"></a>10.1.2 函数string.match</h3><p>由于函数string.match也用于在一个字符串中搜索模式，因此它与函数string.find非常相似。不过，函数string.match返回的是目标字符串中与模式相匹配的那部分子串，而非该模式所在的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(string.math(&quot;hello world&quot;,&quot;hello&quot;))--&gt; hello</span><br></pre></td></tr></table></figure><p>对于诸如’hello’这样固定的模式，使用这个函数并没有什么意义。<br>然而，当模式是变量时，这个函数的强大之处就显现出来了，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;Today is 17/7/1990&quot;</span><br><span class="line">d = string.match(data,&quot; %d+/%d+/%d+&quot;);</span><br><span class="line">print(d)--&gt; 17/7/1990</span><br></pre></td></tr></table></figure><h3 id="10-1-3-函数string-gsub"><a href="#10-1-3-函数string-gsub" class="headerlink" title="10.1.3 函数string.gsub"></a>10.1.3 函数string.gsub</h3><p>函数string.gsub有3个必选参数：目标字符串、模式和替换字符串（replacementstring），其基本用法是将目标字符串中所有出现模式的地方换成替换字符串。</p><p>此外，该函数还有一个可选的第4个参数，用于限制替换的次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = string.gsub(&quot;all lii&quot;,&quot;l&quot;,&quot;x&quot;,1)</span><br><span class="line">print(s)--&gt; axl lii</span><br><span class="line">s = string.gsub(&quot;all lii&quot;,&quot;l&quot;,&quot;x&quot;,2)</span><br><span class="line">print(s)--&gt; axx lii</span><br></pre></td></tr></table></figure><p>除了替换字符串以外，string.gsub的第3个参数也可以是一个函数或一个表，这个函数或表会被调用（或检索）以产生替换字符串；我们会在10.4节中学习这个功能。</p><p>函数string.gsub还会返回第2个结果，即发生替换的次数。</p><h3 id="10-1-4-函数string-gmatch"><a href="#10-1-4-函数string-gmatch" class="headerlink" title="10.1.4 函数string.gmatch"></a>10.1.4 函数string.gmatch</h3><p>函数string.gmatch返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。</p><p>例如，以下示例可以找出指定字符串s中出现的所有单词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;some thing&quot;</span><br><span class="line">words = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for w in string.gmatch(s,&quot;%a+&quot;) do</span><br><span class="line">words[#words + 1] = w</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>后续我们马上会学习到，模式’%a+’会匹配一个或多个字母组成的序列（也就是单词）。<br>因此，for循环会遍历所有目标字符串中的单词，然后把它们保存到列表words中。</p><h2 id="10-2-模式"><a href="#10-2-模式" class="headerlink" title="10.2 模式"></a>10.2 模式</h2><p>大多数模式匹配库都使用反斜杠（backslash）作为转义符。然而，这种方式可能会导致一些不良的后果。<br>对于Lua语言的解析器而言，模式仅仅是普通的字符串。模式与其他的字符串一样遵循相同的规则，并不会被特殊对待；只有模式匹配相关的函数才会把它们当作模式进行解析。<br>由于反斜杠是Lua语言中的转义符，所以我们应该避免将它传递给任何函数。模式本身就难以阅读，到处把”&quot;换成”\“就更加火上浇油了。</p><p>我们可以使用双括号把模式括起来构成的长字符串来解决这个问题（某些语言在实践中推荐这种办法）。然而，长字符串的写法对于通常比较短的模式而言又往往显得冗长。此外，我们还会失去在模式内进行转义的能力（某些模式匹配工具通过再次实现常见的字符串转义来绕过这种限制）。</p><p>Lua语言的解决方案更加简单：Lua语言中的模式使用百分号（percent sign）作为转义符（C语言中的一些函数采用的也是同样的方式，如函数printf和函数strftime）。<br>总体上，所有被转义的字母都具有某些特殊含义（例如’%a’匹配所有字母），而所有被转义的非字母则代表其本身（例如’%.’匹配一个点）。</p><p>我们首先来学习字符分类（character class）的模式。<br>所谓字符分类，就是模式中能够与一个特定集合中的任意字符相匹配的一项。<br>例如，分类%d匹配的是任意数字。因此，可以使用模式’%d%d/%d%d/%d%d%d%d’来匹配dd/mm/yyyy格式的日期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;Dealine is 30/05/1999, firm&quot;</span><br><span class="line">data = &quot;%d%d/%d%d/%d%d%d%d&quot;</span><br><span class="line">print(string.match(s,data))--&gt; 30/05/1999</span><br></pre></td></tr></table></figure><p>下表列出了所有预置的字符分类及其对应的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.任意字符</span><br><span class="line">%a字母</span><br><span class="line">%c控制字符</span><br><span class="line">%d数字</span><br><span class="line">%g除空格外的可打印字符</span><br><span class="line">%l小写字母</span><br><span class="line">%p标点符号</span><br><span class="line">%s空白字符</span><br><span class="line">%u大写字母</span><br><span class="line">%w字母和数字</span><br><span class="line">%x十六进制数字</span><br></pre></td></tr></table></figure><p>这些类的大写形式表示类的补集。例如，’%A’代表任意非字母的字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((string.gsub(&quot;hello, up-down!&quot;,&quot;%A&quot;,&quot;.&quot;)))</span><br><span class="line">--&gt;hello.up.down.</span><br></pre></td></tr></table></figure><p>在输出函数gsub的返回结果时，我们使用了额外的括号来丢弃第二个结果，也就是替换发生的次数。</p><p>当在模式中使用时，还有一些被称为魔法字符（magic character）的字符具有特殊含义。<br>Lua语言的模式所使用的魔法字符包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) . % + - * ? [ ] ^ $</span><br></pre></td></tr></table></figure><p>正如我们之前已经看到的，百分号同样可以用于这些魔法字符的转义。<br>因此，’%？’匹配一个问号，’%%’匹配一个百分号。我们不仅可以用百分号对魔法字符进行转义，还可以将其用于其他所有字母和数字外的字符。当不确定是否需要转义时，为了保险起见就可以使用转义符。</p><p>可以使用字符集（char-set）来创建自定义的字符分类，只需要在方括号内将单个字符和字符分类组合起来即可。<br>例如，字符集’[%w_]’匹配所有以下画线结尾的字母和数字，’[01]’匹配二进制数字，’[%[%]]’匹配方括号。<br>如果想要统计一段文本中元音的数量，可以使用如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,nvow = string.gsub(text,&quot;AEIOUaeiou&quot;,&quot;&quot;)</span><br></pre></td></tr></table></figure><p>还可以在字符集中包含一段字符范围，做法是写出字符范围的第一个字符和最后一个字符并用横线将它们连接在一起。<br>由于大多数常用的字符范围都被预先定义了，所以这个功能很少被使用。例如，’%d’相当于’[0-9]’，’%x’相当于’[0-9a-fA-F]’。不过，如果需要查找一个八进制的数字，那么使用’[0-7]’就比显式地枚举’[01234567]’强多了。</p><p>在字符集前加一个补字符^就可以得到这个字符集对应的补集：模式’[^0-7]’代表所有八进制数字以外的字符，模式’[^\n]’则代表除换行符以外的其他字符。<br>尽管如此，我们还是要记得对于简单的分类来说可以使用大写形式来获得对应的补集：’%S’显然要比’[^%s]’更简单。</p><p>还可以通过描述模式中重复和可选部分的修饰符（modifier，在其他语言中也被译为限定符）来让模式更加有用。<br>Lua语言中的模式提供了4种修饰符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+重复一次或多次</span><br><span class="line">*重复零次或多次</span><br><span class="line">-重复零次或多次（最小匹配）</span><br><span class="line">?可选（出现零次或一次）</span><br></pre></td></tr></table></figure><p>修饰符+匹配原始字符分类中的一个或多个字符，它总是获取与模式相匹配的最长序列。<br>例如，模式’%a+’代表一个或多个字母（即一个单词）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((string.gsub(&quot;one, and two; and three&quot;,&quot;%a+&quot;,&quot;word&quot;)))</span><br><span class="line">--&gt; word, word word; word word</span><br></pre></td></tr></table></figure><p>模式’%d+’匹配一个或多个数字（一个整数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((string.match(&quot;the number 1298 is even&quot;,&quot;%d+&quot;)))</span><br><span class="line">--&gt; 1298</span><br></pre></td></tr></table></figure><p>修饰符 * 类似于修饰符 +，但是它还接受对应字符分类出现零次的情况。<br>该修饰符一个典型的用法就是在模式的部分之间匹配可选的空格。<br>例如，为了匹配像（）或（）这样的空括号对，就可以使用模式’%（%s*%）’，其中的’%s*’匹配零个或多个空格（括号在模式中有特殊含义，所以必须进行转义）。<br>另一个示例是用模式’[ _ %a][_%w]*’匹配Lua程序中的标识符：标识符是一个由字母或下画线开头，并紧跟零个或多个由下画线、字母或数字组成的序列。</p><p>修饰符 - 和修饰符 * 类似，也是用于匹配原始字符分类的零次或多次出现。<br>不过，跟修饰符 * 总是匹配能匹配的最长序列不同，修饰符-只会匹配最短序列。<br>虽然有时它们两者并没有什么区别，但大多数情况下这两者会导致截然不同的结果。<br>例如，当试图用模式’[_ %a][_ %w]-‘查找标识符时，由于’[_%w]-‘总是匹配空序列，所以我们只会找到第一个字母。<br>又如，假设我们想要删掉某C语言程序中的所有注释，通常会首先尝试使用’/%* .* %* /‘（即”/* “和”* /“之间的任意序列，使用恰当的转义符对* 进行转义）。然而，由于’.* ‘会尽可能长地匹配<br>，因此程序中的第一个”/* “只会与最后一个”*/“相匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = &quot;int x; /* x */ int y; /* y */&quot;</span><br><span class="line">print((string.gsub(test,&quot;/%*.*%*/&quot;,&quot;&quot;)))</span><br><span class="line">--&gt; int x;</span><br></pre></td></tr></table></figure><p>相反，模式’.-‘则只会匹配到找到的第一个”*/“，这样就能得到期望的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = &quot;int x; /* x */ int y; /* y */&quot;</span><br><span class="line">print((string.gsub(test,&quot;/%*.-%*/&quot;,&quot;&quot;)))</span><br><span class="line">--&gt; int x; int y;</span><br></pre></td></tr></table></figure><p>最后一个修饰符？可用于匹配一个可选的字符。<br>例如，假设我们想在一段文本中寻找一个整数，而这个整数可能包括一个可选的符号，那么就可以使用模式’[+-]？%d+’来完成这个需求，该模式可以匹配像”-12”、”23”和”+1009”这样的数字。其中，字符分类’[+-]’匹配加号或减号，而其后的问号则代表这个符号是可选的。</p><p>与其他系统不同的是，Lua语言中的修饰符只能作用于一个字符模式，而无法作用于一组分类。<br>例如，我们不能写出匹配一个可选的单词的模式（除非这个单词只由一个字母组成）。通常，可以使用一些将在本章最后介绍的高级技巧来绕开这个限制。</p><p>以补字符^开头的模式表示从目标字符串的开头开始匹配。<br>类似地，以$结尾的模式表示匹配到目标字符串的结尾。<br>我们可以同时使用这两个标记来限制匹配查找和锚定（anchor）模式。例如，如下的代码可以用来检查字符串s是否以数字开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if string.find(s,&quot;^%d&quot;) then ...</span><br></pre></td></tr></table></figure><p>如下的代码用来检查字符串是否为一个没有多余前缀字符和后缀字符的整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if string.find(s,&quot;^[+-]?%d+$&quot;) then ...</span><br></pre></td></tr></table></figure><p>^和$字符只有位于模式的开头和结尾时才具有特殊含义；否则，它们仅仅就是与其自身相匹配的普通字符。</p><p>模式’%b’匹配成对的字符串，它的写法是’%bxy’，其中x和y是任意两个不同的字符，x作为起始字符而y作为结束字符。<br>例如，模式’%b（）’匹配以左括号开始并以对应右括号结束的子串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;a (enclosed  (in) parentheses) line&quot;</span><br><span class="line">print((string.gsub(s,&quot;%b()&quot;,&quot;&quot;)))</span><br><span class="line">--&gt; a line;</span><br></pre></td></tr></table></figure><p>通常，我们使用’%b（）’、’%b[]’、’%b{}’或’%b&lt;&gt;’等作为模式，但实际上可以用任意不同的字符作为分隔符。</p><p>最后，模式’%f[char-set]’代表前置模式（frontier pattern）。<br>该模式只有在后一个字符位于char-set内而前一个字符不在时匹配一个空字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;the anthem is the anthem&quot;</span><br><span class="line">print((string.gsub(s,&quot;%f[%w]the%f[%W]&quot;,&quot;one&quot;)))</span><br><span class="line">--&gt; one anthem is one anthem;</span><br></pre></td></tr></table></figure><p>模式’%f[%w]’匹配位于一个非字母或数字的字符和一个字母或数字的字符之间的前置，<br>而模式’%f[%W]’则匹配一个字母或数字的字符和一个非字母或数字的字符之间的前置。<br>因此，指定的模式只会匹配完整的字符串”the”。<br>请注意，即使字符集只有一个分类，也必须把它用括号括起来。</p><p>前置模式把目标字符串中第一个字符前和最后一个字符后的位置当成空字符（ASCII编码的\0）。<br>在前例中，第一个”the”在不属于集合’[%w]’的空字符和属于集合’[%w]’的t之间匹配了一个前置。</p><h2 id="10-3-捕获"><a href="#10-3-捕获" class="headerlink" title="10.3 捕获"></a>10.3 捕获</h2><p>捕获（capture）机制允许根据一个模式从目标字符串中抽出与该模式匹配的内容来用于后续用途，可以通过把模式中需要捕获的部分放到一对圆括号内来指定捕获。</p><p>对于具有捕获的模式，函数string.match会将所有捕获到的值作为单独的结果返回；换句话说，该函数会将字符串切分成多个被捕获的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair = &quot;name = zwt&quot;</span><br><span class="line">key,value= string.match(pair,&quot;(%a+)%s*=%s*(%a+)&quot;)</span><br><span class="line">print(key,value)--&gt; name zwt</span><br></pre></td></tr></table></figure><p>模式’%a+’表示一个非空的字母序列，模式’%s*’表示一个可能为空的空白序列。<br>因此，上例中的这个模式表示一个字母序列、紧跟着空白序列、一个等号、空白序列以及另一个字母序列。<br>模式中的两个字母序列被分别放在圆括号中，因此在匹配时就能捕获到它们。</p><p>下面是一个类似的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date = &quot;Today is 17/7/1990&quot;</span><br><span class="line">d,m,y = string.match(date,&quot;(%d+)/(%d+)/(%d+)&quot;)</span><br><span class="line">print(d,m,y)--&gt; 17 7 1990</span><br></pre></td></tr></table></figure><p>在这个示例中，使用了3个捕获，每个捕获对应一个数字序列。</p><p>在模式中，形如’%n’的分类（其中n是一个数字），表示匹配第n个捕获的副本。<br>举一个典型的例子，假设想在一个字符串中寻找一个由单引号或双引号括起来的子串。<br>那么可能会尝试使用模式’[“‘].-[“‘]’，它表示一个引号后面跟任意内容及另外一个引号；但是，这种模式在处理像”it’s all right”这样的字符串时会有问题。<br>要解决这个问题，可以捕获第一个引号然后用它来指明第二个引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [[then he said: &quot;it&#x27;s all right&quot;!]]</span><br><span class="line">q,quotedPart = string.match(s,&quot;([\&quot;&#x27;])(.-)%1&quot;)</span><br><span class="line">print(quotedPart)--&gt; it&#x27;s all right</span><br><span class="line">print(q)--&gt; &quot;</span><br></pre></td></tr></table></figure><p>第1个捕获是引号本身，第2个捕获是引号中的内容（与’.-‘匹配的子串）。</p><p>下例是一个类似的示例，用于匹配Lua语言中的长字符串的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[(=*)%[(.-)%]%1%]</span><br></pre></td></tr></table></figure><p>它所匹配的内容依次是：一个左方括号、零个或多个等号、另一个左方括号、任意内容（即字符串的内容）、一个右方括号、相同数量的等号及另一个右方括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = &quot;%[(=*)%[(.-)%]%1%]&quot;</span><br><span class="line">s = &quot;a = [=[[[ something ]] ]==] ]=]; print(a)&quot;</span><br><span class="line">print(string.match(s,p))--&gt; = [[ something ]] ]==] </span><br></pre></td></tr></table></figure><p>第1个捕获是等号序列（在本例中只有一个），第2个捕获是字符串内容。</p><p>被捕获对象的第3个用途是在函数gsub的替代字符串中。<br>像模式一样，替代字符串同样可以包括像”%n”一样的字符分类，当发生替换时会被替换为相应的捕获。<br>特别地，”%0”意味着整个匹配，并且替换字符串中的百分号必须被转义为”%%”。</p><p>下面这个示例会重复字符串中的每个字母，并且在每个被重复的字母之间插入一个减号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((string.gsub(&quot;hello lua!&quot;,&quot;%a&quot;,&quot;%0-%0&quot;)))</span><br><span class="line">--&gt;h-he-el-ll-lo-o l-lu-ua-a!</span><br></pre></td></tr></table></figure><p>下例交换了相邻的字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((string.gsub(&quot;hello lua!&quot;,&quot;(.)(.)&quot;,&quot;%2%1&quot;)))</span><br><span class="line">--&gt;ehll oul!a</span><br></pre></td></tr></table></figure><p>以下是一个更有用的示例，让我们编写一个原始的格式转换器，该格式转换器能读取LATEX风格的命令，并将它们转换成XML风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\command&#123;some text&#125;--&gt; &lt;command&gt;some text&lt;/command&gt;</span><br></pre></td></tr></table></figure><p>如果不允许嵌套的命令，那么以下调用函数string.gsub的代码即可完成这项工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [[the \quote&#123;task&#125; is to \em&#123;change&#125; that.]]</span><br><span class="line">s = string.gsub(s,&quot;\\(%a+)&#123;(.-)&#125;&quot;,&quot;&lt;%1&gt;%2&lt;/%1&gt;&quot;)</span><br><span class="line">print(s)</span><br><span class="line">--&gt;the &lt;quote&gt;task&lt;/quote&gt; is to &lt;em&gt;change&lt;/em&gt; that.</span><br></pre></td></tr></table></figure><p>另一个有用的示例是剔除字符串两端空格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function trim(s)</span><br><span class="line">s = string.gsub(s,&quot;^%s*(.-)%s*$&quot;,&quot;%1&quot;)</span><br><span class="line">return s</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>请注意模式中修饰符的合理运用。两个定位标记（^和$）保证了我们可以获取到整个字符串。由于中间的’.-‘只会匹配尽可能少的内容，所以两个’%s*’便可匹配到首尾两端的空格。</p><h2 id="10-4-替换"><a href="#10-4-替换" class="headerlink" title="10.4 替换"></a>10.4 替换</h2><p>正如我们此前已经看到的，函数string.gsub的第3个参数不仅可以是字符串，还可以是一个函数或表。<br>当第3个参数是一个函数时，函数string.gsub会在每次找到匹配时调用该函数，参数是捕获到的内容而返回值则被作为替换字符串。<br>当第3个参数是一个表时，函数string.gsub会把第一个捕获到的内容作为键，然后将表中对应该键的值作为替换字符串。<br>如果函数的返回值为nil或表中不包含这个键或表中键的对应值为nil，那么函数gsub不改变这个匹配。</p><p>最后一个例子，让我们再回到上一节中提到的格式转换器。<br>我们仍然是想将LATEX风格的命令（\example{text}）转换成XML风格的（<example>text</example>），但这次允许嵌套的命令。<br>以下的函数用递归的方式完成了这个需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function toxml(s)</span><br><span class="line">s = string.gsub(s,&quot;\\(%a+)(%b&#123;&#125;)&quot;,function(tag,body)</span><br><span class="line">body = string.sub(body,2,-2)-- 移除括号</span><br><span class="line">body = toxml(body)-- 处理嵌套的命令</span><br><span class="line">return string.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;,tag,body,tag)</span><br><span class="line">end)</span><br><span class="line"></span><br><span class="line">return s</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(toxml(&quot;\\title&#123;The \\bold&#123;big&#125; example&#125;&quot;))</span><br><span class="line">--&gt;&lt;title&gt;The &lt;bold&gt;big&lt;/bold&gt; example&lt;/title&gt;</span><br></pre></td></tr></table></figure><h3 id="10-4-1-URL编码"><a href="#10-4-1-URL编码" class="headerlink" title="10.4.1 URL编码"></a>10.4.1 URL编码</h3><p>我们的下一个示例中将用到URL编码，也就是HTTP所使用的在URL中传递参数的编码方式。<br>这种编码方式会将特殊字符（例如=、＆和+）编码为”%xx”的形式，其中xx是对应字符的十六进制值。此外，URL编码还会将空格转换为加号。</p><p>例如，字符串”a+b = c”的URL编码为”a%2Bb+%3D+c”。<br>最后，URL编码会将每对参数名及其值用等号连接起来，然后将每对name=value用＆连接起来。<br>例如，值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;al&quot;; query = &quot;a+b = c&quot;;q = &quot;yes or no&quot;</span><br></pre></td></tr></table></figure><p>对应的URL编码为”name=al＆query=a%2Bb+%3D+c＆q=yes+or+no”。</p><h3 id="10-4-2-制表符展开"><a href="#10-4-2-制表符展开" class="headerlink" title="10.4.2 制表符展开"></a>10.4.2 制表符展开</h3><p>在Lua语言中，像’（）’这样的空白捕获（empty capture）具有特殊含义。<br>该模式并不代表捕获空内容（这样的话毫无意义），而是捕获模式在目标字符串中的位置（该位置是数值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(string.match(&quot;hello&quot;,&quot;()ll()&quot;))--&gt; 3 5</span><br></pre></td></tr></table></figure><p>（请注意，由于第2个空捕获的位置是在匹配之后，所以这个示例的结果与调用函数string.find得到的结果并不一样。）</p><h2 id="10-5-诀窍"><a href="#10-5-诀窍" class="headerlink" title="10.5 诀窍"></a>10.5 诀窍</h2><p>模式匹配是进行字符串处理的强大工具之一。虽然通过多次调用函数string.gsub就可以完成许多复杂的操作，但是还是应该谨慎地使用该函数。</p><p>通常，在Lua程序中使用模式匹配时的效率是足够高的：笔者的新机器可以在不到0.2秒的时间内计算出一个4.4MB大小（具有85万个单词）的文本中所有单词的数量。<br>但仍然需要注意，应该永远使用尽可能精确的模式，不精确的模式会比精确的模式慢很多。<br>一个极端的例子是模式’（.-）%$’，它用于获取字符串中第一个$符号前的所有内容。<br>如果目标字符串中有$符号，那么这个模式工作很正常；但是，如果字符串中没有$符号，那么模式匹配算法就会首先从字符串起始位置开始匹配，直至为了搜索$符号而遍历完整个字符串。当到达字符串结尾时，这次从字符串起始位置开始的模式匹配就失败了。<br>之后，模式匹配算法又从字符串的第二个位置开始第二次搜索，结果仍然是无法匹配这个模式。这个匹配过程会在字符串的每个位置上进行一次，从而导致O（n2）的时间复杂度。<br>在笔者的新机器上，搜索20万个字符需要耗费超过4分钟的时间。<br>要解决这个问题，我们只需使用’^（.-）%$’将模式锚定在字符串的开始位置即可。这样，如果不能从起始位置开始找到匹配，搜索就会停止。有了^的锚定以后，该模式匹配就只需要不到0.01秒的时间了。</p><p>此外，还要留心空模式，也就是那些匹配空字符串的模式。<br>例如，如果试图使用模式’%a*’来匹配名字，那么就会发现到处都是名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i,j = string.find(&quot;;$% **#$hello13&quot;,&quot;%a*&quot;)</span><br><span class="line">print(i,j)--&gt; 1 0</span><br></pre></td></tr></table></figure><p>在这个示例中，函数string.find在字符串的开始位置正确地找到一个空的字母序列。</p><p>在模式的结束处使用修饰符-是没有意义的，因为这样只会匹配到空字符串。该修饰符总是需要在其后跟上其他的东西来限制扩展的范围。同样，含有’.*’的模式也非常容易出错，这主要是因为这种模式可能会匹配到超出我们预期范围的内容。</p><h1 id="Chapter11-小插曲：出现频率最高的单词"><a href="#Chapter11-小插曲：出现频率最高的单词" class="headerlink" title="Chapter11 小插曲：出现频率最高的单词"></a>Chapter11 小插曲：出现频率最高的单词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">local counter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for line in io.lines() do</span><br><span class="line">forword in string.gmatch(line,&quot;%w+&quot;) do</span><br><span class="line">counter[word] = (counter[word] or 0) + 1</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local words = &#123;&#125;-- 文本中所有单词的列表</span><br><span class="line"></span><br><span class="line">for w in pairs(counter) do</span><br><span class="line">words[#words + 1] = w</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">table.sort(words,function(w1,w2)</span><br><span class="line">return counter[w1] &gt; counter[w2] or (counter[w1] == counter[w2] and w1 &lt; w2)</span><br><span class="line">end)</span><br></pre></td></tr></table></figure><h1 id="Chapter12-日期和时间"><a href="#Chapter12-日期和时间" class="headerlink" title="Chapter12 日期和时间"></a>Chapter12 日期和时间</h1><p>Lua语言的标准库提供了两个用于操作日期和时间的函数，这两个函数在C语言标准库中也存在，提供的是同样的功能。虽然这两个函数看上去很简单，但依旧可以基于这些简单的功能完成很多复杂的工作。</p><p>Lua语言针对日期和时间使用两种表示方式。</p><p>第1种表示方式是一个数字，这个数字通常是一个整型数。<br>尽管并非是ISO C所必需的，但在大多数系统中这个数字是自一个被称为纪元（epoch）的固定日期后至今的秒数。特别地，在POSIX和Windows系统中这个固定日期均是Jan 01,1970,0:00 UTC。</p><p>Lua语言针对日期和时间提供的第2种表示方式是一个表。<br>日期表（date table）具有以下几个重要的字段：year、month、day、hour、min、sec、wday、yday和isdst，除isdst以外的所有字段均为整型数。<br>前6个字段的含义非常明显，而wday字段表示本周中的第几天（第1天为星期天）；yday字段表示当年中的第几天（第1天是1月1日）；isdst字段表示布尔类型，如果使用夏时令则为真。</p><p>例如，Sep 16,1998,23:48:10（星期三）对应的表是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = 1998,month = 9,day = 16,yday = 259,wday = 4,</span><br><span class="line"> hour = 23,min = 48,sec = 10,isdst = false&#125;</span><br></pre></td></tr></table></figure><p>日期表中不包括时区，程序需要负责结合相应的时区对其正确解析。</p><h2 id="12-1-函数os-time"><a href="#12-1-函数os-time" class="headerlink" title="12.1 函数os.time"></a>12.1 函数os.time</h2><p>不带任何参数调用函数os.time，会以数字形式返回当前的日期和时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local time = os.time()</span><br><span class="line">print(time)--&gt; 1659428550</span><br></pre></td></tr></table></figure><p>对应的时间是08 02,2022,08:22:30。在一个POSIX系统中，可以使用一些基本的数学运算分离这个数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">local date = 1659428550</span><br><span class="line"></span><br><span class="line">local day2year = 365.242-- 一年的天数</span><br><span class="line">local sec2hour = 60 * 60 -- 一小时的秒数</span><br><span class="line">local sec2day  = sec2hour * 24-- 一天的秒数</span><br><span class="line">local sec2year = sec2day * day2year-- 一年的秒数</span><br><span class="line"></span><br><span class="line">-- 年</span><br><span class="line">print(date // sec2year + 1970)--&gt; 2022</span><br><span class="line"></span><br><span class="line">-- 小时（UTC格式）</span><br><span class="line">print(date % sec2day // sec2hour)--&gt; 8</span><br><span class="line"></span><br><span class="line">-- 分钟</span><br><span class="line">print(date % sec2hour // 60)--&gt; 22</span><br><span class="line"></span><br><span class="line">-- 秒</span><br><span class="line">print(date % 60)--&gt; 30</span><br></pre></td></tr></table></figure><p>如果以一个日期表作为参数调用函数os.time，那么该函数会返回该表中所描述日期和时间对应的数字。<br>year、month和day字段是必需的，hour、min和sec字段如果没有提供的话则默认为12:00:00，其余字段（包括wday和yday）则会被忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local time = os.time(&#123;year = 2022,month = 8,day = 2,hour = 8,min = 22,sec = 30&#125;)</span><br><span class="line">print(time)--&gt; 1659399750</span><br></pre></td></tr></table></figure><h2 id="12-2-函数os-date"><a href="#12-2-函数os-date" class="headerlink" title="12.2 函数os.date"></a>12.2 函数os.date</h2><p>函数os.date在一定程度上是函数os.time的反函数（尽管这个函数的名字写的是date），它可以将一个表示日期和时间的数字转换为某些高级的表示形式，要么是日期表要么是字符串。<br>该函数的第1个参数是描述期望表示形式的格式化字符串（format string），第2个参数是数字形式的日期和时间（如果不提供，则默认为当前日期和时间）。<br>要生成一个日期表，可以使用格式化字符串”*t”。例如，调用函数os.date（”*t”,906000490）会返回下列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;year = 1998,month = 9,day = 16,yday = 259,wday = 4,</span><br><span class="line"> hour = 23,min = 48,sec = 10,isdst = false&#125;</span><br></pre></td></tr></table></figure><p>大致上，对于任何有效的时间t，os.time（os.date（”*t”,t））==t均成立。</p><p>对于其他格式化字符串，函数os.date会将日期格式化为一个字符串，该字符串是根据指定的时间和日期信息对特定的指示符进行了替换的结果。<br>所有的指示符都以百分号开头紧跟一个字母，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(os.date(&quot;a %A in %B&quot;))--&gt; a Tuesday in August</span><br><span class="line">print(os.date(&quot;%d/%m/%Y&quot;,906000490))--&gt;17/09/1998</span><br></pre></td></tr></table></figure><p>下表列出了主要的指示符，这些指示符使用的时间为1998年9月16日（星期三）23:48:10。<br>【函数os.date的指示符】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%a星期几的简写（例：Wed）</span><br><span class="line">%A星期几的全名（例：Wednesday）</span><br><span class="line">%b月份的简写（例：Sep）</span><br><span class="line">%B月份的全名（例：September）</span><br><span class="line">%c日期和时间（例：09/16/98 23：48:18）</span><br><span class="line">%d一个月中的第几天（16）[01-31]</span><br><span class="line">%H24小时制中的小时数（23）[00-23]</span><br><span class="line">%I12小时制中的小时数（11）[01-12]</span><br><span class="line">%j一年中的第几天（259）[001-365]</span><br><span class="line">%m月份（09）[01-12]</span><br><span class="line">%M分钟（48）[00-59]</span><br><span class="line">%p&quot;am&quot;或&quot;pm&quot;（pm）</span><br><span class="line">%S秒数（10）[00-60]</span><br><span class="line">%w星期（3）[0-6 = Sunday-Saturday]</span><br><span class="line">%W一年中的第几周（37）[00-53]</span><br><span class="line">%x日期（例：09/16/98）</span><br><span class="line">%X时间（例：23:48:10）</span><br><span class="line">%y两位数的年份（98）[00-99]</span><br><span class="line">%Y完整的年份（1998）</span><br><span class="line">%z时区（例：-0300）</span><br><span class="line">%%百分号</span><br></pre></td></tr></table></figure><p>如果格式化字符串以叹号开头，那么函数os.date会以UTC格式对其进行解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 纪元</span><br><span class="line">print(os.date(&quot;!%c&quot;,0))--&gt; 01/01/70 00:00:00</span><br></pre></td></tr></table></figure><p>如果不带任何参数调用函数os.date，那么该函数会使用格式%c，即以一种合理的格式表示日期和时间信息。<br>请注意，%x、%X和%c会根据不同的区域和系统而发生变化。如果需要诸如dd/mm/yyyy这样的固定表示形式，那么就必须显式地使用诸如”%d/%m/%Y”这样的格式化字符串。</p><h2 id="12-3-日期和时间处理"><a href="#12-3-日期和时间处理" class="headerlink" title="12.3 日期和时间处理"></a>12.3 日期和时间处理</h2><p>当函数os.date创建日期表时，该表的所有字段均在有效的范围内。当我们给函数os.time传入一个日期表时，其中的字段并不需要归一化。这个特性对于日期和时间处理非常重要。</p><p>函数os.difftime用来计算两个时间之间的差值，该函数以秒为单位返回两个指定数字形式表示的时间的差值。<br>对于大多数系统而言，这个差值就是一个时间相对于另一个时间的减法结果。但是，与减法不同，函数os.difftime的行为在任何系统中都是确定的。</p><p>我们还可以使用函数os.difftime来计算一段代码的执行时间。<br>不过，对于这个需求，更好的方式是使用函数os.clock，该函数会返回程序消耗的CPU时间（单位是秒）。<br>函数os.clock在性能测试（benchmark）中的典型用法形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local x = os.clock()</span><br><span class="line">local s = 0</span><br><span class="line">for i = 1,100000 do</span><br><span class="line">s = s + 1</span><br><span class="line">end</span><br><span class="line">print(string.format(&quot;elapsed time: %.2f\n&quot;,os.clock() - x))--&gt;elapsed time: 0.81</span><br></pre></td></tr></table></figure><p>与函数os.time不同，函数os.clock通常具有比秒更高的精度，因此其返回值为一个浮点数。具体的精度与平台相关，在POSIX系统中通常是1毫秒。</p><h1 id="Chapter13-位和字节"><a href="#Chapter13-位和字节" class="headerlink" title="Chapter13 位和字节"></a>Chapter13 位和字节</h1><p>Lua语言处理二进制数据的方式与处理文本的方式类似。<br>Lua语言中的字符串可以包含任意字节，并且几乎所有能够处理字符串的库函数也能处理任意字节。我们甚至可以对二进制数据进行模式匹配。</p><h2 id="13-1-位运算"><a href="#13-1-位运算" class="headerlink" title="13.1 位运算"></a>13.1 位运算</h2><p>Lua语言从5.3版本开始提供了针对数值类型的一组标准位运算符（bitwise operator）。<br>与算术运算符不同的是，位运算符只能用于整型数。<br>位运算符包括＆（按位与）、|（按位或）、～（按位异或）、&gt;&gt;（逻辑右移）、&lt;&lt;（逻辑左移）和一元运算符～（按位取反）。<br>（请注意，在其他一些语言中，异或运算符为^，而在Lua语言中^代表幂运算。）</p><p>两个移位操作都会用0填充空出的位，这种行为通常被称为逻辑移位（logical shift）。<br>Lua语言没有提供算术右移（arithmetic right shift），即使用符号位填充空出的位。</p><p>如果移位数等于或大于整型表示的位数（标准Lua为64位，精简Lua为32位），由于所有的位都被从结果中移出了，所以结果是0。</p><h2 id="13-2-无符号整型数"><a href="#13-2-无符号整型数" class="headerlink" title="13.2 无符号整型数"></a>13.2 无符号整型数</h2><p>整型表示中使用一个比特来存储符号位。<br>因此，64位整型数最大可以表示2^63-1而不是2^64-1。通常，这点区别是无关紧要的，因为2^63-1已经相当大了。</p><p>不过，由于我们可能需要处理使用无符号整型表示的外部数据或实现一些需要64位整型数的算法，因而有时也不能浪费这个符号位。<br>此外，在精简Lua中，这种区别可能会很重要。<br>例如，如果用一个32位有符号整型数表示文件中的位置，那么能够操作的最大文件大小就是2GB；而一个无符号整型数能操作的最大文件大小则是有符号整型数的2倍，即4GB。</p><h2 id="13-3-打包和解包二进制数据"><a href="#13-3-打包和解包二进制数据" class="headerlink" title="13.3 打包和解包二进制数据"></a>13.3 打包和解包二进制数据</h2><p>Lua 5.3还引入了一个在二进制数和基本类型值（数值和字符串类型）之间进行转换的函数。<br>函数string.pack会把值“打包（pack）”为二进制字符串，而函数string.unpack则从字符串中提取这些值。<br>函数string.pack和函数string.unpack的第1个参数是格式化字符串，用于描述如何打包数据。<br>格式化字符串中的每个字母都描述了如何打包/解包一个值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = string.pack(&quot;iii&quot;,3,-27,450)</span><br><span class="line">#s--&gt; 12</span><br><span class="line">string.unpack(&quot;iii&quot;,s)--&gt; 3 -27 450 13</span><br></pre></td></tr></table></figure><h2 id="13-4-二进制文件"><a href="#13-4-二进制文件" class="headerlink" title="13.4 二进制文件"></a>13.4 二进制文件</h2><p>函数io.input和io.output总是以文本方式（text mode）打开文件。<br>在POSIX操作系统中，二进制文件和文本文件是没有差别的。<br>然而，在其他一些像Windows之类的操作系统中，必须用特殊方式来打开二进制文件，即在io.open的模式字符串中使用字母b。</p><h1 id="Chapter14-数据结构"><a href="#Chapter14-数据结构" class="headerlink" title="Chapter14 数据结构"></a>Chapter14 数据结构</h1><p>Lua语言中的表并不是一种数据结构，它们是其他数据结构的基础。<br>我们可以用Lua语言中的表来实现其他语言提供的数据结构，如数组、记录、列表、队列、集合等。而且，用Lua语言中的表实现这些数据结构还很高效。</p><h2 id="14-1-数组"><a href="#14-1-数组" class="headerlink" title="14.1 数组"></a>14.1 数组</h2><p> 在Lua语言中，简单地使用整数来索引表即可实现数组。因此，数组的大小不用非得是固定的，而是可以按需增长的。</p><h2 id="14-2-矩阵及多维数组"><a href="#14-2-矩阵及多维数组" class="headerlink" title="14.2 矩阵及多维数组"></a>14.2 矩阵及多维数组</h2><p>在Lua语言中，有两种方式来表示矩阵。</p><p>第一种方式是使用一个不规则数组（jagged array），即数组的数组，也就是一个所有元素均是另一个表的表。</p><p>在Lua中表示矩阵的第二种方式是将两个索引合并为一个。<br>典型情况下，我们通过将第一个索引乘以一个合适的常量再加上第二个索引来实现这种效果。</p><h2 id="14-3-链表"><a href="#14-3-链表" class="headerlink" title="14.3 链表"></a>14.3 链表</h2><p>由于表是动态对象，所以在Lua语言中可以很容易地实现链表（linked list）。<br>我们可以把每个节点用一个表来表示（也只能用表表示），链接则为一个包含指向其他表的引用的简单表字段。</p><h2 id="14-4-队列及双端队列"><a href="#14-4-队列及双端队列" class="headerlink" title="14.4  队列及双端队列"></a>14.4  队列及双端队列</h2><p>在Lua语言中实现队列（queue）的一种简单方法是使用table标准库中的函数insert和remove。<br>正如我们在5.6节中所看到的，这两个函数可以在一个数组的任意位置插入或删除元素，同时根据所做的操作移动其他元素。不过，这种移动对于较大的结构来说开销很大。<br>一种更高效的实现是使用两个索引，一个指向第一个元素，另一个指向最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-- 一个双端队列</span><br><span class="line">function ListNew()</span><br><span class="line">return &#123;first = 0,last = -1&#125;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function PushFirst(list,value)</span><br><span class="line">local first = list.first - 1;</span><br><span class="line">list.first = first;</span><br><span class="line">list[first] = value;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function PushLast(list,value)</span><br><span class="line">local last = list.last + 1;</span><br><span class="line">list.last = last;</span><br><span class="line">list[last] = value;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function PopFirst(list)</span><br><span class="line">local first = list.first;</span><br><span class="line">if first &gt; list.last then</span><br><span class="line">error(&quot;list is empty&quot;);</span><br><span class="line">end</span><br><span class="line">local value = list[first];</span><br><span class="line">list[first] = nil;--使得元素能够被垃圾回收</span><br><span class="line">list.first = first + 1;</span><br><span class="line">return value;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function PopLast(list)</span><br><span class="line">local last = list.last;</span><br><span class="line">if list.first &gt; last then</span><br><span class="line">error(&quot;list is empty&quot;);</span><br><span class="line">end</span><br><span class="line">local value = list[last];</span><br><span class="line">list[last] = nil;--使得元素能够被垃圾回收</span><br><span class="line">list.last = last - 1;</span><br><span class="line">return value;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="14-5-反向表"><a href="#14-5-反向表" class="headerlink" title="14.5 反向表"></a>14.5 反向表</h2><p>正如此前提到的，我们很少在Lua语言中进行搜索操作。相反，我们使用被称为索引表（index table）或反向表（reverse table）的数据结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 反向表</span><br><span class="line">local days = &#123;&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;&#125;;</span><br><span class="line"></span><br><span class="line">local revDays = &#123;&#125;</span><br><span class="line">for k,v in pairs(days) do</span><br><span class="line">revDays[v] = k;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="14-6-集合与包"><a href="#14-6-集合与包" class="headerlink" title="14.6 集合与包"></a>14.6 集合与包</h2><p>假设我们想列出一个程序源代码中的所有标识符，同时过滤掉其中的保留字。<br>一些C程序员可能倾向于使用字符串数组来表示保留字集合，然后搜索这个数组来决定某个单词是否属于该集合。<br>为了提高搜索的速度，他们还可能会使用二叉树来表示该集合。</p><p>在Lua语言中，还可以用一种高效且简单的方式来表示这类集合，即将集合元素作为索引放入表中。<br>那么，对于指定的元素无须再搜索表，只需用该元素检索表并检查结果是否为nil即可。</p><p>以上述需求为例，代码形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 集合</span><br><span class="line">local reserved = &#123;</span><br><span class="line">[&quot;while&quot;] = true,</span><br><span class="line">[&quot;if&quot;] = true,</span><br><span class="line">[&quot;else&quot;] = true,</span><br><span class="line">[&quot;do&quot;] = true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 包（bag），也被称为多重集合（multiset），与普通集合的不同之处在于其中的元素可以出现多次。在Lua语言中，包的简单表示类似于此前集合的表示，只不过其中的每一个键都有一个对应的计数器。</p><h2 id="14-7-字符串缓冲区"><a href="#14-7-字符串缓冲区" class="headerlink" title="14.7 字符串缓冲区"></a>14.7 字符串缓冲区</h2><p>假设我们正在开发一段处理字符串的程序，比如逐行地读取一个文件。<br>典型的代码可能形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local buff = &quot;&quot;;</span><br><span class="line">for line in io.lines() do</span><br><span class="line">buff = buff..line..&quot;\n&quot;;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>虽然这段Lua语言代码看似能够正常工作，但实际上在处理大文件时却可能导致巨大的性能开销。例如，在笔者的新机器上用这段代码读取一个4.5MB大小的文件需要超过30秒的时间。</p><p>这是为什么呢？为了搞清楚到底发生了什么，让我们想象一下读取循环中发生了什么。<br>假设每行有20字节，当我们读取了大概2500行后，buff就会变成一个50KB大小的字符串。<br>在Lua语言中进行字符串连接buff..line..”\n”时，会创建一个50020字节的新字符串，然后从buff中复制50000字节中到这个新字符串中。<br>这样，对于后续的每一行，Lua语言都需要移动大概50KB且还在不断增长的内存。<br>因此，该算法的时间复杂度是二次方的。<br>在读取了100行（仅2KB）以后，Lua语言就已经移动了至少5MB内存。当Lua语言完成了350KB的读取后，它已经至少移动了50GB的数据。<br>（这个问题不是Lua语言特有的：在其他语言中，只要字符串是不可变值（immutable value），就会出现类似的问题，其中最有名的例子就是Java。）</p><p>在继续学习之前，我们必须说明，上述场景中的情况并不常见。<br>对于较小的字符串，上述循环并没什么问题。<br>当读取整个文件时，Lua语言提供了带有参数的函数io.read（”a”）来一次性地读取整个文件。<br>不过，有时候我们必须面对这个问题。<br>Java提供了StringBuffer类来解决这个问题；而在Lua语言中，我们可以把一个表当作字符串缓冲区，其关键是使用函数table.concat，这个函数会将指定列表中的所有字符串连接起来并返回连接后的结果。</p><p>使用函数concat可以这样重写上述循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local t = &#123;&#125;;</span><br><span class="line">for line in io.lines() do</span><br><span class="line">t[#t + 1] = line .. &quot;\n&quot;;</span><br><span class="line">end</span><br><span class="line">local s = table.concat(t);</span><br></pre></td></tr></table></figure><p>我们还可以做得更好。函数concat还有第2个可选参数，用于指定插在字符串间的分隔符。有了这个分隔符，我们就不必在每行后插入换行符了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local t = &#123;&#125;;</span><br><span class="line">for line in io.lines() do</span><br><span class="line">t[#t + 1] = line;</span><br><span class="line">end</span><br><span class="line">local s = table.concat(t,&quot;\n&quot;)..&quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>虽然函数concat能够在字符串之间插入分隔符，但我们还需要增加最后一个换行符。<br>最后一次字符串连接创建了结果字符串的一个副本，这个副本可能已经相当长了。<br>虽然没有直接的选项能够让函数concat插入这个额外的分隔符，但我们可以想办法绕过，只需在字符串t后面添加一个空字符串就行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[#t + 1] = &quot;&quot;;</span><br><span class="line">s = table.concat(t,&quot;\n&quot;);</span><br></pre></td></tr></table></figure><h2 id="14-8-图形"><a href="#14-8-图形" class="headerlink" title="14.8 图形"></a>14.8 图形</h2><p>我们使用一个由两个字段组成的表来表示每个节点，即name（节点的名称）和adj（与此节点邻接的节点的集合）。<br>由于我们会从一个文本文件中加载图对应的数据，所以需要能够根据节点的名称来寻找指定节点的方法。<br>因此，我们使用了一个额外的表来建立节点和节点名称之间的映射。<br>函数name2node可以根据指定节点的名称返回对应的节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local function name2node(graph,name)</span><br><span class="line">local node = graph[name];</span><br><span class="line">if not node then</span><br><span class="line">--节点不存在，创建一个新节点</span><br><span class="line">node = &#123;name = name,adj = &#123;&#125;&#125;;</span><br><span class="line">graph[name] = node;</span><br><span class="line">end</span><br><span class="line">return node;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>从文件中加载图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function ReadGraph()</span><br><span class="line">local graph = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for line in io.lines() do</span><br><span class="line">--把一行分割为两个名字</span><br><span class="line">local nameform,nameto = string.match(line,&quot;(%S+)%s+(%S+)&quot;);</span><br><span class="line">--找到对应节点</span><br><span class="line">local from = name2node(graph,nameform);</span><br><span class="line">local to = name2node(graph,nameto);</span><br><span class="line">--把&#x27;to&#x27;增加到邻接集合&#x27;from&#x27;中</span><br><span class="line">from.adj[to] = true;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return graph;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>寻找两个节点之间的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function findpath(curr,to,path,visited)</span><br><span class="line">path = path or &#123;&#125;;</span><br><span class="line">visited = visited or &#123;&#125;;</span><br><span class="line"></span><br><span class="line">if visited[curr] then--是否节点已被访问</span><br><span class="line">return nil;</span><br><span class="line">end</span><br><span class="line">visited[curr] = true;--标记节点为已被访问</span><br><span class="line">path[#path+1] = curr;</span><br><span class="line">if curr == to then</span><br><span class="line">return path;</span><br><span class="line">end</span><br><span class="line">--尝试所有的邻接节点</span><br><span class="line">for node in pairs(curr.adj) do</span><br><span class="line">local p = findpath(node,to,path,visited);</span><br><span class="line"></span><br><span class="line">if p then</span><br><span class="line">return p;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">table.remove(path);--从路径中删除节点</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>函数findpath使用深度优先遍历搜索两个节点之间的路径。<br>该函数的第1个参数是当前节点，第2个参数是目标节点，第3个参数用于保存从起点到当前节点的路径，最后一个参数为所有已被访问节点的集合（用于避免回路）。</p><h1 id="Chapter15-数据文件和序列化"><a href="#Chapter15-数据文件和序列化" class="headerlink" title="Chapter15 数据文件和序列化"></a>Chapter15 数据文件和序列化</h1><h2 id="15-2-序列化"><a href="#15-2-序列化" class="headerlink" title="15.2 序列化"></a>15.2 序列化</h2><p>我们可以使用一种安全的方法来括住一个字符串，那就是使用函数string.format的”%q”选项。<br>该选项被设计为以一种能够让Lua语言安全地反序列化字符串的方式来序列化字符串，它使用双引号括住字符串并正确地转义其中的双引号和换行符等其他字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local a = &#x27;a &quot;problematic&quot; \\string&#x27;;</span><br><span class="line">print(string.format(&quot;%q&quot;,a));--&gt; &quot;a \&quot;problematic\&quot; \\string&quot;</span><br></pre></td></tr></table></figure><p>Lua 5.3.3对格式选项”%q”进行了扩展，使其也可以用于数值、nil和Boolean类型，进而使它们能够正确地被序列化和反序列化。（特别地，这个格式选项以十六进制格式处理浮点类型以保留完整的精度。）</p><h1 id="Chapter16-编译、执行和错误"><a href="#Chapter16-编译、执行和错误" class="headerlink" title="Chapter16 编译、执行和错误"></a>Chapter16 编译、执行和错误</h1><p>虽然我们把Lua语言称为解释型语言（interpreted language），但Lua语言总是在运行代码前先预编译（precompile）源码为中间代码（这没什么大不了的，很多解释型语言也这样做）。<br>编译（compilation）阶段的存在听上去超出了解释型语言的范畴，但解释型语言的区分并不在于源码是否被编译，而在于是否有能力（且轻易地）执行动态生成的代码。<br>可以认为，正是由于诸如dofile这样函数的存在，才使得Lua语言能够被称为解释型语言。</p><h2 id="16-1-编译"><a href="#16-1-编译" class="headerlink" title="16.1 编译"></a>16.1 编译</h2><p>此前，我们已经介绍过函数dofile，它是运行Lua代码段的主要方式之一。<br>实际上，函数dofile是一个辅助函数，函数loadfile才完成了真正的核心工作。<br>与函数dofile类似，函数loadfile也是从文件中加载Lua代码段，但它不会运行代码，而只是编译代码，然后将编译后的代码段作为一个函数返回。<br>此外，与函数dofile不同，函数loadfile只返回错误码而不抛出异常。<br>可以认为，函数dofile就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function dofile(filename)</span><br><span class="line">local f = assert(loadfile(filename));</span><br><span class="line">return f();</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>对于简单的需求而言，由于函数dofile在一次调用中就做完了所有工作，所以该函数非常易用。不过，函数loadfile更灵活。<br>在发生错误的情况中，函数loadfile会返回nil及错误信息，以允许我们按自定义的方式来处理错误。<br>此外，如果需要多次运行同一个文件，那么只需调用一次loadfile函数后再多次调用它的返回结果即可。<br>由于只编译一次文件，因此这种方式的开销要比多次调用函数dofile小得多（编译在某种程度上相比其他操作开销更大）。</p><p>通常，用函数load来加载字符串常量是没有意义的。<br>例如，如下的两行代码基本等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = load(&quot;i = i + 1&quot;);</span><br><span class="line">f = function ()</span><br><span class="line">i = i + 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>但是，由于第2行代码会与其外层的函数一起被编译，所以其执行速度要快得多。与之对比，第一段代码在调用函数load时会进行一次独立的编译。</p><p>由于函数load在编译时不涉及词法定界，所以上述示例的两段代码可能并不完全等价。<br>为了清晰地展示它们之间的区别，让我们稍微修改一下上面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = 32;</span><br><span class="line">local i = 0;</span><br><span class="line">f = load(&quot;i = i + 1;print(i)&quot;);</span><br><span class="line">g = function ()</span><br><span class="line">i = i + 1;</span><br><span class="line">print(i);</span><br><span class="line">end</span><br><span class="line">f()--&gt; 33</span><br><span class="line">g()--&gt; 1</span><br></pre></td></tr></table></figure><p>函数g像我们所预期地那样操作局部变量i，但函数f操作的却是全局变量i，这是由于函数load总是在全局环境中编译代码段。</p><p>我们也可以使用读取函数（reader function）作为函数load的第1个参数。<br>读取函数可以分几次返回一段程序，函数load会不断地调用读取函数直到读取函数返回nil（表示程序段结束）。<br>作为示例，以下的调用与函数loadfile等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = load(io.lines(filename,&quot;*L&quot;));</span><br></pre></td></tr></table></figure><p>函数load和函数loadfile从来不引发错误。当有错误发生时，它们会返回nil及错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(load(&quot;i i&quot;));</span><br><span class="line">--&gt; nil [string &quot;i i&quot;]:1: &#x27;=&#x27; expected near &#x27;i&#x27;</span><br></pre></td></tr></table></figure><p>此外，这些函数没有任何副作用，它们既不改变或创建变量，也不向文件写入等。<br>这些函数只是将程序段编译为一种中间形式，然后将结果作为匿名函数返回。<br>一种常见的误解是认为加载一段程序也就是定义了函数，但实际上在Lua语言中函数定义是在运行时而不是在编译时发生的一种赋值操作。<br>例如，假设有一个文件foo.lua：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)</span><br><span class="line">print(x);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = loadfile(&quot;foo.lua&quot;);</span><br></pre></td></tr></table></figure><p>时，编译foo的命令并没有定义foo，只有运行代码才会定义它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = loadfile(&quot;foo.lua&quot;);</span><br><span class="line">print(foo);--&gt; nil</span><br><span class="line">f();-- 运行代码</span><br><span class="line">foo(&quot;ok&quot;)--&gt; ok</span><br></pre></td></tr></table></figure><h2 id="16-2-预编译的代码"><a href="#16-2-预编译的代码" class="headerlink" title="16.2 预编译的代码"></a>16.2 预编译的代码</h2><h2 id="16-3-错误"><a href="#16-3-错误" class="headerlink" title="16.3 错误"></a>16.3 错误</h2><h2 id="16-4-错误处理和异常"><a href="#16-4-错误处理和异常" class="headerlink" title="16.4 错误处理和异常"></a>16.4 错误处理和异常</h2><p>假设要执行一段Lua代码并捕获（try-catch）执行中发生的所有错误，那么首先需要将这段代码封装到一个函数中，这个函数通常是一个匿名函数。<br>之后，通过pcall来调用这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local ok,msg = pcall(function ()</span><br><span class="line">some code</span><br><span class="line">if unexpected_condition then</span><br><span class="line">error();</span><br><span class="line">end</span><br><span class="line">some code</span><br><span class="line">print(a[i]);-- 潜在错误：&#x27;a&#x27;可能不是一个表</span><br><span class="line">some code</span><br><span class="line">end)</span><br><span class="line"></span><br><span class="line">if ok then-- 执行被保护的代码时没有错误发生</span><br><span class="line">regular code</span><br><span class="line">else-- 执行被保护的代码时有错误发生：进行恰当的处理</span><br><span class="line">error-handling code</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>函数pcall会以一种保护模式（protected mode）来调用它的第1个参数，以便捕获该函数执行中的错误。无论是否有错误发生，函数pcall都不会引发错误。<br>如果没有错误发生，那么pcall返回true及被调用函数（作为pcall的第1个参数传入）的所有返回值；<br>否则，则返回false及错误信息。</p><h2 id="16-5-错误信息和栈回溯"><a href="#16-5-错误信息和栈回溯" class="headerlink" title="16.5 错误信息和栈回溯"></a>16.5 错误信息和栈回溯</h2><p>通常，除了发生错误的位置以外，我们还希望在错误发生时得到更多的调试信息。至少，我们希望得到具有发生错误时完整函数调用栈的栈回溯（traceback）。<br>当函数pcall返回错误信息时，部分的调用栈已经被破坏了（从pcall到出错之处的部分）。<br>因此，如果希望得到一个有意义的栈回溯，那么就必须在函数pcall返回前先将调用栈构造好。<br>为了完成这个需求，Lua语言提供了函数xpcall。该函数与函数pcall类似，但它的第2个参数是一个消息处理函数（message handler function）。<br>当发生错误时，Lua会在调用栈展开（stack unwind）前调用这个消息处理函数，以便消息处理函数能够使用调试库来获取有关错误的更多信息。<br>两个常用的消息处理函数是debug.debug和debug.traceback，前者为用户提供一个Lua提示符来让用户检查错误发生的原因；<br>后者则使用调用栈来构造详细的错误信息，Lua语言的独立解释器就是使用这个函数来构造错误信息的。</p><h1 id="Chapter17-模块和包"><a href="#Chapter17-模块和包" class="headerlink" title="Chapter17 模块和包"></a>Chapter17 模块和包</h1><p>从用户观点来看，一个模块（module）就是一些代码（要么是Lua语言编写的，要么是C语言编写的），这些代码可以通过函数require加载，然后创建和返回一个表。<br>这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。</p><p>使用表来实现模块的显著优点之一是，让我们可以像操作普通表那样操作模块，并且能利用Lua语言的所有功能实现额外的功能。<br>在大多数语言中，模块不是第一类值（即它们不能被保存在变量中，也不能被当作参数传递给函数等），所以那些语言需要为模块实现一套专门的机制。<br>而在Lua语言中，我们则可以轻易地实现这些功能。</p><h2 id="17-1-函数require"><a href="#17-1-函数require" class="headerlink" title="17.1 函数require"></a>17.1 函数require</h2><ul><li>函数require尝试对模块的定义做最小的假设。</li></ul><p>对于该函数来说，一个模块可以是定义了一些变量（比如函数或者包含函数的表）的代码。<br>典型地，这些代码返回一个由模块中函数组成的表。<br>不过，由于这个动作是由模块的代码而不是由函数require完成的，所以某些模块可能会选择返回其他的值或者甚至引发副作用（例如，通过创建全局变量）。</p><ul><li>首先，函数require在表package.loaded中检査模块是否已被加载。</li></ul><p>如果模块已经被加载，函数require就返回相应的值。<br>因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。</p><ul><li>如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定，我们会在后续对其进行讨论）。</li></ul><p>如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器（loader）的函数（加载器就是一个被调用时加载模块的函数）。</p><p>如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。（在这种情况下，搜索路径由变量package.cpath指定。）<br>如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。<br>在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数luaopen_modname。</p><p>不管模块是在Lua文件还是C标准库中找到的，函数require此时都具有了用于加载它的加载函数。<br>为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在文件的名称（大多数模块会忽略这两个参数）。<br>如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载同一模块时返回相同的值。<br>如果加载函数没有返回值且表中的package.loaded[@rep{modname}]为空，函数require就假设模块的返回值是true。<br>如果没有这种补偿，那么后续调用函数require时将会重复加载模块。</p><h3 id="17-1-1-模块重命名"><a href="#17-1-1-模块重命名" class="headerlink" title="17.1.1 模块重命名"></a>17.1.1 模块重命名</h3><p>为了进行这种重命名，函数require运用了一个连字符的技巧：如果一个模块名中包含连字符，那么函数require就会用连字符之前的内容来创建luaopen_*函数的名称。<br>例如，如果一个模块的名称为mod-v3.4，那么函数require会认为该模块的加载函数应该是luaopen_mod而不是luaopen_mod-v3.4（这也不是有效的C语言函数名）。<br>因此，如果需要使用两个名称均为mod的模块（或相同模块的两个不同版本），那么可以对其中的一个进行重命名，如mod-v1。<br>当调用m1=require”mod-v1”时，函数require会找到改名后的文件mod-v1并将其中原名为luaopen_mod的函数作为加载函数。</p><h3 id="17-1-2-搜索路径"><a href="#17-1-2-搜索路径" class="headerlink" title="17.1.2 搜索路径"></a>17.1.2 搜索路径</h3><p>在搜索一个Lua文件时，函数require使用的路径与典型的路径略有不同。典型的路径是很多目录组成的列表，并在其中搜索指定的文件。<br>不过，ISO C（Lua语言依赖的抽象平台）并没有目录的概念。<br>所以，函数require使用的路径是一组模板（template），其中的每项都指定了将模块名（函数require的参数）转换为文件名的方式。<br>更准确地说，这种路径中的每一个模板都是一个包含可选问号的文件名。<br>对于每个模板，函数require会用模块名来替换每一个问号，然后检查结果是否存在对应的文件；如果不存在，则尝试下一个模板。<br>路径中的模板以在大多数操作系统中很少被用于文件名的分号隔开。</p><p>例如，考虑如下路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?;?.lua;c:\windows\?;/usr/local/lua/?/?.lua</span><br></pre></td></tr></table></figure><p>在使用这个路径时，调用require”sql”将尝试打开如下的Lua文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">sql.lua</span><br><span class="line">c:\windows\sql</span><br><span class="line">/usr/local/lua/sql/sql.lua</span><br></pre></td></tr></table></figure><p>函数require只处理分号（作为分隔符）和问号，所有其他的部分（包括目录分隔符和文件扩展名）则由路径自己定义。</p><p>函数require用于搜索Lua文件的路径是变量package.path的当前值。</p><p>搜索C标准库的路径的逻辑与此相同，只不过C标准库的路径来自变量package.cpath而不是package.path。</p><p>函数package.searchpath中实现了搜索库的所有规则，该函数的参数包括模块名和路径，然后遵循上述规则来搜索文件。<br>函数package.searchpath要么返回第一个存在的文件的文件名，要么返回nil外加描述所有文件都无法成功打开的错误信息。</p><h3 id="17-1-3-搜索器"><a href="#17-1-3-搜索器" class="headerlink" title="17.1.3 搜索器"></a>17.1.3 搜索器</h3><p>数组package.searchers列出了函数require使用的所有搜索器。<br>在寻找模块时，函数require传入模块名并调用列表中的每一个搜索器直到它们其中的一个找到了指定模块的加载器。<br>如果所有搜索器都被调用完后还找不到，那么函数require就抛出一个异常。</p><p>预加载（preload）搜索器使得我们能够为要加载的模块定义任意的加载函数。<br>预加载搜索器使用一个名为package.preload的表来映射模块名称和加载函数。<br>当搜索指定的模块名时，该搜索器只是简单地在表中搜索指定的名称。如果它找到了对应的函数，那么就将该函数作为相应模块的加载函数返回；否则，则返回nil。<br>预加载搜索器为处理非标场景提供了一种通用的方式。<br>例如，一个静态链接到Lua中的C标准库可以将其luaopen_函数注册到表preload中，这样luaopen_函数只有当用户加载这个模块时才会被调用。<br>用这种方式，程序不会为没有用到的模块浪费资源。</p><h2 id="17-2-Lua语言中编写模块的基本方法"><a href="#17-2-Lua语言中编写模块的基本方法" class="headerlink" title="17.2 Lua语言中编写模块的基本方法"></a>17.2 Lua语言中编写模块的基本方法</h2><h2 id="17-3-子模块和包"><a href="#17-3-子模块和包" class="headerlink" title="17.3 子模块和包"></a>17.3 子模块和包</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter9-闭包&quot;&gt;&lt;a href=&quot;#Chapter9-闭包&quot; class=&quot;headerlink&quot; title=&quot;Chapter9 闭包&quot;&gt;&lt;/a&gt;Chapter9 闭包&lt;/h1&gt;&lt;p&gt;在Lua语言中，函数是严格遵循词法定界（lexicalscoping</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《Lua程序设计》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
    <category term="编程实操" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%93%8D/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>Lua程序设计（Lua语言入门1-8）</title>
    <link href="https://afoolzwt.github.io/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/"/>
    <id>https://afoolzwt.github.io/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/</id>
    <published>2022-10-30T16:00:00.000Z</published>
    <updated>2022-11-02T12:47:30.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-Lua语言入门"><a href="#Chapter1-Lua语言入门" class="headerlink" title="Chapter1        Lua语言入门"></a>Chapter1        Lua语言入门</h1><h2 id="1-3-全局变量"><a href="#1-3-全局变量" class="headerlink" title="1.3 全局变量"></a>1.3 全局变量</h2><p>在Lua语言中，全局变量（Global Variable）无须声明即可使用，使用未经初始化的全局变量也不会导致错误。<br>当使用未经初始化的全局变量时，得到的结果是nil：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; b<span class="comment">--&gt; nil</span></span><br><span class="line">&gt; b = <span class="number">10</span></span><br><span class="line">&gt; b<span class="comment">--&gt; 10</span></span><br></pre></td></tr></table></figure><p>当把nil赋值给全局变量时，Lua会回收该全局变量（就像该全局变量从来没有出现过一样），例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; b = <span class="literal">nil</span> </span><br><span class="line">&gt; b<span class="comment">--&gt; nil</span></span><br><span class="line">```   </span><br><span class="line">Lua语言不区分未初始化变量和被赋值为<span class="literal">nil</span>的变量。</span><br><span class="line">在上述赋值语句执行后，Lua语言会最终回收该变量占用的内存。</span><br><span class="line">## <span class="number">1.4</span>　类型和值</span><br><span class="line">Lua语言是一种动态类型语言（Dynamically-typed language），在这种语言中没有类型定义（<span class="built_in">type</span> definition），每个值都带有其自身的类型信息。</span><br><span class="line">Lua语言中有<span class="number">8</span>种基本类型：<span class="literal">nil</span>（空）、boolean（布尔）、number（数值）、<span class="built_in">string</span>（字符串）、userdata（用户数据）、<span class="function"><span class="keyword">function</span>（函数）、<span class="title">thread</span>（线程）、<span class="title">table</span>（表）。</span></span><br><span class="line"><span class="function">使用函数<span class="title">type</span>可获取一个值对应的类型名称：</span></span><br><span class="line"><span class="function">```<span class="title">Lua</span></span></span><br><span class="line"><span class="function">&gt; <span class="title">type</span><span class="params">(nil)</span></span><span class="comment">--&gt; nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="literal">true</span>)<span class="comment">--&gt; boolean</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="number">10.4</span> * <span class="number">3</span>)<span class="comment">--&gt; number</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="string">&quot;Hello world&quot;</span>)<span class="comment">--&gt; string</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>)<span class="comment">--&gt; userdata</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="built_in">print</span>)<span class="comment">--&gt; function</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="built_in">type</span>)<span class="comment">--&gt; thread</span></span><br><span class="line">&gt; <span class="built_in">type</span>(&#123;&#125;)<span class="comment">--&gt; table</span></span><br><span class="line">&gt; <span class="built_in">type</span>(<span class="built_in">type</span>(X))<span class="comment">--&gt; string</span></span><br></pre></td></tr></table></figure><p>不管X是什么，最后一行返回的永远是”string”。<br>这是因为函数type的返回值永远是一个字符串。</p><p>userdata类型允许把任意的C语言数据保存在Lua语言变量中。<br>在Lua语言中，用户数据类型除了赋值和相等性测试外，没有其他预定义的操作。<br>用户数据被用来表示由应用或C语言编写的库所创建的新类型。<br>例如，标准I/O库使用用户数据来表示打开的文件。<br>我们会在后面涉及CAPI时再讨论更多的相关内容。</p><p>变量没有预定义的类型，任何变量都可以包含任何类型的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(a)<span class="comment">--&gt; nil</span></span><br><span class="line">&gt; a = <span class="number">10</span></span><br><span class="line">&gt; <span class="built_in">type</span>(a)<span class="comment">--&gt; number</span></span><br><span class="line">&gt; a = <span class="string">&quot;a string!!&quot;</span></span><br><span class="line">&gt; <span class="built_in">type</span>(a)<span class="comment">--&gt; string</span></span><br><span class="line">&gt; a = <span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(a)<span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><p> 一般情况下，将一个变量用作不同类型时会导致代码的可读性不佳；但是，在某些情况下谨慎地使用这个特性可能会带来一定程度的便利。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Lua语言中，条件测试（例如控制结构中的分支语句）将除Boolean值false和nil外的所有其他值视为真。特别的是，在条件检测中Lua语言把零和空字符串也都视为真。</p><p>Lua语言支持常见的逻辑运算符：and 、or 和 not。和条件测试一样，所有的逻辑运算将Boolean类型的 false 和 nil 当做假，而把其他值当作真。</p><p>逻辑运算符 and 的运算结果为：如果它的第一个操作数为“false”，则返回第一个操作数，否则返回第二个操作数。<br>逻辑运算符 or 的运算结果为：如果它的第一个操作数不为“false”，则返回第一个操作数，否则返回第二个操作数。<br>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span><span class="comment">--&gt; 5</span></span><br><span class="line">&gt; <span class="literal">nil</span> <span class="keyword">and</span> <span class="number">13</span><span class="comment">--&gt; nil</span></span><br><span class="line">&gt; <span class="literal">false</span> <span class="keyword">and</span> <span class="number">13</span><span class="comment">--&gt; false</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="keyword">or</span> <span class="number">5</span><span class="comment">--&gt; 0</span></span><br><span class="line">&gt; <span class="literal">false</span> <span class="keyword">or</span> <span class="string">&quot;hi&quot;</span><span class="comment">--&gt; &quot;hi&quot;</span></span><br><span class="line">&gt; <span class="literal">nil</span> <span class="keyword">or</span> <span class="literal">false</span> <span class="comment">--&gt; false</span></span><br><span class="line">```   </span><br><span class="line"><span class="keyword">and</span> 和 <span class="keyword">or</span> 都遵循短路求值（Short-circuit evaluation）原则，即只在必要时才对第二个操作数进行求值。</span><br><span class="line">例如，根据短路求值的原则，表达式（i～=<span class="number">0</span> <span class="keyword">and</span> a/i&gt;b）不会发生运行时异常（当i等于<span class="number">0</span>时，a/i不会执行）。</span><br><span class="line"></span><br><span class="line">在Lua语言中，形如x=x <span class="keyword">or</span> v的惯用写法非常有用，它等价于：</span><br><span class="line">```Lua</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span></span><br><span class="line">x = v;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>即，当x未被初始化时，将其默认值设为v（假设x不是Boolean类型的false。）</p><p>另一种有用的表达式形如（（a and b）or c）或（a and b or c）（由于 and 的运算符优先级高于 or，所以这两种表达形式等价，后面会详细介绍），当b不为false时，它们还等价于C语言的三目运算符a？b:c。<br>例如，我们可以使用表达式（x&gt;y）and x or y选出数值x和y中较大的一个。当x&gt;y时，and 的第一个操作数为true，与第二个操作数（x）进行 and 运算后结果为x，最终与 or 运算后返回第一个操作数x。当x&gt;y不成立时，and 表达式的值为false，最终 or 运算后的结果是第二个操作数y。</p><p>not 运算符永远返回Boolean类型的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">not</span> <span class="literal">nil</span><span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="keyword">not</span> <span class="literal">false</span><span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="keyword">not</span> <span class="number">0</span><span class="comment">--&gt; false</span></span><br><span class="line">&gt; <span class="keyword">not</span> <span class="keyword">not</span> <span class="number">1</span><span class="comment">--&gt; true</span></span><br><span class="line">&gt; <span class="keyword">not</span> <span class="keyword">not</span> <span class="literal">nil</span><span class="comment">--&gt; false</span></span><br></pre></td></tr></table></figure><h1 id="Chapter2-小插曲：八皇后问题"><a href="#Chapter2-小插曲：八皇后问题" class="headerlink" title="Chapter2        小插曲：八皇后问题"></a>Chapter2        小插曲：八皇后问题</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">8</span>;--棋盘大小</span><br><span class="line"></span><br><span class="line">--检查(n,c)是否不会被攻击</span><br><span class="line"><span class="function">function <span class="title">IsPlaceOk</span><span class="params">(a,n,c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i </span>= <span class="number">1</span>,n - <span class="number">1</span> <span class="keyword">do</span>--对于每一个已经被放置的皇后</span><br><span class="line"><span class="keyword">if</span> a[i] <span class="function">then</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(a[i] == c)</span><span class="keyword">or</span>--同一列？</span></span><br><span class="line"><span class="function"><span class="params">(a[i] - i == c - n)</span> <span class="keyword">or</span>--同一对角线？</span></span><br><span class="line"><span class="function"><span class="params">(a[i] + i == c + n)</span> then</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="literal">false</span> --位置会被攻击</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="literal">true</span> --不会被攻击；位置有效</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--打印棋盘</span></span><br><span class="line"><span class="function">function <span class="title">PrintSolution</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">for</span>i </span>= <span class="number">1</span>,N <span class="keyword">do</span> --对于每一行</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span>,N <span class="keyword">do</span> --和每一列</span><br><span class="line">--输出“X”或“-”，外加一个空格</span><br><span class="line">io.write(a[i] == j <span class="keyword">and</span> <span class="string">&quot;X&quot;</span> <span class="keyword">or</span> <span class="string">&quot;-&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">end</span><br><span class="line">io.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">end</span><br><span class="line">io.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--把从“n”到“N”的所有皇后放在棋盘“a”上</span><br><span class="line"><span class="function">function <span class="title">AddQueen</span><span class="params">(a,n)</span></span></span><br><span class="line"><span class="function"><span class="keyword">if</span> n &gt; N then--是否所有的皇后都被放置好了</span></span><br><span class="line"><span class="function"><span class="title">PrintSolution</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="keyword">else</span>--尝试着放置第n个皇后</span><br><span class="line"><span class="keyword">for</span> c = <span class="number">1</span>,N <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> IsPlaceOk(a,n,c) then</span><br><span class="line">a[n] = c --把第n个皇后放在列“c”</span><br><span class="line">AddQueen(a,n+<span class="number">1</span>);</span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">AddQueen</span><span class="params">(&#123;&#125;,<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="Chapter3-数值"><a href="#Chapter3-数值" class="headerlink" title="Chapter3        数值"></a>Chapter3        数值</h1><h2 id="3-1数值常量"><a href="#3-1数值常量" class="headerlink" title="3.1数值常量"></a>3.1数值常量</h2><p>具有十进制小数或者指数的数值会被当作浮点型值，否则会被当作整型值。<br>整型值和浮点型值的类型都是”number”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; type(<span class="number">3</span>)--&gt; number</span><br><span class="line">&gt; type(<span class="number">3.5</span>)--&gt; number</span><br><span class="line">&gt; type(<span class="number">3.0</span>)--&gt; number</span><br><span class="line">```   </span><br><span class="line">由于整型值和浮点型值的类型都是<span class="string">&quot;number&quot;</span>，所以它们是可以相互转换的。</span><br><span class="line">同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的：</span><br><span class="line">```c</span><br><span class="line">&gt; <span class="number">1</span> == <span class="number">1.0</span>--&gt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="number">-3</span> == <span class="number">-3.0</span> --&gt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="number">0.2e3</span> == <span class="number">200</span> --&gt; <span class="literal">true</span></span><br><span class="line">```   </span><br><span class="line">在少数情况下，当需要区分整型值和浮点型值时，可以使用函数math.type：</span><br><span class="line">```c</span><br><span class="line">&gt; math.type(<span class="number">3</span>)--&gt; integer</span><br><span class="line">&gt; math.type(<span class="number">3.0</span>) --&gt; <span class="keyword">float</span></span><br></pre></td></tr></table></figure><h2 id="3-2算术运算"><a href="#3-2算术运算" class="headerlink" title="3.2算术运算"></a>3.2算术运算</h2><p>对于Lua 5.3中引入的整型而言，主要的建议就是“开发人员要么选择忽略整型和浮点型二者之间的不同，要么就完整地控制每一个数值的表示。”<br>因此，所有的算术操作符不论操作整型值还是浮点型值，结果都应该是一样的。</p><p>两个整型值进行相加、相减、相乘、相除和取负操作的结果仍然是整型值。<br>对于这些算术运算而言，操作数是用整型还是用浮点型表示的整数都没有区别（除非发生溢出，参见3.5节）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">13</span> + <span class="number">15</span>--&gt; <span class="number">28</span></span><br><span class="line">&gt; <span class="number">13.0</span> + <span class="number">15.0</span>--&gt; <span class="number">28.0</span></span><br></pre></td></tr></table></figure><p>如果两个操作数都是整型值，那么结果也是整型值；否则，结果就是浮点型值。<br>当操作数一个是整型值一个是浮点型值时，Lua语言会在进行算术运算前先将整型值转换为浮点型值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">13.0</span> + <span class="number">25</span>--&gt; <span class="number">38.0</span></span><br><span class="line">&gt; -(<span class="number">3</span> * <span class="number">6.0</span>)--&gt; <span class="number">-18.0</span></span><br></pre></td></tr></table></figure><p>由于两个整数相除的结果并不一定是整数（数学领域称为不能整除），因此除法不遵循上述规则。<br>为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作的永远是浮点数且产生浮点型值的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3.0</span> / <span class="number">2.0</span>--&gt; <span class="number">1.5</span></span><br><span class="line">&gt; <span class="number">3</span> / <span class="number">2</span>--&gt; <span class="number">1.5</span></span><br></pre></td></tr></table></figure><p> Lua 5.3针对整数除法引入了一个称为floor除法的新算术运算符//。<br>顾名思义，floor除法会对得到的商向负无穷取整，从而保证结果是一个整数。<br>这样，floor除法就可以与其他算术运算一样遵循同样的规则：如果操作数都是整型值，那么结果就是整型值，否则就是浮点型值（其值是一个整数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> // <span class="number">2</span>--&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">3.0</span> // <span class="number">2</span>--&gt; <span class="number">1.0</span></span><br><span class="line">&gt; <span class="number">6</span> // <span class="number">2</span>--&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">6.0</span> // <span class="number">2.0</span>--&gt; <span class="number">3.0</span></span><br><span class="line">&gt; -<span class="number">9</span> // <span class="number">2</span>--&gt; -<span class="number">5</span></span><br><span class="line">&gt; <span class="number">1.5</span> // <span class="number">0.5</span>--&gt; <span class="number">3.0</span></span><br><span class="line">```   </span><br><span class="line"><span class="comment">## 3.7运算符优先级</span></span><br><span class="line">Lua语言中的运算符优先级如下（优先级从高到低）：</span><br></pre></td></tr></table></figure><p>^</p><ul><li><h1 id="not-（一元运算符）"><a href="#not-（一元运算符）" class="headerlink" title="- not    （一元运算符）"></a>- not    （一元运算符）</h1></li></ul><ul><li>/ // %</li></ul><ul><li>-<br>..            (连接)<br>&lt;&lt; &gt;&gt;        (按位移位)<br>&amp;            (按位与)<br>~            (按位异或)<br>|            (按位或)<br>&lt; &gt; &lt;= &gt;= ~= ==<br>and<br>or<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在二元运算符中，除了幂运算和连接操作符是右结合的外，其他运算符都是左结合的。因此，以下各个表达式的左右两边等价：</span><br></pre></td></tr></table></figure>a+i&lt;b/2+1        &lt;–&gt;        (a + i) &lt; ((b / 2) + 1)<br>5+x^2*8            &lt;–&gt;        5 + ((x^2) * 8)<br>a&lt;y and y&lt;=z    &lt;–&gt;          (a &lt; y) and (y &lt;= z)</li></ul><p>-x^2            &lt;–&gt;        -(x^2)<br>x^y^z            &lt;–&gt;        x^(y^z)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 当不能确定某些表达式的运算符优先级时，应该显式地用括号来指定所希望的运算次序。</span><br><span class="line"># Chapter4字符串</span><br><span class="line">Lua语言中的字符串是一串字节组成的序列，Lua核心并不关心这些字节究竟以何种方式编码文本。在Lua语言中，字符使用8个比特位来存储（eight-bit clean）。</span><br><span class="line">Lua语言中的字符串可以存储包括空字符在内的所有数值代码，这意味着我们可以在字符串中存储任意的二进制数据。</span><br><span class="line"></span><br><span class="line">Lua语言中的字符串是不可变值（immutable value）。</span><br><span class="line">我们不能像在C语言中那样直接改变某个字符串中的某个字符，但是我们可以通过创建一个新字符串的方式来达到修改的目的，例如：</span><br><span class="line">```c</span><br><span class="line">a = &quot;one string&quot;</span><br><span class="line">b = string.gsub(a,&quot;one&quot;,&quot;another&quot;) --改变字符串中的某些部分</span><br><span class="line">print(a)--&gt; one string</span><br><span class="line">print(b)--&gt; another string</span><br></pre></td></tr></table></figure><p>像Lua语言中的其他对象（表、函数等）一样，Lua语言中的字符串也是自动内存管理的对象之一。<br>这意味着Lua语言会负责字符串的分配和释放，开发人员无须关注。</p><p>可以使用长度操作符（length operator）（#）获取字符串的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">print(<span class="meta">#a)--&gt; 5</span></span><br><span class="line">print(#<span class="string">&quot;good bye&quot;</span>)--&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>该操作符返回字符串占用的字节数，在某些编码中，这个值可能与字符串中字符的个数不同。</p><p>应该注意，在Lua语言中，字符串是不可变量。字符串连接总是创建一个新字符串，而不会改变原来作为操作数的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &quot;Hello&quot;</span><br><span class="line">&gt; a .. &quot;World&quot;--&gt; Hello World</span><br><span class="line">&gt; a--&gt; Hello</span><br></pre></td></tr></table></figure><h2 id="4-1字符串常量"><a href="#4-1字符串常量" class="headerlink" title="4.1字符串常量"></a>4.1字符串常量</h2><p>我们可以使用一对双引号或单引号来声明字符串常量（literal string）。<br>使用双引号和单引号声明字符串是等价的。<br>它们两者唯一的区别在于，使用双引号声明的字符串中出现单引号时，单引号可以不用转义；使用单引号声明的字符串中出现双引号时，双引号可以不用转义。</p><h2 id="4-2长字符串-多行字符串"><a href="#4-2长字符串-多行字符串" class="headerlink" title="4.2长字符串/多行字符串"></a>4.2长字符串/多行字符串</h2><p>有时字符串中可能有类似a=b[c[i]]这样的内容（注意其中的]]），或者，字符串中可能有被注释掉的代码。<br>为了应对这些情况，可以在两个左方括号之间加上任意数量的等号，如[===[。这样，字符串常量只有在遇到了包含相同数量等号的两个右方括号时才会结束（就前例而言，即]===]）。<br>Lua语言的语法扫描器会忽略所含等号数量不相同的方括号。通过选择恰当数量的等号，就可以在无须修改原字符串的情况下声明任意的字符串常量了。</p><p>对注释而言，这种机制也同样有效。例如，我们可以使用–[=[和]=]来进行长注释，从而降低了对内部已经包含注释的代码进行注释的难度。</p><h2 id="4-3强制类型转换"><a href="#4-3强制类型转换" class="headerlink" title="4.3强制类型转换"></a>4.3强制类型转换</h2><p>Lua语言在运行时提供了数值与字符串之间的自动转换（conversion）。针对字符串的所有算术操作会尝试将字符串转换为数值。<br>Lua语言不仅仅在算术操作时进行这种强制类型转换（coercion），还会在任何需要数值的情况下进行，例如函数math.sin的参数。</p><p>相反，当Lua语言发现在需要字符串的地方出现了数值时，它就会把数值转换为字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(10 .. 20)--&gt;1020</span><br></pre></td></tr></table></figure><p>很多人认为自动强制类型转换算不上是Lua语言中的一项好设计。作为原则之一，建议最好不要完全寄希望于自动强制类型转换。虽然在某些场景下这种机制很便利，但同时也给语言和使用这种机制的程序带来了复杂性。</p><p>作为这种“二类状态（second-class status）”的表现之一，Lua 5.3没有实现强制类型转换与整型的集成，而是采用了另一种更简单和快速的实现方式：算术运算的规则就是只有在两个操作数都是整型值时结果才是整型。<br>因此，由于字符串不是整型值，所以任何有字符串参与的算术运算都会被当作浮点运算处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&quot;10&quot; + 1--&gt;11.0</span><br></pre></td></tr></table></figure><p>如果需要显式地将一个字符串转换成数值，那么可以使用函数tonumber。<br>当这个字符串的内容不能表示为有效数字时该函数返回nil；否则，该函数就按照Lua语法扫描器的规则返回对应的整型值或浮点类型值。</p><p>与算术操作不同，比较操作符不会对操作数进行强制类型转换。请注意，”0”和0是不同的。<br>此外，2&lt;15明显为真，但”2”&lt;”15”却为假（字母顺序）。<br>为了避免出现不一致的结果，当比较操作符中混用了字符串和数值（比如2&lt;”15”）时，Lua语言会抛出异常。</p><h2 id="4-4字符串标准库"><a href="#4-4字符串标准库" class="headerlink" title="4.4字符串标准库"></a>4.4字符串标准库</h2><p>字符串标准库中的一些函数非常简单：<br>    函数string.len（s）返回字符串s的长度，等价于#s。<br>    函数string.rep（s,n）返回将字符串s重复n次的结果。可以通过调用string.rep（”a”,2^20）创建一个1MB大小的字符串（例如用于测试）。<br>    函数string.reverse用于字符串翻转。<br>    函数string.lower（s）返回一份s的副本，其中所有的大写字母都被转换成小写字母，而其他字符则保持不变。<br>    函数string.upper与之相反，该函数会将小写字母转换成大写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; string.rep(&quot;abc&quot;,3)--&gt; abcabcabc</span><br><span class="line">&gt; string.reverse(&quot;A Long Line!&quot;)--&gt; !eniL gnoL A</span><br><span class="line">&gt; string.lower(&quot;A Long Line!&quot;)--&gt; a long line!</span><br><span class="line">&gt; string.upper(&quot;A Long Line!&quot;)--&gt; A LONG LINE!</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">函数string.sub（s,i,j）从字符串s中提取第i个到第j个字符（包括第i个和第j个字符，字符串的第一个字符索引为1）。</span><br><span class="line">该函数也支持负数索引，负数索引从字符串的结尾开始计数：索引-1代表字符串的最后一个字符，索引-2代表倒数第二个字符，依此类推。</span><br><span class="line">这样，对字符串s调用函数string.sub（s,1,j）得到的是字符串s中长度为j的前缀，调用string.sub（s,j,-1）得到的是字符串s中从第j个字符开始的后缀，调用string.sub（s,2,-2）返回的是去掉字符串s中第一个和最后一个字符后的结果：</span><br></pre></td></tr></table></figure><blockquote><p>s = “[in brackets]”<br>string.sub(s,2,-2)        –&gt; in brackets<br>string.sub(s,1,1)            –&gt; [<br>string.sub(s,-1,-1)        –&gt;    ]</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请注意，Lua语言中的字符串是不可变的。和Lua语言中的所有其他函数一样，函数string.sub不会改变原有字符串的值，它只会返回一个新字符串。</span><br><span class="line">一种常见的误解是以为string.sub（s,2,-2）返回的是修改后的s。</span><br><span class="line">如果需要修改原字符串，那么必须把新的值赋值给它：</span><br></pre></td></tr></table></figure><p>s =  string.sub(s,2,-2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数string.char和string.byte用于转换字符及其内部数值表示。</span><br><span class="line">函数string.char接收零个或多个整数作为参数，然后将每个整数转换成对应的字符，最后返回由这些字符连接而成的字符串。</span><br><span class="line">函数string.byte（s,i）返回字符串s中第i个字符的内部数值表示，该函数的第二个参数是可选的。</span><br><span class="line">调用string.byte（s）返回字符串s中第一个字符（如果字符串只由一个字符组成，那么就返回这个字符）的内部数值表示。</span><br><span class="line">在下例中，假定字符是用ASCII表示的：</span><br></pre></td></tr></table></figure><p>print(string.char(97))                        –&gt; abc<br>i = 99;print(string.char(i,i+1,i+2))        –&gt; cde<br>print(string.byte(“abc”))                    –&gt; 97<br>print(string.byte(“abc”,2))                    –&gt; 98<br>print(string.byte(“abc”,-1))                –&gt; 99</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在最后一行中，使用了负数索引来访问字符串的最后一个字符。</span><br><span class="line">调用string.byte（s,i,j）返回索引i到j之间（包括i和j）的所有字符的数值表示：</span><br></pre></td></tr></table></figure><p>print(string.byte(“abc”,1,2))                –&gt; 97 98</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 一种常见的写法是&#123;string.byte（s,1,-1）&#125;，该表达式会创建一个由字符串s中的所有字符代码组成的表（由于Lua语言限制了栈大小，所以也限制了一个函数的返回值的最大个数，默认最大为一百万个。因此，这个技巧不能用于大小超过1MB的字符串）。</span><br><span class="line">   </span><br><span class="line">函数string.format是用于进行字符串格式化和将数值输出为字符串的强大工具，该函数会返回第一个参数（也就是所谓的格式化字符串（  format string））的副本，其中的每一个指示符（directive）都会被替换为使用对应格式进行格式化后的对应参数。</span><br><span class="line">格式化字符串中的指示符与C语言中函数printf的规则类似，一个指示符由一个百分号和一个代表格式化方式的字母组成：d代表一个十进制整数、x代表一个十六进制整数、f代表一个浮点数、s代表字符串，等等。</span><br></pre></td></tr></table></figure><blockquote><p>string.format(“x = %d y = %d”,10,20)                        –&gt; x = 10 y = 20<br>string.format(“x = %x”,200)                                –&gt; x = c8<br>string.format(“x = 0x%X”,200)                                –&gt; x = 0xC8<br>string.format(“x = %f”,200)                                –&gt; x = 200.000000<br>tag,title = “h1”,”a title”<br>string.format(“&lt;%s&gt;%s&lt;/%s&gt;”,tag,title,tag)                –&gt; <h1>a title<h1></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在百分号和字母之间可以包含用于控制格式细节的其他选项。</span><br><span class="line"></span><br><span class="line">例如，可以指定一个浮点数中小数点的位数：</span><br></pre></td></tr></table></figure><p>print(string.format(“pi = %.4f”,math.pi))                    –&gt; pi = 3.1416<br>d = 5;m = 11;y = 1990<br>print(string.format(“%02d/%02d/%04d”,d,m,y))                –&gt; 05/11/1990</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在上例中，%.4f表示小数点后保留4位小数；%02d表示一个十进制数至少由两个数字组成，不足两个数字的用0补齐，而%2d则表示用空格来补齐。</span><br><span class="line">关于这些指示符的完整描述可以参阅C语言printf函数的相关文档，因为Lua语言是通过调用C语言标准库来完成实际工作的。  </span><br><span class="line"></span><br><span class="line">可以使用冒号操作符像调用字符串的一个方法那样调用字符串标准库中的所有函数。</span><br><span class="line">例如，string.sub（s,i,j）可以重写为s:sub（i,j），string.upper（s）可以重写为s:upper（)。 </span><br><span class="line"></span><br><span class="line">字符串标准库还包括了几个基于模式匹配的函数。</span><br><span class="line">函数string.find用于在指定的字符串中进行模式搜索：</span><br></pre></td></tr></table></figure><blockquote><p>string.find(“hello world”,”wor”)                            –&gt; 7 9<br>string.find(“hello world”,”war”)                            –&gt; nil</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果该函数在指定的字符串中找到了匹配的模式，则返回模式的开始和结束位置，否则返回nil。</span><br><span class="line"></span><br><span class="line">函数string.gsub（Global SUBstitution）则把所有匹配的模式用另一个字符串替换：</span><br></pre></td></tr></table></figure><blockquote><p>string.gsub(“hello world”,”l”,”.”)                        –&gt; he..o wor.d 3<br>string.gsub(“hello world”,”ll”,”..”)                        –&gt; he..o world 1<br>string.gsub(“hello world”,”a”,”.”)                        –&gt; hello world 0</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">该函数还会在第二个返回值中返回发生替换的次数。   </span><br><span class="line"># Chapter5表</span><br><span class="line">表（Table）是Lua语言中最主要（事实上也是唯一的）和强大的数据结构。使用表，Lua语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。Lua语言也使用表来表示包（package）和其他对象。</span><br><span class="line">当调用函数math.sin时，我们可能认为是“调用了math库中函数sin”；而对于Lua语言来说，其实际含义是“以字符串&quot;sin&quot;为键检索表math”。</span><br><span class="line"></span><br><span class="line">Lua语言中的表本质上是一种辅助数组（associative array），这种数组不仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引（nil除外）。</span><br><span class="line"></span><br><span class="line">Lua语言中的表要么是值要么是变量，它们都是对象（ object）。可以认为，表是一种动态分配的对象，程序只能操作指向表的引用（或指针）。</span><br><span class="line">除此以外，Lua语言不会进行隐藏的拷贝（hidden copies）或创建新的表 。（此处所谓的隐藏的拷贝是指深拷贝，即拷贝的是对象的引用而非整个对象本身。）</span><br><span class="line"></span><br><span class="line">表永远是匿名的，表本身和保存表的变量之间没有固定的关系。</span><br><span class="line"></span><br><span class="line">对于一个表而言，当程序中不再有指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。</span><br><span class="line">## 5.1表索引</span><br><span class="line">同一个表中存储的值可以具有不同的类型索引 ，并可以按需增长以容纳新的元素。 </span><br></pre></td></tr></table></figure><blockquote><p>a = {}        –空的表<br>– 创建1000个新元素<br>for i=1,1000 do a[i] = i*2 end<br>a[9]            –&gt; 18<br>a[“x”] = 10<br>a[“x”]        –&gt; 10<br>a[“y”]        –&gt; nil</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请注意上述代码的最后一行：如同全局变量一样，未经初始化的表元素为nil，将nil赋值给表元素可以将其删除。这并非巧合，因为Lua语言实际上就是使用表来存储全局变量的（详见第22章）。</span><br><span class="line"></span><br><span class="line">当把表当作结构体使用时，可以把索引当作成员名称使用（a.name等价于a[&quot;name&quot;]）。因此，可以使用这种更加易读的方式改写前述示例的最后几行：</span><br></pre></td></tr></table></figure><blockquote><p>a = {}        –空的表<br>a.x = 10        –等价于a[“x”] = 10、<br>a.x            –&gt; 10    –等价于a[“x”]<br>a.y             –&gt; nil    –等价于a[“y”]</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对Lua语言而言，这两种形式是等价且可以自由混用的；不过，对于阅读程序的人而言，这两种形式可能代表了不同的意图。</span><br><span class="line">形如a.name的点分形式清晰地说明了表是被当作结构体使用的，此时表实际上是由固定的、预先定义的键组成的集合；而形如a[&quot;name&quot;]的字符串索引形式则说明了表可以使用任意字符串作为键，并且出于某种原因我们操作的是指定的键。</span><br><span class="line"></span><br><span class="line">初学者常常会混淆a.x和a[x]。</span><br><span class="line">实际上，a.x代表的是a[&quot;x&quot;]，即由字符串&quot;x&quot;索引的表；而a[x]则是指由变量x对应的值索引的表，例如：</span><br></pre></td></tr></table></figure><blockquote><p>a = {}<br>x = “y”<br>a[x] = 10        – 把10放在字段”y”中<br>a[x]            –&gt; 10    –字段”y”的值<br>a.x            –&gt; nil    –字段”x”的值(未定义)<br>a.y            –&gt; 10    –字段”y”的值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于可以使用任意类型索引表，所以在索引表时会遇到相等性比较方面的微妙问题。</span><br><span class="line">虽然确实都能用数字0和字符串&quot;0&quot;对同一个表进行索引，但这两个索引的值及其所对应的元素是不同的。</span><br><span class="line">同样，字符串&quot;+1&quot;、&quot;01&quot;和&quot;1&quot;指向的也是不同的元素。</span><br><span class="line">当不能确定表索引的真实数据类型时，可以使用显式的类型转换。</span><br><span class="line"></span><br><span class="line">整型和浮点型类型的表索引则不存在上述问题。由于2和2.0的值相等，所以当它们被当作表索引使用时指向的是同一个表元素：</span><br></pre></td></tr></table></figure><blockquote><p>a = {}<br>a[2.0] = 10<br>a[2.1] = 20<br>a[2]        –&gt; 10<br>a[2.1]    –&gt; 20</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">更准确地说，当被用作表索引时，任何能够被转换为整型的浮点数都会被转换成整型数。</span><br><span class="line">例如，当执行表达式a[2.0]=10时，键2.0会被转换为2。相反，不能被转换为整型数的浮点数则不会发生上述的类型转换。</span><br><span class="line">## 5.2表构造器</span><br><span class="line">表构造器（Table Constructor）是用来创建和初始化表的表达式，也是Lua语言中独有的也是最有用、最灵活的机制之一。</span><br><span class="line"></span><br><span class="line">正如我们此前已经提到的，最简单的构造器是空构造器&#123;&#125;。</span><br><span class="line">表构造器也可以被用来初始化列表，例如，下例中使用字符串&quot;Sunday&quot;初始化了days[1]（构造器第一个元素的索引是1而不是0）、使用字符串&quot;Monday&quot;初始化了days[2]，依此类推：</span><br></pre></td></tr></table></figure><p>days =  {“Sunday”,”Monday”,”Tuesday”,”Wednesday”,”Thursday”,”Friday”,”Saturday”}</p><p>print(days[4])        –&gt; Wednesday</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lua语言还提供了一种初始化记录式（record-like）表的特殊语法：</span><br></pre></td></tr></table></figure><p>a = {x = 10 , y = 20}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上述代码等价于：</span><br></pre></td></tr></table></figure><p>a = {}; a.x = 10; a.y = 20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不过，在第一种写法中，由于能够提前判断表的大小，所以运行速度更快。</span><br><span class="line">无论使用哪种方式创建表，都可以随时增加或删除表元素。</span><br><span class="line"></span><br><span class="line">不过，正如此前所提到的，使用合适的构造器来创建表会更加高效和易读。</span><br><span class="line">在同一个构造器中，可以混用记录式（record-style）和列表式（list-style）写法：</span><br></pre></td></tr></table></figure><p>polyline = {<br>    color = “blue”,<br>    thickness = 2,<br>    npoints = 4,<br>    { x = 0 , y = 0 },        – polyline[1]<br>    { x = -10 , y = 0 },    – polyline[2]<br>    { x = -10 , y = 1 },    – polyline[3]<br>    { x = 0 , y = 1 },        – polyline[4]<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上述的示例也同时展示了如何创建嵌套表（和构造器）以表达更加复杂的数据结构。</span><br><span class="line">每一个元素polyline[i]都是代表一条记录的表：</span><br></pre></td></tr></table></figure><p>print(polyline[2].x)        –&gt; -10<br>print(polyline[4].y)        –&gt; 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不过，这两种构造器都有各自的局限。</span><br><span class="line">例如，使用这两种构造器时，不能使用负数索引初始化表元素，也不能使用不符合规范的标识符作为索引。</span><br><span class="line">对于这类需求，可以使用另一种更加通用的构造器，即通过方括号括起来的表达式显式地指定每一个索引：</span><br></pre></td></tr></table></figure><p>opnames = {[“+”] = “add”,[“-“] = “sub”,<br>            [“*”] = “mul”,[“/“] = “div”}</p><p>i = 20;s = “-“<br>a = {[i+0] = s,[i+1] = s..s,[i+2] = s..s..s}</p><p>print(opnames[s])        –&gt; sub<br>print(a[22])            –&gt; —</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这种构造器虽然冗长，但却非常灵活，不管是记录式构造器还是列表式构造器均是其特殊形式。</span><br><span class="line">例如，下面的几种表达式就相互等价：</span><br></pre></td></tr></table></figure><p>{ x = 0 , y = 0 }        &lt;–&gt;        { [“x”] = 0 , [“y”] = 0 }<br>{ “r”,”g”,”b” }            &lt;–&gt;        {[1] = “r”,[2] = “g”,[3] = “b”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">## 5.3数组、列表和序列</span><br><span class="line">如果想表示常见的数组（array）或列表（list），那么只需要使用整型作为索引的表即可。同时，也不需要预先声明表的大小，只需要直接初始化我们需要的元素即可。</span><br><span class="line"></span><br><span class="line">当操作列表时，往往必须事先获取列表的长度。列表的长度可以存放在常量中，也可以存放在其他变量或数据结构中。</span><br><span class="line">通常，我们把列表的长度保存在表中某个非数值类型的字段中（由于历史原因，这个键通常是&quot;n&quot;）。当然，列表的长度经常也是隐式的。</span><br><span class="line">请注意，由于未初始化的元素均为nil，所以可以利用nil值来标记列表的结束。</span><br><span class="line">例如，当向一个列表中写入了10行数据后，由于该列表的数值类型的索引为1,2,...,10，所以可以很容易地知道列表的长度就是10。</span><br><span class="line">这种技巧只有在列表中不存在空洞（hole）时（即所有元素均不为nil）才有效，此时我们把这种所有元素都不为nil的数组称为序列（sequence）。</span><br><span class="line"></span><br><span class="line">对于中间存在空洞（nil值）的列表而言，序列长度操作符是不可靠的，它只能用于序列（所有元素均不为nil的列表）。</span><br><span class="line">更准确地说，序列（sequence）是由指定的 n 个正数数值类型的键所组成集合&#123;1,...,n&#125;形成的表（请注意值为nil的键实际不在表中）。</span><br><span class="line">特别地，不包含数值类型键的表就是长度为零的序列。</span><br><span class="line"></span><br><span class="line">## 5.4 遍历表</span><br><span class="line">我们可以使用pairs迭代器遍历表中的键值对：</span><br></pre></td></tr></table></figure><p>t = {10，print,x = 12,k = “hi”}<br>for k,v in pairs(t) do<br>    print(k,v)<br>end</p><p>—&gt; 1 10<br>—&gt; k hi<br>—&gt; 2 function: 0x420610<br>—&gt; x 12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">受限于表在Lua语言中的底层实现机制，遍历过程中元素的出现顺序可能是随机的，相同的程序在每次运行时也可能产生不同的顺序。</span><br><span class="line">唯一可以确定的是，在遍历的过程中每个元素会且只会出现一次。</span><br><span class="line"></span><br><span class="line">对于列表而言，可以使用ipairs迭代器：</span><br></pre></td></tr></table></figure><p>t = {10，print,12,”hi”}<br>for k,v in ipairs(t) do<br>    print(k,v)<br>end</p><p>—&gt; 1 10<br>—&gt; 2 function: 0x420610<br>—&gt; 3 12<br>—&gt; 4 hi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时，Lua会确保遍历是按照顺序进行的。</span><br><span class="line"></span><br><span class="line">另一种遍历序列的方法是使用数值型for循环：</span><br></pre></td></tr></table></figure><p>t = {10，print,12,”hi”}<br>for k=1,#t in do<br>    print(k,t[k])<br>end</p><p>—&gt; 1 10<br>—&gt; 2 function: 0x420610<br>—&gt; 3 12<br>—&gt; 4 hi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 5.5安全访问</span><br><span class="line">考虑如下的情景：我们想确认在指定的库中是否存在某个函数。如果我们确定这个库确实存在，那么可以直接使用if lib.foo then...；否则，就得使用形如if lib and lib.foo then...的表达式。</span><br><span class="line">   </span><br><span class="line">当表的嵌套深度变得比较深时，这种写法就会很容易出错，例如：</span><br></pre></td></tr></table></figure><p>zip = company and company.director and<br>        company.director.address and<br>            company.director.address.zipcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这种写法不仅冗长而且低效，该写法在一次成功的访问中对表进行了6次访问而非3次访问。</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">对于这种情景，诸如C#的一些编程语言提供了一种安全访问操作符（safe navigation operator）。</span><br><span class="line">在C#中，这种安全访问操作符被记为“？.”。例如，对于表达式a？.b，当a为nil时，其结果是nil而不会产生异常。使用这种操作符，可以将上例改写为：</span><br></pre></td></tr></table></figure><p>zip = company?.director?.address?.zipcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果上述的成员访问过程中出现nil，安全访问操作符会正确地处理nil并最终返回nil。</span><br><span class="line"></span><br><span class="line">Lua语言并没有提供安全访问操作符，并且认为也不应该提供这种操作符。</span><br><span class="line">一方面，Lua语言在设计上力求简单；另一方面，这种操作符也是非常有争议的，很多人就无理由地认为该操作符容易导致无意的编程错误。</span><br><span class="line">不过，我们可以使用其他语句在Lua语言中模拟安全访问操作符。</span><br><span class="line"></span><br><span class="line">对于表达式a or &#123;&#125;，当a为nil时其结果是一个空表。因此，对于表达式（a or&#123;&#125;）.b，当a为nil时其结果也同样是nil。</span><br><span class="line">这样，我们就可以将之前的例子重写为：</span><br></pre></td></tr></table></figure><p>zip = (((company or {}).director or  {}).address or {}).zipcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再进一步，我们还可以写得更短和更高效：</span><br></pre></td></tr></table></figure><p>E = {} – 可以在其他类似表达式中复用</p><p>zip = (((company or E).director or  E).address or E).zipcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">确实，上述的语法比安全访问操作符更加复杂。</span><br><span class="line">不过尽管如此，表中的每一个字段名都只被使用了一次，从而保证了尽可能少地对表进行访问（本例中对表仅有3次访问）；同时，还避免了向语言中引入新的操作符。</span><br><span class="line">就我个人看来，这已经是一种足够好的替代方案了。</span><br><span class="line">## 5.6表标准库</span><br><span class="line">表标准库提供了操作列表和序列的一些常用函数。</span><br><span class="line"></span><br><span class="line">函数table.insert向序列的指定位置插入一个元素，其他元素依次后移。</span><br><span class="line">例如，对于列表t=&#123;10,20,30&#125;，在调用table.insert（t,1,15）后它会变成&#123;15,10,20,30&#125;，另一种特殊但常见的情况是调用insert时不指定位置，此时该函数会在序列的最后插入指定的元素，而不会移动任何元素。</span><br><span class="line"></span><br><span class="line">函数table.remove删除并返回序列指定位置的元素，然后将其后的元素向前移动填充删除元素后造成的空洞。如果在调用该函数时不指定位置，该函数会删除序列的最后一个元素。</span><br><span class="line"></span><br><span class="line">Lua 5.3对于移动表中的元素引入了一个更通用的函数table.move（a,f,e,t），调用该函数可以将表a中从索引f到e的元素（包含索引f和索引e对应的元素本身）移动到位置t上。</span><br><span class="line">例如，如下代码可以在列表a的开头插入一个元素：</span><br></pre></td></tr></table></figure><p>table.move(a,1,#a,2);<br>a[1] = newElement</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下的代码可以删除第一个元素：</span><br></pre></td></tr></table></figure><p>table.move(a,2,#a,1)<br>a[#a] = nil</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">应该注意，在计算机领域，移动（move）实际上是将一个值从一个地方拷贝（copy）到另一个地方。因此，像上面的例子一样，我们必须在移动后显式地把最后一个元素删除。</span><br><span class="line"> </span><br><span class="line">函数table.move还支持使用一个表作为可选的参数。</span><br><span class="line">当带有可选的表作为参数时，该函数将第一个表中的元素移动到第二个表中。</span><br><span class="line">例如，table.move（a,1,#a,1,&#123;&#125;）返回列表a的一个克隆（clone）（通过将列表a中的所有元素拷贝到新列表中），table.move（a,1,#a,#b+1,b）将列表a中的所有元素复制到列表b的末尾 。</span><br><span class="line"># Chapter6函数</span><br><span class="line">在Lua语言中，函数（Function）是对语句和表达式进行抽象的主要方式。函数既可以用于完成某种特定任务（有时在其他语言中也称为过程（procedure）或子例程（ subroutine）），也可以只是进行一些计算然后返回计算结果。</span><br><span class="line">在前一种情况下，我们将一句函数调用视为一条语句；而在后一种情况下，我们则将函数调用视为表达式。</span><br><span class="line"></span><br><span class="line">一个Lua程序既可以调用Lua语言编写的函数，也可以调用C语言（或者宿主程序使用的其他任意语言）编写的函数。</span><br><span class="line">一般来说，我们选择使用C语言编写的函数来实现对性能要求更高，或不容易直接通过Lua语言进行操作的操作系统机制等。</span><br><span class="line">例如，Lua语言标准库中所有的函数就都是使用C语言编写的。</span><br><span class="line">不过，无论一个函数是用Lua语言编写的还是用C语言编写的，在调用它们时都没有任何区别。</span><br><span class="line"></span><br><span class="line">在这种语法中，一个函数定义具有一个函数名（name，本例中的add）、一个参数（parameter）组成的列表和由一组语句组成的函数体（body）。</span><br><span class="line">参数的行为与局部变量的行为完全一致，相当于一个用函数调用时传入的值进行初始化的局部变量。</span><br><span class="line">   </span><br><span class="line">调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致。Lua语言会通过抛弃多余参数和将不足的参数设为nil的方式来调整参数的个数。</span><br><span class="line">## 6.1多返回值</span><br><span class="line">Lua语言中一种与众不同但又非常有用的特性是允许一个函数返回多个结果（Multiple Results）。  </span><br><span class="line"></span><br><span class="line">Lua语言根据函数的被调用情况调整返回值的数量。</span><br><span class="line">当函数被作为一条单独语句调用时，其所有返回值都会被丢弃；当函数被作为表达式（例如，加法的操作数）调用时，将只保留函数的第一个返回值。</span><br><span class="line">只有当函数调用是一系列表达式中的最后一个表达式（或是唯一一个表达式）时，其所有的返回值才能被获取到。</span><br><span class="line">这里所谓的“一系列表达式”在Lua中表现为4种情况：多重赋值、函数调用时传入的实参列表、表构造器和return语句。</span><br><span class="line"></span><br><span class="line">为了分别展示这几种情况，接下来举几个例子：</span><br></pre></td></tr></table></figure><p>function foo0() end                        – 不返回结果<br>function foo1() return “a” end            – 返回1个结果<br>function foo2() return “a”,”b” end         – 返回2个结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在多重赋值中，如果一个函数调用是一系列表达式中的最后（或者是唯一）一个表达式，则该函数调用将产生尽可能多的返回值以匹配待赋值变量：</span><br></pre></td></tr></table></figure><p>x,y = foo2()        – x = “a”,y = “b”<br>x = foo2()            – x = “a”,”b”被丢弃<br>x,y,z = 10,foo2()    – x = 10,y = “a”,z = “b”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在多重赋值中，如果一个函数没有返回值或者返回值个数不够多，那么Lua语言会用nil来补充缺失的值：</span><br></pre></td></tr></table></figure><p>x,y = foo0()        – x = nil,y = nil<br>x,y = foo1()        – x = “a”,y = nil<br>x,y,z = 10,foo2()    – x = 10,y = “a”,z = “b”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请注意，只有当函数调用是一系列表达式中的最后（或者是唯一）一个表达式时才能返回多值结果，否则只能返回一个结果：</span><br></pre></td></tr></table></figure><p>x,y = foo2(),20        – x = “a”,y = 20    (“b”被丢弃)<br>x,y = foo0(),20,30    – x = nil,y = 20    (30被丢弃)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当一个函数调用是另一个函数调用的最后一个（或者是唯一）实参时，第一个函数的所有返回值都会被作为实参传给第二个函数。</span><br><span class="line">我们已经见到过很多这样的代码结构，例如函数print。由于函数print能够接收可变数量的参数，所以print（g（））会打印出g返回的所有结果。</span><br></pre></td></tr></table></figure><p>print(foo0())        –&gt; (没有结果)<br>print(foo1())        –&gt; a<br>print(foo2())        –&gt; a b<br>print(foo2(),1)        –&gt; a 1<br>print(foo2()..”x”)    –&gt; ax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当在表达式中调用foo2时，Lua语言会把其返回值的个数调整为1。因此，在上例的最后一行，只有第一个返回值&quot;a&quot;参与了字符串连接操作。</span><br><span class="line"></span><br><span class="line">当我们调用f（g（））时，如果f的参数是固定的，那么Lua语言会把g返回值的个数调整成与f的参数个数一致。这并非巧合，实际上这正是多重赋值的逻辑。</span><br><span class="line"> </span><br><span class="line">表构造器会完整地接收函数调用的所有返回值，而不会调整返回值的个数：  </span><br></pre></td></tr></table></figure><p>t = {foo0()}        – t = {}(一个空表)<br>t = {foo1()}        – t = {“a”}<br>t = {foo2()}        – t = {“a”,”b”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不过，这种行为只有当函数调用是表达式列表中的最后一个时才有效，在其他位置上的函数调用总是只返回一个结果：</span><br></pre></td></tr></table></figure><p>t =  {foo0(),foo2(),4}        – t[1] = nil,t[2] = “a”,t[3] = 4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后，形如return f（）的语句会返回f返回的所有结果：</span><br></pre></td></tr></table></figure><p>function foo(i)<br>    if i == 0 then return foo0()<br>    elseif i == 1 then return foo1()<br>    elseif i == 2 then return foo2()<br>    end<br>end</p><p>print(foo(1))        –&gt; a<br>print(foo(2))        –&gt; a b<br>print(foo(0))        –&gt; (无结果)<br>print(foo(3))        –&gt; (无结果)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将函数调用用一对圆括号括起来可以强制其只返回一个结果：</span><br></pre></td></tr></table></figure><p>print((foo(0)))        –&gt; nil<br>print((foo(1)))        –&gt; a<br>print((foo(2)))        –&gt; a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 6.2可变长参数函数</span><br><span class="line">Lua语言中的函数可以是可变长参数函数（variadic），即可以支持数量可变的参数。</span><br><span class="line"></span><br><span class="line">下面是一个简单的示例，该函数返回所有参数的总和：</span><br></pre></td></tr></table></figure><p>function add (…)<br>    local s = 0<br>    for _,v in ipairs {…} do<br>        s = s + v<br>    end</p><pre><code>return s</code></pre><p>end</p><p>print(add(3,4,10,25,12))        –&gt; 54</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数列表中的三个点（...）表示该函数的参数是可变长的。</span><br><span class="line">当这个函数被调用时，Lua内部会把它的所有参数收集起来，我们把这些被收集起来的参数称为函数的额外参数（extra argument）。</span><br><span class="line">当函数要访问这些参数时仍需用到三个点，但不同的是此时这三个点是作为一个表达式来使用的。</span><br><span class="line">在上例中，表达式&#123;...&#125;的结果是一个由所有可变长参数组成的列表，该函数会遍历该列表来累加其中的元素。</span><br><span class="line">   </span><br><span class="line">我们将三个点组成的表达式称为可变长参数表达式（vararg expression），其行为类似于一个具有多个返回值的函数，返回的是当前函数的所有可变长参数。</span><br><span class="line"></span><br><span class="line">具有可变长参数的函数也可以具有任意数量的固定参数，但固定参数必须放在变长参数之前。Lua语言会先将前面的参数赋给固定参数，然后将剩余的参数（如果有）作为可变长参数。</span><br><span class="line"></span><br><span class="line">要遍历可变长参数，函数可以使用表达式&#123;...&#125;将可变长参数放在一个表中，就像add示例中所做的那样。</span><br><span class="line">不过，在某些罕见的情况下，如果可变长参数中包含无效的nil，那么&#123;...&#125;获得的表可能不再是一个有效的序列。此时，就没有办法在表中判断原始参数究竟是不是以nil结尾的。</span><br><span class="line">对于这种情况，Lua语言提供了函数table.pack。 该函数像表达式&#123;...&#125;一样保存所有的参数，然后将其放在一个表中返回，但是这个表还有一个保存了参数个数的额外字段&quot;n&quot;。</span><br><span class="line">例如，下面的函数使用了函数table.pack来检测参数中是否有nil：</span><br></pre></td></tr></table></figure><p>function nonils (…)<br>    local arg = table.pack(…)<br>    for i = 1,arg.n do<br>        if arg[i] == nil then<br>            return false<br>        end<br>    end</p><pre><code>return true</code></pre><p>end</p><p>print(nonils(2,3,nil))        –&gt; false<br>print(nonils(2,3))            –&gt; true<br>print(nonils())                –&gt; true<br>print(nonils(nil))            –&gt; false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种遍历函数的可变长参数的方法是使用函数select。</span><br><span class="line">函数select总是具有一个固定的参数 selector，以及数量可变的参数。</span><br><span class="line">如果selector是数值n，那么函数select则返回第n个参数后的所有参数；否则，selector应该是字符串&quot;#&quot;，以便函数select返回额外参数的总数。</span><br></pre></td></tr></table></figure><p>print(select(1,”a”,”b”,”c”))        –&gt; a b c<br>print(select(2,”a”,”b”,”c”))        –&gt; b c<br>print(select(3,”a”,”b”,”c”))        –&gt; c<br>print(select(“#”,”a”,”b”,”c”))        –&gt; 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常，我们在需要把返回值个数调整为1的地方使用函数select，因此可以把select（n,...）认为是返回第n个额外参数的表达式。</span><br><span class="line"></span><br><span class="line">来看一个使用函数select的典型示例，下面是使用该函数的add函数：</span><br></pre></td></tr></table></figure><p>function add (…)<br>    local s = 0<br>    for i = 1,select(“#”,……) do<br>        s = s + select(i,…)<br>    end</p><pre><code>return s</code></pre><p>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对于参数较少的情况，第二个版本的add更快，因为该版本避免了每次调用时创建一个新表。</span><br><span class="line">不过，对于参数较多的情况，多次带有很多参数调用函数select会超过创建表的开销，因此第一个版本会更好（特别地，由于迭代的次数和每次迭代时传入参数的个数会随着参数的个数增长，因此第二个版本的时间开销是二次代价（quadratic cost）的）。</span><br><span class="line">## 6.3函数table.unpack</span><br><span class="line">多重返回值还涉及一个特殊的函数table.unpack。该函数的参数是一个数组，返回值为数组内的所有元素。</span><br><span class="line"></span><br><span class="line">顾名思义，函数table.unpack与函数table.pack的功能相反。</span><br><span class="line">pack把参数列表转换成Lua语言中一个真实的列表（一个表），而unpack则把Lua语言中的真实的列表（一个表）转换成一组返回值，进而可以作为另一个函数的参数被使用。</span><br><span class="line"></span><br><span class="line">unpack函数的重要用途之一体现在泛型调用（generic call）机制中。</span><br><span class="line">泛型调用机制允许我们动态地调用具有任意参数的任意函数。例如，在ISO C中，我们无法编写泛型调用的代码，只能声明可变长参数的函数（使用stdarg.h）或使用函数指针来调用不同的函数。</span><br><span class="line">但是，我们仍然不能调用具有可变数量参数的函数，因为C语言中的每一个函数调用的实参个数是固定的，并且每个实参的类型也是固定的。</span><br><span class="line">而在Lua语言中，却可以做到这一点。如果我们想通过数组a传入可变的参数来调用函数f，那么可以写成：</span><br></pre></td></tr></table></figure><p>f(table.unpack(a))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unpack会返回a中所有的元素，而这些元素又被用作f的参数。</span><br><span class="line">例如，考虑如下的代码：</span><br></pre></td></tr></table></figure><p>print(string.find(“hello”,”ll”))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用如下的代码动态地构造一个等价的调用：</span><br></pre></td></tr></table></figure><p>f = string.find<br>a = {“hello”,”ll”}</p><p>print(f(table.unpack(a)))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通常，函数table.unpack使用长度操作符获取返回值的个数，因而该函数只能用于序列。不过，如果有需要，也可以显式地限制返回元素的范围：</span><br></pre></td></tr></table></figure><p>print(table.unpack({“Sun”,”Mon”,”Tue”,”Wed”},2,3))<br>–&gt; Mon Tue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然预定义的函数unpack是用C语言编写的，但是也可以利用递归在Lua语言中实现：</span><br></pre></td></tr></table></figure><p>function unpack(t,i,n)<br>    i = i or 1<br>    n = n or #t<br>    if i&lt;=n then<br>        return t[i],unpack(t,i+1,n)<br>    end<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在第一次调用该函数时，只传入一个参数，此时i为1，n为序列长度；然后，函数返回t[1]及unpack（t,2,n）返回的所有结果，而unpack（t,2,n）又会返回t[2]及unpack（t,3,n）返回的所有结果，依此类推，直到处理完n个元素为止。</span><br><span class="line">## 6.4正确的尾调用</span><br><span class="line">Lua语言中有关函数的另一个有趣的特性是，Lua语言是支持尾调用消除（tail-call elimination）的。这意味着Lua语言可以正确地（properly）尾递归（tail recursive ），虽然尾调用消除的概念并没有直接涉及递归。</span><br><span class="line"></span><br><span class="line">尾调用（tail call）是被当作函数调用使用的跳转 。当一个函数的最后一个动作是调用另一个函数而没有再进行其他工作时，就形成了尾调用。例如，下列代码中对函数g的调用就是尾调用：</span><br></pre></td></tr></table></figure><p>function f(x)<br>    x = x + 1<br>    return g(x)<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当函数f调用完函数g之后，f不再需要进行其他的工作。这样，当被调用的函数执行结束后，程序就不再需要返回最初的调用者。</span><br><span class="line">因此，在尾调用之后，程序也就不需要在调用栈中保存有关调用函数的任何信息。当g返回时，程序的执行路径会直接返回到调用f的位置。</span><br><span class="line">在一些语言的实现中，例如Lua语言解释器，就利用了这个特点，使得在进行尾调用时不使用任何额外的栈空间。我们就将这种实现称为尾调用消除（tail-call elimination）。</span><br><span class="line">   </span><br><span class="line">由于尾调用不会使用栈空间，所以一个程序中能够嵌套的尾调用的数量是无限的。例如，下列函数支持任意的数字作为参数：</span><br></pre></td></tr></table></figure><p>function foo(n)<br>    if n &gt; 0 then<br>        return foo(n - 1)<br>    end<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">该函数永远不会发生栈溢出。</span><br><span class="line"></span><br><span class="line">关于尾调用消除的一个重点就是如何判断一个调用是尾调用。</span><br><span class="line">很多函数调用之所以不是尾调用，是由于这些函数在调用之后还进行了其他工作。例如，下例中调用g就不是尾调用：</span><br></pre></td></tr></table></figure><p>function f(x)<br>    g(x)<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个示例的问题在于，当调用完g后，f在返回前还不得不丢弃g返回的所有结果。</span><br><span class="line">类似的，以下的所有调用也都不符合尾调用的定义：</span><br></pre></td></tr></table></figure><p>return g(x) + 1        – 必须进行加法<br>return x or g(x)    – 必须把返回值限制为1个<br>return (g(x))        – 必须把返回值限制为1个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在Lua语言中，只有形如return func（args）的调用才是尾调用。</span><br><span class="line">不过，由于Lua语言会在调用前对func及其参数求值，所以func及其参数都可以是复杂的表达式。</span><br><span class="line">例如，下面的例子就是尾调用：</span><br></pre></td></tr></table></figure><p>return x[i].foo(x[j] + a*b,i+j)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Chapter7输入输出</span><br><span class="line">由于Lua语言强调可移植性和嵌入性，所以Lua语言本身并没有提供太多与外部交互的机制。</span><br><span class="line">在真实的Lua程序中，从图形、数据库到网络的访问等大多数I/O操作，要么由宿主程序实现，要么通过不包括在发行版中的外部库实现。</span><br><span class="line">单就Lua语言而言，只提供了ISO C语言标准支持的功能，即基本的文件操作等。</span><br><span class="line">## 7.1简单I/O模型</span><br><span class="line">对于文件操作来说，I/O库提供了两种不同的模型。</span><br><span class="line">简单模型虚拟了一个当前输入流（current input stream）和一个当前输出流（current output stream），其I/O操作是通过这些流实现的。</span><br><span class="line">I/O库把当前输入流初始化为进程的标准输入（C语言中的stdin），将当前输出流初始化为进程的标准输出（C语言中的stdout）。</span><br><span class="line">因此，当执行类似于io.read（）这样的语句时，就可以从标准输入中读取一行。</span><br><span class="line">   </span><br><span class="line">函数io.input和函数io.output可以用于改变当前的输入输出流。</span><br><span class="line">调用io.input（filename）会以只读模式打开指定文件，并将文件设置为当前输入流。之后，所有的输入都将来自该文件，除非再次调用io.input。</span><br><span class="line">对于输出而言，函数io.output的逻辑与之类似。</span><br><span class="line">如果出现错误，这两个函数都会抛出异常。如果想直接处理这些异常，则必须使用完整I/O模型。</span><br><span class="line">   </span><br><span class="line">由于函数write比函数read简单，我们首先来看函数write。</span><br><span class="line">函数io.write可以读取任意数量的字符串（或者数字）并将其写入当前输出流。</span><br><span class="line">由于调用该函数时可以使用多个参数，因此应该避免使用io.write（a..b..c），应该调用io.write（a,b,c），后者可以用更少的资源达到同样的效果，并且可以避免更多的连接动作。</span><br><span class="line"></span><br><span class="line">作为原则，应该只在“用后即弃”的代码或调试代码中使用函数print；当需要完全控制输出时，应该使用函数io.write。</span><br><span class="line">与函数print不同，函数io.write不会在最终的输出结果中添加诸如制表符或换行符这样的额外内容。</span><br><span class="line">此外，函数io.write允许对输出进行重定向，而函数print只能使用标准输出。</span><br><span class="line">最后，函数print可以自动为其参数调用tostring，这一点对于调试而言非常便利，但这也容易导致一些诡异的Bug。</span><br><span class="line">   </span><br><span class="line">函数io.write在将数值转换为字符串时遵循一般的转换规则；如果想要完全地控制这种转换，则应该使用函数string.format。</span><br><span class="line"></span><br><span class="line">函数io.read可以从当前输入流中读取字符串，其参数决定了要读取的数据：</span><br></pre></td></tr></table></figure><p>“a”        读取整个文件<br>“l”        读取下一行（丢弃换行符）<br>“L”        读取下一行（保留换行符）<br>“n”        读取一个数值<br>num        以字符串读取num个字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">调用io.read（&quot;a&quot;）可从当前位置开始读取当前输入文件的全部内容。如果当前位置处于文件的末尾或文件为空，那么该函数返回一个空字符串。</span><br><span class="line"></span><br><span class="line">因为Lua语言可以高效地处理长字符串，所以在Lua语言中编写过滤器（filter）的一种简单技巧就是将整个文件读取到一个字符串中，然后对字符串进行处理，最后输出结果。</span><br><span class="line"></span><br><span class="line">调用io.read（&quot;l&quot;）会返回当前输入流的下一行，不包括换行符在内；调用io.read（&quot;L&quot;）与之类似，但会保留换行符（如果文件中存在）。</span><br><span class="line">当到达文件末尾时，由于已经没有内容可以返回，该函数会返回nil。</span><br><span class="line">选项&quot;l&quot;是函数read的默认参数。</span><br><span class="line">我通常只在逐行处理数据的算法中使用该参数，其他情况则更倾向于使用选项&quot;a&quot;一次性地读取整个文件，或者像后续介绍的按块（block）读取。</span><br><span class="line">  </span><br><span class="line">调用io.read（&quot;n&quot;）会从当前输入流中读取一个数值，这也是函数read返回值为数值（整型或者浮点型，与Lua语法扫描器的规则一致）而非字符串的唯一情况。</span><br><span class="line">如果在跳过了空格后，函数io.read仍然不能从当前位置读取到数值（由于错误的格式问题或到了文件末尾），则返回nil。</span><br><span class="line"></span><br><span class="line">除了上述这些基本的读取模式外，在调用函数read时还可以用一个数字n作为其参数：在这种情况下，函数read会从输入流中读取n个字符。</span><br><span class="line">如果无法读取到任何字符（处于文件末尾）则返回nil；否则，则返回一个由流中最多n个字符组成的字符串。</span><br><span class="line">  </span><br><span class="line">io.read（0）是一个特例，它常用于测试是否到达了文件末尾。如果仍然有数据可供读取，它会返回一个空字符串；否则，则返回nil。</span><br><span class="line"></span><br><span class="line">调用函数read时可以指定多个选项，函数会根据每个参数返回相应的结果。</span><br><span class="line">假设有一个每行由3个数字组成的文件：</span><br></pre></td></tr></table></figure><p>6.0        -3.23        15e12<br>4.3        234            1000001</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果想打印每一行的最大值，那么可以通过调用函数read来一次性地同时读取每行中的3个数字：</span><br></pre></td></tr></table></figure><p>while true do<br>    local n1,n2,n3 = io.read(“n”,”n”,”n”)</p><pre><code>if not n1 then    breakendprint(math.max(n1,n2,n3));</code></pre><p>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 7.2完整I/O模型 </span><br><span class="line">简单I/O模型对简单的需求而言还算适用，但对于诸如同时读写多个文件等更高级的文件操作来说就不够了。对于这些文件操作，我们需要用到完整I/O模型。</span><br><span class="line"></span><br><span class="line">可以使用函数io.open来打开一个文件，该函数仿造了C语言中的函数fopen。</span><br><span class="line">这个函数有两个参数，一个参数是待打开文件的文件名，另一个参数是一个模式（mode）字符串。</span><br><span class="line">模式字符串包括表示只读的r、表示只写的w（也可以用来删除文件中原有的内容）、表示追加的a，以及另外一个可选的表示打开二进制文件的b。</span><br><span class="line">函数io.open返回对应文件的流。</span><br><span class="line">当发生错误时，该函数会在返回nil的同时返回一条错误信息及一个系统相关的错误码。</span><br><span class="line"></span><br><span class="line">检查错误的一种典型方法是使用函数assert。</span><br><span class="line">如果函数io.open执行失败，错误信息会作为函数assert的第二个参数被传入，之后函数assert会将错误信息展示出来。</span><br><span class="line">   </span><br><span class="line">在打开文件后，可以使用方法read和write从流中读取和向流中写入。它们与函数read和write类似，但需要使用冒号运算符将它们当作流对象的方法来调用。</span><br><span class="line">例如，可以使用如下的代码打开一个文件并读取其中所有内容：</span><br></pre></td></tr></table></figure><p>local f = assert(io.open(filename,”r”))<br>local t = f:read(“a”)<br>f:close()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">I/O库提供了三个预定义的C语言流的句柄：io.stdin、io.stdout和io.stderr。</span><br><span class="line">例如，可以使用如下的代码将信息直接写到标准错误流中：</span><br></pre></td></tr></table></figure><p>io.stderr:write(message)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数io.input和io.output允许混用完整I/O模型和简单I/O模型。</span><br><span class="line">调用无参数的io.input（）可以获得当前输入流，调用io.input（handle）可以设置当前输入流（类似的调用同样适用于函数io.output）。</span><br><span class="line">例如，如果想要临时改变当前输入流，可以像这样：</span><br></pre></td></tr></table></figure><p>local temp = io.input() – 保存当前输入流<br>io.input(“newInput”)    – 打开一个新的当前输入流<br>– 对新的输入流进行某些操作<br>io.input():close()        – 关闭当前流<br>io.input(temp)            – 恢复此前的当前输入流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意，io.read（args）实际上是io.input（）:read（args）的简写，即函数read是用在当前输入流上的。同样，io.write（args）是io.output（）:write（args）的简写。</span><br><span class="line"></span><br><span class="line">除了函数io.read外，还可以用函数io.lines从流中读取内容。</span><br><span class="line">正如之前的示例中展示的那样，函数io.lines返回一个可以从流中不断读取内容的迭代器。</span><br><span class="line">给函数io.lines提供一个文件名，它就会以只读方式打开对应该文件的输入流，并在到达文件末尾后关闭该输入流。若调用时不带参数，函数io.lines就从当前输入流读取。</span><br><span class="line">我们也可以把函数lines当作句柄的一个方法。</span><br><span class="line"></span><br><span class="line">此外，从Lua 5.2开始，函数io.lines可以接收和函数io.read一样的参数。</span><br><span class="line">例如，下面的代码会以在8KB为块迭代，将当前输入流中的内容复制到当前输出流中：</span><br></pre></td></tr></table></figure><p>for block in io.input():lines(2^13) do<br>    io.write(block)<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## 7.3其他文件操作</span><br><span class="line">函数io.tmpfile返回一个操作临时文件的句柄，该句柄是以读/写模式打开的。当程序运行结束后，该临时文件会被自动移除（删除）。</span><br><span class="line"></span><br><span class="line">函数flush将所有缓冲数据写入文件。</span><br><span class="line">与函数write一样，我们也可以把它当作io.flush（）使用，以刷新当前输出流；或者把它当作方法f:flush（）使用，以刷新流f。 </span><br><span class="line"></span><br><span class="line">函数setvbuf用于设置流的缓冲模式。</span><br><span class="line">该函数的第一个参数是一个字符串：&quot;no&quot;表示无缓冲，&quot;full&quot;表示在缓冲区满时或者显式地刷新文件时才写入数据，&quot;line&quot;表示输出一直被缓冲直到遇到换行符或从一些特定文件（例如终端设备）中读取到了数据。</span><br><span class="line">对于后两个选项，函数setvbuf支持可选的第二个参数，用于指定缓冲区大小。</span><br><span class="line"></span><br><span class="line">在大多数系统中，标准错误流（io.stderr）是不被缓冲的，而标准输出流（io.stdout）按行缓冲。</span><br><span class="line">因此，当向标准输出中写入了不完整的行（例如进度条）时，可能需要刷新这个输出流才能看到输出结果。</span><br><span class="line"></span><br><span class="line">函数seek用来获取和设置文件的当前位置，常常使用f:seek（whence,offset）的形式来调用，其中参数whence是一个指定如何使用偏移的字符串。</span><br><span class="line">当参数whence取值为&quot;set&quot;时，表示相对于文件开头的偏移；取值为&quot;cur&quot;时，表示相对于文件当前位置的偏移；取值为&quot;end&quot;时，表示相对于文件尾部的偏移。</span><br><span class="line">不管whence的取值是什么，该函数都会以字节为单位，返回当前新位置在流中相对于文件开头的偏移。</span><br><span class="line">whence的默认值是&quot;cur&quot;，offset的默认值是0。</span><br><span class="line">因此，调用函数file:seek（）会返回当前的位置且不改变当前位置；调用函数file:seek（&quot;set&quot;）会将位置重置到文件开头并返回0；调用函数file:seek（&quot;end&quot;）会将当前位置重置到文件结尾并返回文件的大小。</span><br><span class="line">下面的函数演示了如何在不修改当前位置的情况下获取文件大小：</span><br></pre></td></tr></table></figure><p>function fsize(file)<br>    local current = file:seek()        – 保存当前位置<br>    local size = file:seek(“end”)    – 获取文件大小<br>    file:seek(“set”,current)        – 恢复当前位置</p><pre><code>return size</code></pre><p>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此外，函数os.rename用于文件重命名，函数os.remove用于移除（删除）文件。需要注意的是，由于这两个函数处理的是真实文件而非流，所以它们位于os库而非io库中。</span><br><span class="line"></span><br><span class="line">上述所有的函数在遇到错误时，均会返回nil外加一条错误信息和一个错误码。</span><br><span class="line">## 7.4 其他系统调用</span><br><span class="line">函数os.exit用于终止程序的执行。</span><br><span class="line">该函数的第一个参数是可选的，表示该程序的返回状态，其值可以为一个数值（0表示执行成功）或者一个布尔值（true表示执行成功）；</span><br><span class="line">该函数的第二个参数也是可选的，当值为true时会关闭Lua状态并调用所有析构器释放所占用的所有内存（这种终止方式通常是非必要的，因为大多数操作系统会在进程退出时释放其占用的所有资源）。</span><br><span class="line"></span><br><span class="line">函数os.getenv用于获取某个环境变量，该函数的输入参数是环境变量的名称，返回值为保存了该环境变量对应值的字符串。</span><br><span class="line">对于未定义的环境变量，该函数返回nil。</span><br><span class="line">### 7.4.1运行系统命令</span><br><span class="line">函数os.execute用于运行系统命令，它等价于C语言中的函数system。</span><br><span class="line">该函数的参数为表示待执行命令的字符串，返回值为命令运行结束后的状态。</span><br><span class="line">其中，第一个返回值是一个布尔类型，当为true时表示程序成功运行完成；</span><br><span class="line">第二个返回值是一个字符串，当为&quot;exit&quot;时表示程序正常运行结束，当为&quot;signal&quot;时表示因信号而中断；</span><br><span class="line">第三个返回值是返回状态（若该程序正常终结）或者终结该程序的信号代码。</span><br><span class="line"></span><br><span class="line">例如，在POSIX和Windows中都可以使用如下的函数创建新目录：</span><br></pre></td></tr></table></figure><p>function createDir(dirname)<br>    return os.execute(“mkdir”..dirname)<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一个非常有用的函数是io.popen。</span><br><span class="line">同函数os.execute一样，该函数运行一条系统命令，但该函数还可以重定向命令的输入/输出，从而使得程序可以向命令中写入或从命令的输出中读取。</span><br><span class="line"></span><br><span class="line">例如，下列代码使用当前目录中的所有内容构建了一个表：</span><br></pre></td></tr></table></figure><p>– 对于POSIX系统而言，使用’ls’而非’dir’<br>local f = io.popen(“dir /B”,”r”)<br>local dir = {}<br>for entry in f:lines() do<br>    dir[#dir + 1] = entry<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">其中，函数io.popen的第二个参数&quot;r&quot;表示从命令的执行结果中读取。由于该函数的默认行为就是这样，所以在上例中这个参数实际是可选的。</span><br><span class="line"></span><br><span class="line">正如我们在上面的两个例子中看到的一样，函数os.execute和io.popen都是功能非常强大的函数，但它们也同样是非常依赖于操作系统的。</span><br><span class="line"># Chapter8补充知识</span><br><span class="line"> ## 8.1 局部变量和代码块</span><br><span class="line">Lua语言中的变量在默认情况下是全局变量，所有的局部变量在使用前必须声明。与全局变量不同，局部变量的生效范围仅限于声明它的代码块。</span><br><span class="line">一个代码块（block）是一个控制结构的主体，或是一个函数的主体，或是一个代码段（即变量被声明时所在的文件或字符串）。</span><br><span class="line">   </span><br><span class="line">一旦输入了do，命令就只会在遇到匹配的end时才结束，这样Lua语言解释器就不会单独执行每一行的命令。</span><br><span class="line">当需要更好地控制某些局部变量的生效范围时，do程序块也同样有用：</span><br></pre></td></tr></table></figure><p>local x1,x2<br>do<br> local a2 = 2<em>a<br> local d = (b^2 - 4</em>a*c)^(1/2)<br> x1 = (-b + d)/a2<br> x2 = (-b - d)/a2<br>end        – ‘a2’和’d’的范围在此结束<br>print(x1,x2)    – ‘x1’和’x2’仍在范围内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">尽可能地使用局部变量是一种良好的编程风格。</span><br><span class="line">首先，局部变量可以避免由于不必要的命名而造成全局变量的混乱；</span><br><span class="line">其次，局部变量还能避免同一程序中不同代码部分中的命名冲突；</span><br><span class="line">再次，访问局部变量比访问全局变量更快；</span><br><span class="line">最后，局部变量会随着其作用域的结束而消失，从而使得垃圾收集器能够将其释放。</span><br><span class="line"></span><br><span class="line">局部变量的声明可以包含初始值，其赋值规则与常见的多重赋值一样：多余的值被丢弃，多余的变量被赋值为nil。如果一个声明中没有赋初值，则变量会被初始化为nil。</span><br><span class="line"></span><br><span class="line">Lua语言中有一种常见的用法：</span><br></pre></td></tr></table></figure><p>local foo = foo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">这段代码声明了一个局部变量foo，然后用全局变量foo对其赋初值（局部变量foo只有在声明之后才能被访问）。</span><br><span class="line">这个用法在需要提高对foo的访问速度时很有用。当其他函数改变了全局变量foo的值，而代码段又需要保留foo的原始值时，这个用法也很有用，尤其是在进行运行时动态替换（monkey patching，猴子补丁）时。</span><br><span class="line">即使其他代码把print动态替换成了其他函数，在local print=print语句之前的所有代码使用的还都是原先的print函数。</span><br><span class="line">## 8.2控制结构</span><br><span class="line">Lua语言提供了一组精简且常用的控制结构（control structure），包括用于条件执行的if以及用于循环的while、repeat和for。</span><br><span class="line">所有的控制结构语法上都有一个显式的终结符：end用于终结if、for及while结构，until用于终结repeat结构。</span><br><span class="line">   </span><br><span class="line">控制结构的条件表达式（condition expression）的结果可以是任何值。请记住，Lua语言将所有不是false和nil的值当作真（特别地，Lua语言将0和空字符串也当作真）。</span><br><span class="line">### 8.2.1 if then else</span><br><span class="line">if语句先测试其条件，并根据条件是否满足执行相应的then部分或else部分。else部分是可选的。</span><br><span class="line">如果要编写嵌套的if语句，可以使用elseif。它类似于在else后面紧跟一个if，但可以避免重复使用end。</span><br><span class="line">### 8.2.2 while</span><br><span class="line">顾名思义，当条件为真时while循环会重复执行其循环体。</span><br><span class="line">Lua语言先测试while语句的条件，若条件为假则循环结束；否则，Lua会执行循环体并不断地重复这个过程。</span><br><span class="line">### 8.2.3 repeat</span><br><span class="line">顾名思义，repeat-until语句会重复执行其循环体直到条件为真时结束。</span><br><span class="line">由于条件测试在循环体之后执行，所以循环体至少会执行一次。</span><br><span class="line"></span><br><span class="line">和大多数其他编程语言不同，在Lua语言中，循环体内声明的局部变量的作用域包括测试条件：</span><br></pre></td></tr></table></figure><p>– 使用Newton-Raphson法计算’x’的平方根<br>local sqr = x/2<br>repeat<br>    sqr = (sqr + x / sqr) / 2<br>    local error = math.abs(sqr^2 - x)<br>until error &lt; x/10000        – 局部变量’error’此时仍然可见</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 8.2.4 数值型for</span><br><span class="line">for语句有两种形式：数值型（numerical）for和泛型（generic）for。</span><br><span class="line">   </span><br><span class="line">数值型for的语法如下：</span><br></pre></td></tr></table></figure><p>for var = exp1,exp2,exp3 do<br>    something<br>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在这种循环中，var的值从exp1变化到exp2之前的每次循环会执行something，并在每次循环结束后将步长（step）exp3增加到var上。</span><br><span class="line">第三个表达式exp3是可选的，若不存在，Lua语言会默认步长值为1。</span><br><span class="line">如果不想给循环设置上限，可以使用常量math.huge。</span><br><span class="line"></span><br><span class="line">为了更好地使用for循环，还需要了解一些细节。</span><br><span class="line">首先，在循环开始前，三个表达式都会运行一次；</span><br><span class="line">其次，控制变量是被for语句自动声明的局部变量，且其作用范围仅限于循环体内。</span><br><span class="line"></span><br><span class="line">如果需要在循环结束后使用控制变量的值（通常在中断循环时），则必须将控制变量的值保存到另一个变量中。</span><br><span class="line"></span><br><span class="line">最后，不要改变控制变量的值，随意改变控制变量的值可能产生不可预知的结果。</span><br><span class="line">如果要在循环正常结束前停止for循环，可以使用break语句。</span><br><span class="line">### 8.2.5 泛型for</span><br><span class="line">泛型for遍历迭代函数返回的所有值，例如我们已经在很多示例中看到过的pairs、ipairs和io.lines等。</span><br><span class="line">虽然泛型for看似简单，但它的功能非常强大。使用恰当的迭代器可以在保证代码可读性的情况下遍历几乎所有的数据结构。</span><br><span class="line"></span><br><span class="line">与数值型for不同，泛型for可以使用多个变量，这些变量在每次循环时都会更新。当第一个变量变为nil时，循环终止。</span><br><span class="line">像数值型for一样，控制变量是循环体中的局部变量，我们也不应该在循环中改变其值。</span><br><span class="line">## 8. 3 break、return和goto</span><br><span class="line">break和return语句用于从当前的循环结构中跳出，goto语句则允许跳转到函数中的几乎任何地方。</span><br><span class="line"></span><br><span class="line">我们可以使用break语句结束循环，该语句会中断包含它的内层循环（例如for、repeat或者while）；该语句不能在循环外使用。break中断后，程序会紧接着被中断的循环继续执行。</span><br><span class="line">return语句用于返回函数的执行结果或简单地结束函数的运行。所有函数的最后都有一个隐含的return，因此我们不需要在每一个没有返还值的函数最后书写return语句。</span><br><span class="line"></span><br><span class="line">goto语句用于将当前程序跳转到相应的标签处继续执行。</span><br><span class="line">在Lua语言中，goto语句的语法非常传统，即保留字goto后面紧跟着标签名，标签名可以是任意有效的标识符。标签的语法稍微有点复杂：标签名称前后各紧跟两个冒号，形如::name::。</span><br><span class="line">这个复杂的语法是有意而为的，主要是为了在程序中醒目地突出这些标签。</span><br><span class="line"></span><br><span class="line">在使用goto跳转时，Lua语言设置了一些限制条件。</span><br><span class="line">首先，标签遵循常见的可见性规则，因此不能直接跳转到一个代码块中的标签（因为代码块中的标签对外不可见）。</span><br><span class="line">其次，goto不能跳转到函数外（注意第一条规则已经排除了跳转进一个函数的可能性）。</span><br><span class="line">最后，goto不能跳转到局部变量的作用域。</span><br><span class="line"></span><br><span class="line">关于goto语句典型且正确的使用方式，请参考其他一些编程语言中存在但Lua语言中不存在的代码结构，例如continue、多级break、多级continue、redo和局部错误处理等。</span><br><span class="line">continue语句仅仅相当于一个跳转到位于循环体最后位置处标签的goto语句，而redo语句则相当于跳转到代码块开始位置的goto语句：</span><br></pre></td></tr></table></figure><p>while some_condition do<br>    ::redo::</p><pre><code>if some_other_condition then    goto continueelse if yet_another_condition then    goto redoendsome code::continue::</code></pre><p>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lua语言规范中一个很有用的细节是，局部变量的作用域终止于声明变量的代码块中的最后一个有效（non-void）语句处，标签被认为是无效（void）语句。</span><br><span class="line">下列代码展示了这个实用的细节：</span><br></pre></td></tr></table></figure><p>while some_condition do<br>    if some_other_condition then<br>        goto continue<br>    end</p><pre><code>local var = somethingsome code::continue::</code></pre><p>end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读者可能认为，这个goto语句跳转到了变量var的作用域内。</span><br><span class="line">但实际上这个continue标签出现在该代码块的最后一个有效语句后，因此goto并未跳转进入变量var的作用域内。</span><br><span class="line"></span><br><span class="line">举一个简单的迷宫游戏的例子。</span><br><span class="line">迷宫中有几个房间，每个房间的东南西北方向各有一扇门。玩家每次可以输入移动的方向，如果在这个方向上有一扇门，则玩家可以进入相应的房间，否则程序输出一个警告，玩家的最终目的是从第一个房间走到最后一个房间。  </span><br><span class="line">这个游戏是一个典型的状态机，当前玩家所在房间就是一个状态。为实现这个迷宫游戏，我们可以为每个房间对应的逻辑编写一段代码，然后用goto语句表示从一个房间移动到另一个房间。示例展示了如何编写一个由4个房间组成的小迷宫。</span><br></pre></td></tr></table></figure><p>goto room1    – 起始房间</p><p>::room1:: do<br>    local move = io.read()<br>    if move == “south” then<br>        goto room3<br>    elseif move == “east” then<br>        goto room2<br>    else<br>        print(“invalid move”)<br>        goto room1    – 待在同一个房间<br>    end<br>end</p><p>::room2:: do<br>    local move = io.read()<br>    if move == “south” then<br>        goto room4<br>    elseif move == “west” then<br>        goto room1<br>    else<br>        print(“invalid move”)<br>        goto room2<br>    end<br>end</p><p>::room3:: do<br>    local move = io.read()<br>    if move == “north” then<br>        goto room1<br>    elseif move == “east” then<br>        goto room4<br>    else<br>        print(“invalid move”)<br>        goto room3    – 待在同一个房间<br>    end<br>end</p><p>::room4:: do<br>    print(“Congratulations,you won!”)<br>end</p><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter1-Lua语言入门&quot;&gt;&lt;a href=&quot;#Chapter1-Lua语言入门&quot; class=&quot;headerlink&quot; title=&quot;Chapter1        Lua语言入门&quot;&gt;&lt;/a&gt;Chapter1        Lua语言入门&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《Lua程序设计》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
    <category term="Lua语言入门" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8ALua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（串）</title>
    <link href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/"/>
    <id>https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-21T14:53:27.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-5-串"><a href="#Chapter-5-串" class="headerlink" title="Chapter 5 串"></a>Chapter 5 串</h1><p>串：串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。<br>一般记为s=”a1a2……an”(n≥0)，其中，s是串的名称，用双引号（有些书中也用单引号）括起来的字符序列是串的值，注意引号不属于串的内容。<br>ai（1≤i≤n）可以是字母、数字或其他字符，i就是该字符在串中的位置。<br>串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。<br>零个字符的串称为空串（nullstring），它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。<br>所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p><p>还有一些概念需要解释。</p><p>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</p><p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><h2 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h2><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><p>如果我们要在C语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。即给定两个串：s=”a1a2……an”，t=”b1b2……bm”，当且仅当n=m，且a1=b1，a2=b2，……，an=bm时，我们认为s=t。</p><h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><p>串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符。</p><p>因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT  串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">StrAssign</span><span class="params">(T,  *chars)</span>:                生成一个其值等于字符串常量chars的串T。</span></span><br><span class="line"><span class="function"><span class="title">StrCopy</span><span class="params">(T,  S)</span>:                              串S存在，由串S复制得串T。</span></span><br><span class="line"><span class="function"><span class="title">ClearString</span><span class="params">(S)</span>:                            串S存在，将串清空。</span></span><br><span class="line"><span class="function"><span class="title">StringEmpty</span><span class="params">(S)</span>:                            若串S为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span></span><br><span class="line"><span class="function"><span class="title">StrLength</span><span class="params">(S)</span>:                                返回串S的元素个数，即串的长度。</span></span><br><span class="line"><span class="function"><span class="title">StrCompare</span><span class="params">(S,  T)</span>:                        若S&gt;T，返回值&gt;0，若S</span>=T，返回<span class="number">0</span>，若S&lt;T，返回值&lt;<span class="number">0</span>。</span><br><span class="line">Concat(T,  S1,  S2):                      用T返回由S1和S2联接而成的新串。</span><br><span class="line">SubString(Sub,  S,  pos,  len):  串S存在，<span class="number">1</span>≤pos≤StrLength(S)，且<span class="number">0</span>≤len≤StrLength(S)-pos+<span class="number">1</span>，用Sub返回串S的第pos个字符起长度为len的子串。</span><br><span class="line">Index(S,  T,  pos):                        串S和T存在，T是非空串，<span class="number">1</span>≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span>。</span><br><span class="line">Replace(S,  T,  V):                        串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。</span><br><span class="line">StrInsert(S,  pos,  T):                串S和T存在，<span class="number">1</span>≤pos≤StrLength(S)+<span class="number">1</span>。在串S的第pos个字符之前插入串T。</span><br><span class="line">StrDelete(S,  pos,  len):            串S存在，<span class="number">1</span>≤pos≤StrLength(S)-len+<span class="number">1</span>。从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><p>串的存储结构与线性表相同，分为两种。</p><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p><p>对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。</p><h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全。</p><p>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。  */</span></span><br><span class="line"><span class="comment">/*  T非空，1≤pos≤StrLength(S)。  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Index</span><span class="params">(String  S,  String  T,  <span class="keyword">int</span>  pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  i用于主串S中当前位置下标，若pos不为1  */</span></span><br><span class="line"><span class="comment">/*  则从pos位置开始匹配  */</span></span><br><span class="line"><span class="keyword">int</span>  i  =  pos;                             </span><br><span class="line"><span class="comment">/*  j用于子串T中当前位置下标值  */</span></span><br><span class="line"><span class="keyword">int</span>  j  =  <span class="number">1</span>;                               </span><br><span class="line"><span class="comment">/*  若i小于S长度且j小于T的长度时循环  */</span></span><br><span class="line"><span class="keyword">while</span>  (i  &lt;=  S[<span class="number">0</span>]  &amp;&amp;  j  &lt;=  T[<span class="number">0</span>])       </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  两字母相等则继续  */</span></span><br><span class="line"><span class="keyword">if</span>  (S[i]  ==  T[j])                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  指针后退重新开始匹配  */</span></span><br><span class="line">++i;++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  i退回到上次匹配首位的下一位  */</span></span><br><span class="line">i  =  i  -  j  +  <span class="number">2</span>;                        </span><br><span class="line"><span class="comment">/*  j退回到子串T的首位  */</span></span><br><span class="line">j  =  <span class="number">1</span>;                                    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (j  =  T[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  i  -  T[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h2><p><img src="/img/CSDataStructure/32.jpg"><br>如果主串S=”abcdefgab”，与我们要匹配的T=”abcdex”，那么如果用前面的朴素算法的话，前5个字母，两个串完全相等，直到第6个字母，“f”与“x”不等，如图1的①所示。<br>接下来，按照朴素模式匹配算法，应该是如图1的流程②③④⑤⑥。即主串S中当i=2、3、4、5、6时，首字符与子串T的首字符均不等。</p><p>似乎这也是理所当然，原来的算法就是这样设计的。可仔细观察发现。对于要匹配的子串T来说，“abcdex”首字母“a”与后面的串“bcdex”中任意一个字符都不相等。也就是说，既然“a”不与自己后面的子串中任何一字符相等，那么对于图1的①来说，前五位字符分别相等，意味着子串T的首字符“a”不可能与S串的第2位到第5位的字符相等。在图1中，②③④⑤的判断都是多余。</p><p><img src="/img/CSDataStructure/33.jpg"><br>注意这里是理解KMP算法的关键。如果我们知道T串中首字符“a”与T中后面的字符均不相等（注意这是前提，如何判断后面再讲）。<br>而T串的第二位的“b”与S串中第二位的“b”在图1的①中已经判断是相等的，那么也就意味着，T串中首字符“a”与S串中的第二位“b”是不需要判断也知道它们是不可能相等了，这样图1的②这一步判断是可以省略的，如图2所示。</p><p><img src="/img/CSDataStructure/34.jpg"><br>同样道理，在我们知道T串中首字符“a”与T中后面的字符均不相等的前提下，T串的“a”与S串后面的“c”、“d”、“e”也都可以在①之后就可以确定是不相等的，所以这个算法当中②③④⑤没有必要，只保留①⑥即可，如图3所示。</p><p>之所以保留⑥中的判断是因为在①中T[6]≠S[6]，尽管我们已经知道T[1]≠T[6]，但也不能断定T[1]一定不等于S[6]，因此需要保留⑥这一步。</p><p>有人就会问，如果T串后面也含有首字符“a”的字符怎么办呢？</p><p><img src="/img/CSDataStructure/35.jpg"><br>我们来看下面一个例子，假设S=”abcababca”，T=”abcabx”。对于开始的判断，前5个字符完全相等，第6个字符不等，如图5-7-4的①。此时，根据刚才的经验，T的首字符“a”与T的第二位字符“b”、第三位字符“c”均不等，所以不需要做判断，图4的朴素算法步骤②③都是多余。</p><p>因为T的首位“a”与T第四位的“a”相等，第二位的“b”与第五位的“b”相等。而在①时，第四位的“a”与第五位的“b”已经与主串S中的相应位置比较过了，是相等的，因此可以断定，T的首字符“a”、第二位的字符“b”与S的第四位字符和第五位字符也不需要比较了，肯定也是相等的——之前比较过了，还判断什么，所以④⑤这两个比较得出字符相等的步骤也可以省略。</p><p><img src="/img/CSDataStructure/36.jpg"><br>也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。如图5所示，省略掉右图的T串前两位“a”与“b”同S串中的4、5位置字符匹配操作。</p><p>对比这两个例子，我们会发现在①时，我们的i值，也就是主串当前位置的下标是6，②③④⑤，i值是2、3、4、5，到了⑥，i值才又回到了6。即我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的——正所谓好马不吃回头草，我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。</p><p>既然i值不回溯，也就是不可以变小，那么要考虑的变化就是j值了。通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，发现如果有相等字符，j值的变化就会不相同。也就是说，这个j值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。<br>比如图3中，由于T=”abcdex”，当中没有任何重复的字符，所以j就由6变成了1。而图5中，由于T=”abcabx”，前缀的“ab”与最后“x”之前串的后缀“ab”是相等的。因此j就由6变成了3。<br>因此，我们可以得出规律，j值的多少取决于当前字符之前的串的前后缀的相似度。</p><p>我们把T串各个位置的j值的变化定义为一个数组next，那么next的长度就是T串的长度。于是我们可以得到下面的函数定义：<br><img src="/img/CSDataStructure/37.jpg"></p><h3 id="next数组值推导"><a href="#next数组值推导" class="headerlink" title="next数组值推导"></a>next数组值推导</h3><p>具体如何推导出一个串的next数组值呢，我们来看一些例子。</p><ul><li>1.T=”abcdex”</li></ul><p>j  123456<br>模式串T  abcdex<br>next[j]  011111  </p><p>1）当j=1时，next[1]=0；<br>2）当j=2时，j由1到j-1就只有字符“a”，属于其他情况next[2]=1；<br>3）当j=3时，j由1到j-1串是“ab”，显然“a”与“b”不相等，属其他情况，next[3]=1；<br>4）以后同理，所以最终此T串的next[j]为011111。</p><ul><li>2.T=”abcabx”</li></ul><p>j  123456<br>模式串T  abcabx<br>next[j]  011123 </p><p>1）当j=1时，next[1]=0；<br>2）当j=2时，同上例说明，next[2]=1；<br>3）当j=3时，同上，next[3]=1；<br>4）当j=4时，同上，next[4]=1；<br>5）当j=5时，此时j由1到j-1的串是“abca”，前缀字符“a”与后缀字符“a”相等（前缀用下划线表示，后缀用斜体表示），因此可推算出k值为2（由‘p1…pk-1’=‘pj-k＋1…pj-1’，得到p1=p4）因此next[5]=2；<br>6）当j=6时，j由1到j-1的串是“abcab”，由于前缀字符“ab”与后缀“ab”相等，所以next[6]=3。</p><p>我们可以根据经验得到如果前后缀一个字符相等，k值是2，两个字符k值是3，n个相等k值就是n+1。</p><ul><li>3．T=”ababaaaba”</li></ul><p>j  123456789<br>模式串T  ababaaaba<br>next[j]  011234223 </p><p>1）当j=1时，next[1]=0；<br>2）当j=2时，同上next[2]=1；<br>3）当j=3时，同上next[3]=1；<br>4）当j=4时，j由1到j-1的串是“aba”，前缀字符“a”与后缀字符“a”相等，next[4]=2；<br>5）当j=5时，j由1到j-1的串是“abab”，由于前缀字符“ab”与后缀“ab”相等，所以next[5]=3；<br>6）当j=6时，j由1到j-1的串是“ababa”，由于前缀字符“aba”与后缀“aba”相等，所以next[6]=4；<br>7）当j=7时，j由1到j-1的串是“ababaa”，由于前缀字符“ab”与后缀“aa”并不相等，只有“a”相等，所以next[7]=2；<br>8）当j=8时，j由1到j-1的串是“ababaaa”，只有“a”相等，所以next[8]=2；<br>9）当j=9时，j由1到j-1的串是“ababaaab”，由于前缀字符“ab”与后缀“ab”相等，所以next[9]=3。</p><ul><li>4．T=”aaaaaaaab”</li></ul><p>j  123456789<br>模式串T  aaaaaaaab<br>next[j]  012345678 </p><p>1）当j=1时，next[1]=0；<br>2）当j=2时，同上next[2]=1；<br>3）当j=3时，j由1到j-1的串是“aa”，前缀字符“a”与后缀字符“a”相等，next[3]=2；<br>4）当j=4时，j由1到j-1的串是“aaa”，由于前缀字符“aa”与后缀“aa”相等，所以next[4]=3；<br>5）……<br>6）当j=9时，j由1到j-1的串是“aaaaaaaa”，由于前缀字符“aaaaaaa”与后缀“aaaaaaa”相等，所以next[9]=8。</p><h3 id="KMP模式匹配算法实现"><a href="#KMP模式匹配算法实现" class="headerlink" title="KMP模式匹配算法实现"></a>KMP模式匹配算法实现</h3><p>计算出当前要匹配的串T的next数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  通过计算返回子串T的next数组。  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">get_next</span><span class="params">(String  T,  <span class="keyword">int</span>  *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line">i  =  <span class="number">1</span>;j  =  <span class="number">0</span>;next[<span class="number">1</span>]  =  <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*  此处T[0]表示串T的长度  */</span></span><br><span class="line"><span class="keyword">while</span>  (i  &lt;  T[<span class="number">0</span>])                                      </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  T[i]表示后缀的单个字符，  */</span></span><br><span class="line"><span class="comment">/*  T[j]表示前缀的单个字符  */</span></span><br><span class="line"><span class="keyword">if</span>  (j  ==  <span class="number">0</span>  ||  T[i]  ==  T[j])        </span><br><span class="line">&#123;</span><br><span class="line">++i;++j;</span><br><span class="line">next[i]  =  j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>j  =  next[j];<span class="comment">/*  若字符不相同，则j值回溯  */</span>                          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T = “abcabx”;<br>i=1; j=0;<br>next[1] = 0;<br>T[0] = 6</p><p>i=2; j=1;<br>next[2] = 1</p><p>j=0;//回溯</p><p>i=3; j=1;<br>next[3] = 1;</p><p>j=0;//回溯</p><p>i=4; j=1;<br>next[4] = 1;</p><p>i=5; j=2;<br>next[5] = 2;</p><p>i=6; j=3;<br>next[6]=3;</p><p>next = [0,1,1,1,2,3]<br>/———-/<br>T=”ababaaaba”</p><p>i=1;j=0;<br>next[1]=0;</p><p>T[0] = 9;</p><p>i=2;j=1;<br>next[2]=1;</p><p>j=next[1]=0;//回溯</p><p>i=3;j=1;<br>next[3]=1;</p><p>i=4;j=2;<br>next[4]=2;</p><p>i=5;j=3;<br>next[5]=3;</p><p>i=6;j=4;<br>next[6]=4;</p><p>j=next[4]=2;//回溯</p><p>j=next[2]=1;//回溯</p><p>i=7,j=2;<br>next[7]=2;</p><p>j=next[2]=1;//回溯</p><p>i=8;j=2;<br>next[8]=2;</p><p>i=9;j=3;<br>next[9]=3;</p><p>next[0,1,1,2,3,4,2,2,3]</p><p>KMP模式匹配算法实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。  */</span></span><br><span class="line"><span class="comment">/*  T非空，1≤pos≤StrLength(S)。  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Index_KMP</span><span class="params">(String  S,  String  T,  <span class="keyword">int</span>  pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  i用于主串S当前位置下标值，若pos不为1，  */</span></span><br><span class="line"><span class="comment">/*  则从pos位置开始匹配  */</span></span><br><span class="line"><span class="keyword">int</span>  i  =  pos;                                              </span><br><span class="line"><span class="comment">/*  j用于子串T中当前位置下标值  */</span></span><br><span class="line"><span class="keyword">int</span>  j  =  <span class="number">1</span>;                                                  </span><br><span class="line"><span class="comment">/*  定义一next数组  */</span></span><br><span class="line"><span class="keyword">int</span>  next[<span class="number">255</span>];                                          </span><br><span class="line"><span class="comment">/*  对串T作分析，得到next数组  */</span></span><br><span class="line">get_next(T,  next);                                  </span><br><span class="line"><span class="comment">/*  若i小于S的长度且j小于T的长度时，  */</span></span><br><span class="line"><span class="comment">/*  循环继续  */</span></span><br><span class="line"><span class="keyword">while</span>  (i  &lt;=  S[<span class="number">0</span>]  &amp;&amp;  j  &lt;=  T[<span class="number">0</span>])          </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  两字母相等则继续，相对于朴素算法增加了  */</span></span><br><span class="line"><span class="comment">/*  j=0判断  */</span></span><br><span class="line"><span class="keyword">if</span>  (j  ==  <span class="number">0</span>  ||  S[i]  ==  T[j])        </span><br><span class="line">&#123;</span><br><span class="line">++i;++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  指针后退重新开始匹配  */</span>                                                      </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  j退回合适的位置，i值不变  */</span></span><br><span class="line">j  =  next[j];                              </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>  (j  &gt;  T[<span class="number">0</span>])<span class="keyword">return</span>  i  -  T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了i值回溯的部分。<br>对于get_next函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得index_KMP算法效率得到了提高，while循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n＋m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。<br>这里也需要强调，KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显。</p><h2 id="KMP模式匹配算法改进"><a href="#KMP模式匹配算法改进" class="headerlink" title="KMP模式匹配算法改进"></a>KMP模式匹配算法改进</h2><p>后来有人发现，KMP还是有缺陷的。比如，如果我们的主串S=”aaaabcde”，子串T=”aaaaax”，其next数组值分别为012345，在开始时，当i=5、j=5时，我们发现“b”与“a”不相等，如图5-7-6的①，因此j=next[5]=4，如图中的②，此时“b”与第4位置的“a”依然不等，j=next[4]=3，如图中的③，后依次是④⑤，直到j=next[1]=0时，根据算法，此时i++、j++，得到i=6、j=1，如图中的⑥。</p><p><img src="/img/CSDataStructure/38.jpg"></p><p>我们发现，当中的②③④⑤步骤，其实是多余的判断。由于T串的第二、三、四、五位置的字符都与首位的“a”相等，那么可以用首位next[1]的值去取代与它相等的字符后续next[j]的值，这是个很好的办法。因此我们对求next函数进行了改良。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  求模式串T的next函数修正值并存入数组nextval  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">get_nextval</span><span class="params">(String  T,  <span class="keyword">int</span>  *nextval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,j;</span><br><span class="line">i  =  <span class="number">1</span>;</span><br><span class="line">j  =  <span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>]  =  <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*  此处T[0]表示串T的长度  */</span></span><br><span class="line"><span class="keyword">while</span>  (i  &lt;  T[<span class="number">0</span>])                                                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  T[i]表示后缀的单个字符，  */</span></span><br><span class="line"><span class="comment">/*  T[j]表示前缀的单个字符  */</span></span><br><span class="line"><span class="keyword">if</span>  (j  ==  <span class="number">0</span>  ||  T[i]  ==  T[j])                  </span><br><span class="line">&#123;</span><br><span class="line">++i;++j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若当前字符与前缀字符不同  */</span></span><br><span class="line"><span class="keyword">if</span>  (T[i]  !=  T[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  则当前的j为nextval在i位置的值  */</span></span><br><span class="line">nextval[i]  =  j;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  如果与前缀字符相同，则将前缀  */</span></span><br><span class="line"><span class="comment">/*  字符的nextval值赋值给nextval在i位置的值  */</span></span><br><span class="line">nextval[i]  =  nextval[j];</span><br><span class="line">&#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>j  =  nextval[j];<span class="comment">/*  若字符不相同，则j值回溯  */</span>                                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextval数组值推导"><a href="#nextval数组值推导" class="headerlink" title="nextval数组值推导"></a>nextval数组值推导</h3><ul><li>1．T=”ababaaaba”</li></ul><p>j  123456789<br>模式串T      ababaaaba<br>next[j]          011234223<br>nextval[j]   010104210  </p><p>先算出next数组的值分别为011234223，然后再分别判断。</p><p>1）当j=1时，nextval[1]=0；<br>2）当j=2时，因第二位字符“b”的next值是1，而第一位就是“a”，它们不相等，所以nextval[2]=next[2]=1，维持原值。<br>3）当j=3时，因为第三位字符“a”的next值为1，所以与第一位的“a”比较得知它们相等，所以nextval[3]=nextval[1]=0；如图所示。<br><img src="/img/CSDataStructure/39.jpg"><br>4）当j=4时，第四位的字符“b”next值为2，所以与第二位的“b”相比较得到结果是相等，因此nextval[4]=nextval[2]=1；如图所示。<br><img src="/img/CSDataStructure/40.jpg"><br>5）当j=5时，next值为3，第五个字符“a”与第三个字符“a”相等，因此nextval[5]=nextval[3]=0；<br>6）当j=6时，next值为4，第六个字符“a”与第四个字符“b”不相等，因此nextval[6]=4；<br>7）当j=7时，next值为2，第七个字符“a”与第二个字符“b”不相等，因此nextval[7]=2；<br>8）当j=8时，next值为2，第八个字符“b”与第二个字符“b”相等，因此nextval[8]=nextval[2]=1；<br>9）当j=9时，next值为3，第九个字符“a”与第三个字符“a”相等，因此nextval[9]=nextval[3]=0。</p><p>总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>这一章节我们重点讲了“串”这样的数据结构，串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如KMP模式匹配算法的学习，就是更有效地去理解index函数当中的实现细节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-5-串&quot;&gt;&lt;a href=&quot;#Chapter-5-串&quot; class=&quot;headerlink&quot; title=&quot;Chapter 5 串&quot;&gt;&lt;/a&gt;Chapter 5 串&lt;/h1&gt;&lt;p&gt;串：串（string）是由零个或多个字符组成的有限序列，又名叫字符串</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="串" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E4%B8%B2/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（树）</title>
    <link href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/"/>
    <id>https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure3(%E6%A0%91)/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-21T14:54:19.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-6-树"><a href="#Chapter-6-树" class="headerlink" title="Chapter 6 树"></a>Chapter 6 树</h1><p>树：<br>    树（Tree）是n（n≥0）个结点的有限集。<br>    n=0时称为空树。<br>    在任意一棵非空树中：<br>    （1）有且仅有一个特定的称为根（Root）的结点；<br>    （2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>之前我们一直在谈的是一对一的线性结构，可现实中，还有很多一对多的情况需要处理，所以我们需要研究这种一对多的数据结构——“树”，考虑它的各种特性，来解决我们在编程中碰到的相关问题。</p><p>对于树的定义还需要强调两点： 1.n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。 2.m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</p><h2 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。<br>结点拥有的子树数称为结点的度（De-gree）。<br>度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。<br>除根结点之外，分支结点也称为内部结点。<br>树的度是树内各结点的度的最大值。<br>如图所示，因为这棵树结点的度的最大值是结点D的度，为3，所以树的度也为3。<br><img src="/img/CSDataStructure/41.jpg"></p><h2 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h2><p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。<br>对于结点来说其父母同体，唯一的一个，所以只能把它称为双亲了。<br>同一个双亲的孩子之间互称兄弟（Sibling）。<br>结点的祖先是从根到该结点所经分支上的所有结点。<br>所以对于H来说，D、B、A都是它的祖先。<br>反之，以某结点为根的子树中的任一结点都称为该结点的子孙。<br>B的子孙有D、G、H、I，如图所示。<br><img src="/img/CSDataStructure/42.jpg"></p><h2 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h2><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。<br>若某结点在第 i 层，则其子树就在第 i+1层。<br>其双亲在同一层的结点互为堂兄弟。<br>显然图中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。<br>树中结点的最大层次称为树的深度（Depth）或高度，当前树的深度为4。<br><img src="/img/CSDataStructure/43.jpg"><br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林（Forest）是m（m≥0）棵互不相交的树的集合。<br>对树中每个结点而言，其子树的集合即为森林。</p><p>对比线性表与树的结构，它们有很大的不同，如图所示。<br><img src="/img/CSDataStructure/44.jpg"></p><h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT  树(tree)</span><br><span class="line">Data树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">InitTree</span><span class="params">(*T)</span>:                           构造空树T。</span></span><br><span class="line"><span class="function"><span class="title">DestroyTree</span><span class="params">(*T)</span>:                       销毁树T。</span></span><br><span class="line"><span class="function"><span class="title">CreateTree</span><span class="params">(*T,  definition)</span>:  按definition中给出树的定义来构造树。</span></span><br><span class="line"><span class="function"><span class="title">ClearTree</span><span class="params">(*T)</span>:                          若树T存在，则将树T清为空树。</span></span><br><span class="line"><span class="function"><span class="title">TreeEmpty</span><span class="params">(T)</span>:                           若T为空树，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span></span><br><span class="line"><span class="function"><span class="title">TreeDepth</span><span class="params">(T)</span>:                           返回T的深度。</span></span><br><span class="line"><span class="function"><span class="title">Root</span><span class="params">(T)</span>:                                返回T的根结点。</span></span><br><span class="line"><span class="function"><span class="title">Value</span><span class="params">(T,  cur_e)</span>:                       cur_e是树T中一个结点，返回此结点的值。</span></span><br><span class="line"><span class="function"><span class="title">Assign</span><span class="params">(T,  cur_e,  value)</span>:        给树T的结点cur_e赋值为value。</span></span><br><span class="line"><span class="function"><span class="title">Parent</span><span class="params">(T,  cur_e)</span>:                      若cur_e是树T的非根结点，则返回它的双亲，否则返回空。</span></span><br><span class="line"><span class="function"><span class="title">LeftChild</span><span class="params">(T,  cur_e)</span>:                若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。</span></span><br><span class="line"><span class="function"><span class="title">RightSibling</span><span class="params">(T,  cur_e)</span>:          若cur_e有右兄弟，则返回它的右兄弟，否则返回空。</span></span><br><span class="line"><span class="function"><span class="title">InsertChild</span><span class="params">(*T,  *p,  i,  c)</span>:    其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。</span></span><br><span class="line"><span class="function"><span class="title">DeleteChild</span><span class="params">(*T,  *p,  i)</span>:          其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。</span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></table></figure><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系，你想想看，数据元素挨个的存储，谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现要求的。<br>不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。<br>我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。</p><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p><p>以下是我们的双亲表示法的结点结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的双亲表示法结点结构定义  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_TREE_SIZE  100</span></span><br><span class="line"><span class="comment">/*  树结点的数据类型，目前暂定为整型  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  TElemType;                            </span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">PTNode</span>                              </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数据  */</span></span><br><span class="line">TElemType  data;                                  </span><br><span class="line"><span class="comment">/*  双亲位置  */</span></span><br><span class="line"><span class="keyword">int</span>  parent;                                          </span><br><span class="line">&#125;  PTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  树结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数组  */</span></span><br><span class="line">PTNode  nodes[MAX_TREE_SIZE];        </span><br><span class="line"><span class="comment">/*  根的位置和结点数  */</span></span><br><span class="line"><span class="keyword">int</span>  r,  n;                                              </span><br><span class="line">&#125;  PTree;</span><br></pre></td></tr></table></figure><p>有了这样的结构定义，我们就可以来实现双亲表示法了。<br>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。</p><p><img src="/img/CSDataStructure/41.jpg"><br>双亲表示法所示为：</p><table><thead><tr><th>下标</th><th>data</th><th>parent</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>1</td></tr><tr><td>4</td><td>E</td><td>2</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>G</td><td>3</td></tr><tr><td>7</td><td>H</td><td>3</td></tr><tr><td>8</td><td>I</td><td>3</td></tr><tr><td>9</td><td>J</td><td>4</td></tr></tbody></table><p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。<br>可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。<br>这真是麻烦，能不能改进一下呢？<br>当然可以。<br>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。<br>如果没有孩子的结点，这个长子域就设置为-1。</p><table><thead><tr><th>下标</th><th>data</th><th>parent</th><th>firstchild</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td><td>1</td></tr><tr><td>1</td><td>B</td><td>0</td><td>3</td></tr><tr><td>2</td><td>C</td><td>0</td><td>4</td></tr><tr><td>3</td><td>D</td><td>1</td><td>6</td></tr><tr><td>4</td><td>E</td><td>2</td><td>9</td></tr><tr><td>5</td><td>F</td><td>2</td><td>-1</td></tr><tr><td>6</td><td>G</td><td>3</td><td>-1</td></tr><tr><td>7</td><td>H</td><td>3</td><td>-1</td></tr><tr><td>8</td><td>I</td><td>3</td><td>-1</td></tr><tr><td>9</td><td>J</td><td>4</td><td>-1</td></tr></tbody></table><p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。<br>甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。</p><p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？<br>嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。<br>同样的，如果右兄弟不存在，则赋值为-1，如表所示。</p><table><thead><tr><th>下标</th><th>data</th><th>parent</th><th>rightsib</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td><td>2</td></tr><tr><td>2</td><td>C</td><td>0</td><td>-1</td></tr><tr><td>3</td><td>D</td><td>1</td><td>-1</td></tr><tr><td>4</td><td>E</td><td>2</td><td>5</td></tr><tr><td>5</td><td>F</td><td>2</td><td>-1</td></tr><tr><td>6</td><td>G</td><td>3</td><td>7</td></tr><tr><td>7</td><td>H</td><td>3</td><td>8</td></tr><tr><td>8</td><td>I</td><td>3</td><td>-1</td></tr><tr><td>9</td><td>J</td><td>4</td><td>-1</td></tr></tbody></table><p>但如果结点的孩子很多，超过了2个。<br>我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<br>存储结构的设计是一个非常灵活的过程。<br>一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。<br>注意也不是越多越好，有需要时再设计相应的结构。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>换一种完全不同的考虑方法。<br>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。<br>不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p><p>方案一：<br>一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值。<br><img src="/img/CSDataStructure/45.jpg"><br>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。<br>不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。</p><p>方案二：<br>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数。</p><p>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。<br><img src="/img/CSDataStructure/46.jpg"><br>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。</p><p>仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p><p>这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图所示。<br><img src="/img/CSDataStructure/47.jpg"></p><p>为此，设计两种结点结构，一个是孩子链表的孩子结点。<br>child  next<br>其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。</p><p>另一个是表头数组的表头结点。<br>data  firstchild<br>其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。</p><p>以下是我们的孩子表示法的结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的孩子表示法结构定义  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_TREE_SIZE  100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  孩子结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">CTNode</span>                            </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>  child;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">CTNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  表头结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType  data;</span><br><span class="line">ChildPtr  firstchild;</span><br><span class="line">&#125;  CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  树结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数组  */</span></span><br><span class="line">CTBox  nodes[MAX_TREE_SIZE];        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  根的位置和结点数  */</span></span><br><span class="line"><span class="keyword">int</span>  r,n;                                              </span><br><span class="line">&#125;  CTree;</span><br></pre></td></tr></table></figure><p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。<br><img src="/img/CSDataStructure/48.jpg"><br>我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。</p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结点的兄弟的角度考虑又会如何呢？<br>当然，对于树这样的层级结构来说，只研究结点的兄弟是不行的，我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><p>结点结构如下所示。<br>data  firstchild  rightsib</p><p>其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，right-sib是指针域，存储该结点的右兄弟结点的存储地址。</p><p>结构定义代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  树的孩子兄弟表示法结构定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">CSNode</span>  *<span class="title">firstchild</span>,  *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;  CSNode,  *CSTree;</span><br></pre></td></tr></table></figure><p><img src="/img/CSDataStructure/49.jpg"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。<br>当然，如果想找某个结点的双亲，这个表示法也是有缺陷的，那怎么办呢？<br>对，如果真的有必要，完全可以再增加一个parent指针域来解决快速查找双亲的问题，这里就不再细谈了。<br>其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。<br>如图所示。<br><img src="/img/CSDataStructure/50.jpg"></p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><h2 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h2><p>二叉树的特点有：<br>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。<br>注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。<br>左子树和右子树是有顺序的，次序不能任意颠倒。<br>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><p>二叉树具有五种基本形态：<br>1.空二叉树。<br>2.只有一个根结点。<br>3.根结点只有左子树。<br>4.根结点只有右子树。<br>5.根结点既有左子树又有右子树。</p><h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><p>1．斜树</p><p>顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。<br>斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。</p><p>其实线性表结构就可以理解为是树的一种极其特殊的表现形式。</p><p>2．满二叉树</p><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。<br>因此，满二叉树的特点有：<br>（1）叶子只能出现在最下一层。出现在其他层就不可能达成平衡。<br>（2）非叶子结点的度一定是2。<br>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。<br><img src="/img/CSDataStructure/51.jpg"></p><p>3．完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树，如图所示。<br><img src="/img/CSDataStructure/52.jpg"></p><p>这是一种有些理解难度的特殊二叉树。<br>首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。<br>其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。<br>这里有个关键词是按层序编号，像图中的树1，因为5结点没有左子树，却有右子树，那就使得按层序编号的第10个编号空档了。<br>同样道理，图中的树2，由于3结点没有子树，所以使得6、7编号的位置空档了。<br>图中的树3又是因为5编号下没有子树造成第10和第11位置空档。<br>只有上图中的树，尽管它不是满二叉树，但是编号是连续的，所以它是完全二叉树。<br><img src="/img/CSDataStructure/53.jpg"><br>从这里我也可以得出一些完全二叉树的特点：<br>（1）叶子结点只能出现在最下两层。<br>（2）最下层的叶子一定集中在左部连续位置。<br>（3）倒数二层，若有叶子结点，一定都在右部连续位置。<br>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。<br>（5）同样结点数的二叉树，完全二叉树的深度最小。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p><h3 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h3><p>性质1：在二叉树的第i层上至多有2i-1个结点（i≥1）。</p><p>第一层是根结点，只有一个，所以21-1=20=1。<br>第二层有两个，22-1=21=2。<br>第三层有四个，23-1=22=4。<br>第四层有八个，24-1=23=8。<br>通过数据归纳法的论证，可以很容易得出在二叉树的第i层上至多有2i-1个结点（i≥1）的结论。</p><h3 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h3><p>性质2：深度为k的二叉树至多有2k-1个结点（k≥1）。</p><p>注意这里一定要看清楚，是2k后再减去1，而不是2k-1。</p><p>深度为k意思就是有k层的二叉树，我们先来看看简单的。<br>如果有一层，至多1=21-1个结点。<br>如果有二层，至多1+2=3=22-1个结点。<br>如果有三层，至多1+2+4=7=23-1个结点。<br>如果有四层，至多1+2+4+8=15=24-1个结点。<br>通过数据归纳法的论证，可以得出，如果有k层，此二叉树至多有2k-1个结点。</p><h3 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h3><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</p><p>终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。<br>则树T结点总数n=n0+n1+n2。<br>如图的例子，结点总数为10，它是由A、B、C、D等度为2结点，F、G、H、I、J等度为0的叶子结点和E这个度为1的结点组成。总和为4+1+5=10。<br><img src="/img/CSDataStructure/54.jpg"><br>我们换个角度，再数一数它的连接线数，由于根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1。图中就是9个分支。对于A、B、C、D结点来说，它们都有两个分支线出去，而E结点只有一个分支线出去。所以总分支线为4×2+1×1=9。</p><p>用代数表达就是分支线总数=n-1=n1＋2n2。因为刚才我们有等式n=n0＋n1＋n2，所以可推导出n0＋n1＋n2-1=n1＋2n2。结论就是n0=n2＋1。</p><h3 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h3><p>性质4：具有n个结点的完全二叉树的深度为|log2n+1|。</p><p>由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。</p><p>完全二叉树我们前面已经提到，它是一棵具有n个结点的二叉树，若按层序编号后其编号与同样深度的满二叉树中编号结点在二叉树中位置完全相同，那它就是完全二叉树。<br>也就是说，它的叶子结点只会出现在最下面的两层。</p><p>它的结点数一定少于等于同样深度的满二叉树的结点数2k-1，但一定多于2k-1-1。即满足2k-1-1&lt;n≤2k-1。由于结点数n是整数，n≤2k-1意味着n&lt;2k，n&gt;2k-1-1，意味着n≥2k-1，所以2k-1≤n&lt;2k，不等式两边取对数，得到k-1≤log2n&lt;k，而k作为深度也是整数，因此k=|log2n|+1。</p><h3 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h3><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：<br>1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。<br>2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。<br>3．如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p><p>先来看看完全二叉树的顺序存储，一棵完全二叉树如图所示。<br><img src="/img/CSDataStructure/55.jpg"><br>将这棵二叉树存入到数组中，相应的下标对应其同样的位置，如图所示。<br><img src="/img/CSDataStructure/56.jpg"><br>由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。</p><p>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“∧”而已。如图，浅色结点表示不存在。<br><img src="/img/CSDataStructure/57.jpg"></p><p>考虑一种极端的情况，一棵深度为k的右斜树，它只有k个结点，却需要分配2k-1个存储单元空间，这显然是对存储空间的浪费，如图所示。所以，顺序存储结构一般只用于完全二叉树。<br><img src="/img/CSDataStructure/58.jpg"></p><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>既然顺序存储适用性不强，我们就要考虑链式存储结构。<br>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p><p>结点结构如下。<br>lchild  data  rchild<br>其中data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。</p><p>以下是我们的二叉链表的结点结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉链表结点结构定义  */</span></span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>                                 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数据  */</span></span><br><span class="line">TElemType  data;                                         </span><br><span class="line"><span class="comment">/*  左右孩子指针  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span>        </span><br><span class="line">&#125;  BiTNode,  *BiTree;</span><br></pre></td></tr></table></figure><p><img src="/img/CSDataStructure/59.jpg"><br>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。</p><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h2 id="二叉树遍历原理"><a href="#二叉树遍历原理" class="headerlink" title="二叉树遍历原理"></a>二叉树遍历原理</h2><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><p>二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。<br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。</p><h2 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如图所示，遍历的顺序为：ABDGH-CEIF。<br><img src="/img/CSDataStructure/60.jpg"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图所示，遍历的顺序为：GDHBAE-ICF。<br><img src="/img/CSDataStructure/61.jpg"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图所示，遍历的顺序为：GHDBIEFCA。<br><img src="/img/CSDataStructure/62.jpg"></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图所示，遍历的顺序为：ABCDEFGHI。<br><img src="/img/CSDataStructure/63.jpg"></p><p>不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种处理。</p><h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的前序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PreOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                    </span><br><span class="line"><span class="comment">/*  再先序遍历左子树  */</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild);        </span><br><span class="line"><span class="comment">/*  最后先序遍历右子树  */</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们现在有如图这样一棵二叉树T。这树已经用二叉链表结构存储在内存当中。<br><img src="/img/CSDataStructure/64.jpg"><br>那么当调用PreOrderTraverse(T)函数时，我们来看看程序是如何运行的。<br>1．调用PreOrderTraverse(T)，T根结点不为null，所以执行printf，打印字母A，如图所示。<br><img src="/img/CSDataStructure/65.jpg"><br>2．调用PreOrderTraverse(T-&gt;lchild);访问了A结点的左孩子，不为null，执行printf显示字母B，如图所示。<br><img src="/img/CSDataStructure/66.jpg"><br>3．此时再次递归调用PreOrderTraverse(T-&gt;lchild);访问了B结点的左孩子，执行printf显示字母D，如图所示。<br><img src="/img/CSDataStructure/67.jpg"><br>4．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了D结点的左孩子，执行printf显示字母H，如图所示。<br><img src="/img/CSDataStructure/68.jpg"><br>5．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了H结点的左孩子，此时因为H结点无左孩子，所以T==null，返回此函数，此时递归调用PreOrderTraverse(T-&gt;rchild);访问了H结点的右孩子，printf显示字母K，如图所示。<br><img src="/img/CSDataStructure/69.jpg"><br>6．再次递归调用PreOrderTraverse(T-&gt;lchild);访问了K结点的左孩子，K结点无左孩子，返回，调用PreOrderTra-verse(T-&gt;rchild);访问了K结点的右孩子，也是null，返回。于是此函数执行完毕，返回到上一级递归的函数（即打印H结点时的函数），也执行完毕，返回到打印结点D时的函数，调用PreOrderTraverse(T-&gt;rchild);访问了D结点的右孩子，不存在，返回到B结点，调用PreOrderTra-verse(T-&gt;rchild);找到了结点E，打印字母E，如图所示。<br><img src="/img/CSDataStructure/70.jpg"><br>7．由于结点E没有左右孩子，返回打印结点B时的递归函数，递归执行完毕，返回到最初的PreOrderTraverse，调用PreOrderTra-verse(T-&gt;rchild);访问结点A的右孩子，打印字母C，如图所示。<br><img src="/img/CSDataStructure/71.jpg"><br>8．之后类似前面的递归调用，依次继续打印F、I、G、J，步骤略。</p><p>综上，前序遍历这棵二叉树的节点顺序是：AB-DHKECFIGJ。</p><h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的中序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*  中序遍历左子树  */</span></span><br><span class="line">InOrderTraverse(T-&gt;lchild);        </span><br><span class="line"><span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                  </span><br><span class="line"><span class="comment">/*  最后中序遍历右子树  */</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看当调用InOrder-Traverse(T)函数时，程序是如何运行的。</p><p>1．调用InOrderTraverse(T)，T的根结点不为null，于是调用InOrderTraverse(T-&gt;lchild);访问结点B。当前指针不为null，继续调用InOrderTraverse(T-&gt;lchild);访问结点D。不为null，继续调用InOrderTraverse(T-&gt;lchild);访问结点H。继续调用InOrderTraverse(T-&gt;lchild);访问结点H的左孩子，发现当前指针为null，于是返回。打印当前结点H，如图所示。<br><img src="/img/CSDataStructure/72.jpg"><br>2．然后调用InOrderTraverse(T-&gt;rchild);访问结点H的右孩子K，因结点K无左孩子，所以打印K，如图所示。<br><img src="/img/CSDataStructure/73.jpg"><br>3．因为结点K没有右孩子，所以返回。打印结点H函数执行完毕，返回。打印字母D，如图所示。<br><img src="/img/CSDataStructure/74.jpg"><br>4．结点D无右孩子，此函数执行完毕，返回。打印字母B，如图所示。<br><img src="/img/CSDataStructure/75.jpg"><br>5．调用InOrderTraverse(T-&gt;rchild);访问结点B的右孩子E，因结点E无左孩子，所以打印E，如图所示。<br><img src="/img/CSDataStructure/76.jpg"><br>6．结点E无右孩子，返回。结点B的递归函数执行完毕，返回到了最初我们调用In-OrderTraverse的地方，打印字母A，如图所示。<br><img src="/img/CSDataStructure/77.jpg"><br>7．再调用InOrderTraverse(T-&gt;rchild);访问结点A的右孩子C，再递归访问结点C的左孩子F，结点F的左孩子I。因为I无左孩子，打印I，之后分别打印F、C、G、J。步骤省略。</p><p>综上，中序遍历这棵二叉树的节点顺序是：HKDBEAIFCGJ。</p><h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的后序遍历递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PostOrderTraverse</span><span class="params">(BiTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (T  ==  <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*  先后序遍历左子树  */</span></span><br><span class="line">PostOrderTraverse(T-&gt;lchild);        </span><br><span class="line"><span class="comment">/*  再后序遍历右子树  */</span>PostOrderTraverse(T-&gt;rchild);        </span><br><span class="line"><span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  T-&gt;data);                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示，后序遍历是先递归左子树，由根结点A→B→D→H，结点H无左孩子，再查看结点H的右孩子K，因为结点K无左右孩子，所以打印K，返回。<br><img src="/img/CSDataStructure/78.jpg"><br>最终，后序遍历的结点的顺序就是：KHDEB-IFJGCA。</p><h2 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h2><p>有一种题目为了考查你对二叉树遍历的掌握程度，是这样出题的。<br>已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，请问这棵二叉树的后序遍历结果是多少？</p><p>三种遍历都是从根结点开始，前序遍历是先打印再递归左和右。所以前序遍历序列为ABCDEF，第一个字母是A被打印出来，就说明A是根结点的数据。</p><p>再由中序遍历序列是CBAEDF，可以知道C和B是A的左子树的结点，E、D、F是A的右子树的结点，如图所示。<br><img src="/img/CSDataStructure/79.jpg"></p><p>然后我们看前序中的C和B，它的顺序是ABCDEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定。<br>再看中序序列是CBAEDF，C是在B的前面打印，这就说明C是B的左孩子，否则就是右孩子了，如图所示。<br><img src="/img/CSDataStructure/80.jpg"></p><p>再看前序中的E、D、F，它的顺序是ABCDEF，那就意味着D是A结点的右孩子，E和F是D的子孙，注意，它们中有一个不一定是孩子，还有可能是孙子的。再来看中序序列是CBAEDF，由于E在D的左侧，而F在右侧，所以可以确定E是D的左孩子，F是D的右孩子。因此最终得到的二叉树如图所示。<br><img src="/img/CSDataStructure/81.jpg"></p><p>从这里我们也得到两个二叉树遍历的性质：<br>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。<br>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</p><h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  按前序输入二叉树中结点的值（一个字符）  */</span></span><br><span class="line"><span class="comment">/*  #表示空树，构造二叉链表表示二叉树T。  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateBiTree</span><span class="params">(BiTree  *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TElemType  ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,  &amp;ch);</span><br><span class="line"><span class="keyword">if</span>  (ch  ==  <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*T  =  <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*T  =  (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="keyword">if</span>  (!*T)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="comment">/*  生成根结点  */</span></span><br><span class="line">(*T)-&gt;data  =  ch;                             </span><br><span class="line"><span class="comment">/*  构造左子树  */</span></span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;lchild);        </span><br><span class="line"><span class="comment">/*  构造右子树  */</span></span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;rchild);        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h3><p>对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线数，也就是说，其实是存在2n-(n-1)=n＋1个空指针域。<br>这些空间不存储任何事物，白白的浪费着内存的资源。</p><p>在二叉链表上，我们只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。<br>要想知道，必须遍历一次。以后每次需要知道时，都必须先遍历一次。为什么不考虑在创建时就记住这些前驱和后继呢，那将是多大的时间上的节省。</p><p>综合刚才两个角度的分析后，我们可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址。</p><p>我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p><p>如图，我们把这棵二叉树进行中序遍历后，将所有的空指针域中的rchild，改为指向它的后继结点。于是我们就可以通过指针知道H的后继是D（图中①），I的后继是B（图中②），J的后继是E（图中③），E的后继是A（图中④），F的后继是C（图中⑤），G的后继因为不存在而指向NULL（图中⑥）。此时共有6个空指针域被利用。<br><img src="/img/CSDataStructure/82.jpg"></p><p>再看图，我们将这棵二叉树的所有空指针域中的lchild，改为指向当前结点的前驱。因此H的前驱是NULL（图中①），I的前驱是D（图中②），J的前驱是B（图中③），F的前驱是A（图中④），G的前驱是C（图中⑤）。一共5个空指针域被利用，正好和上面的后继加起来是11个。<br><img src="/img/CSDataStructure/83.jpg"></p><p>通过下图（空心箭头实线为前驱，虚线黑箭头为后继），就更容易看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。<br><img src="/img/CSDataStructure/84.jpg"></p><p>不过好事总是多磨的，问题并没有彻底解决。<br>我们如何知道某一结点的lchild是指向它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？<br>比如E结点的lchild是指向它的左孩子J，而rchild却是指向它的后继A。<br>显然我们在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继上是需要一个区分标志的。<br>因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。</p><p>其中：<br>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。<br>rtag为0时指向该结点的右孩子，为1时指向该结点的后继。<br>因此对于此前的二叉链表图可以修改为下图的样子。<br><img src="/img/CSDataStructure/85.jpg"></p><h3 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h3><p>二叉树的线索存储结构定义代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉线索存储结构定义  */</span></span><br><span class="line"><span class="comment">/*  Link==0表示指向左右孩子指针  */</span></span><br><span class="line"><span class="comment">/*  Thread==1表示指向前驱或后继的线索  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">enum</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Link,  </span><br><span class="line">Thread,</span><br><span class="line">&#125;  PointerTag;        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  二叉线索存储结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiThrNode</span>                                     </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数据  */</span></span><br><span class="line">TElemType  data;                                               </span><br><span class="line"><span class="comment">/*  左右孩子指针  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">BiThrNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="comment">/*  左右标志  */</span>         </span><br><span class="line">PointerTag  LTag;</span><br><span class="line">PointerTag  RTag;                                             </span><br><span class="line"> &#125;  BiThrNode,  *BiThrTree;</span><br></pre></td></tr></table></figure><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p><p>中序遍历线索化的递归函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  全局变量，始终指向刚刚访问过的结点  */</span></span><br><span class="line">BiThrTree  pre;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  中序遍历进行中序线索化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InThreading</span><span class="params">(BiThrTree  p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  递归左子树线索化  */</span></span><br><span class="line">InThreading(p-&gt;lchild);        </span><br><span class="line"><span class="comment">/*  没有左孩子  */</span></span><br><span class="line"><span class="keyword">if</span>  (!p-&gt;lchild)                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  前驱线索  */</span></span><br><span class="line">p-&gt;LTag  =  Thread;            </span><br><span class="line"><span class="comment">/*  左孩子指针指向前驱  */</span></span><br><span class="line">p-&gt;lchild  =  pre;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  前驱没有右孩子  */</span></span><br><span class="line"><span class="keyword">if</span>  (!pre-&gt;rchild)                    </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  后继线索  */</span></span><br><span class="line">pre-&gt;RTag  =  Thread;        </span><br><span class="line"><span class="comment">/*  前驱右孩子指针指向后继（当前结点p）  */</span></span><br><span class="line">pre-&gt;rchild  =  p;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  保持pre指向p的前驱  */</span></span><br><span class="line">pre  =  p;                                      </span><br><span class="line"><span class="comment">/*  递归右子树线索化  */</span></span><br><span class="line">InThreading(p-&gt;rchild);        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if(!p-&gt;lchild)表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lchild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。</p><p>后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线索化。</p><p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。</p><p>和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。<br>反之，令二叉树的中序序列中的第一个结点中，lchild域指针和最后一个结点的rchild域指针均指向头结点（图中的③和④）。<br>这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br><img src="/img/CSDataStructure/86.jpg"></p><p>遍历的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的  */</span></span><br><span class="line"><span class="comment">/*  最后一个结点。中序遍历二叉线索链表表示的二叉树T  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree  T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiThrTree  p;</span><br><span class="line"><span class="comment">/*  p指向根结点  */</span></span><br><span class="line">p  =  T-&gt;lchild;                                  </span><br><span class="line"><span class="comment">/*  空树或遍历结束时，p==T  */</span></span><br><span class="line"><span class="keyword">while</span>  (p  !=  T)                                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  当LTag==0时循环到中序序列第一个结点  */</span></span><br><span class="line"><span class="keyword">while</span>  (p-&gt;LTag  ==  Link)        p  =  p-&gt;lchild;</span><br><span class="line"><span class="comment">/*  显示结点数据，可以更改为其他对结点操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  p-&gt;data);          </span><br><span class="line"><span class="keyword">while</span>  (p-&gt;RTag  ==  Thread  &amp;&amp;  p-&gt;rchild  !=  T)</span><br><span class="line">&#123;</span><br><span class="line">p  =  p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,  p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  p进至其右子树根  */</span></span><br><span class="line">p  =  p-&gt;rchild;                          </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>1.代码中，第4行，p=T-&gt;lchild;意思就是图中的①，让p指向根结点开始遍历。</p><p>2.第5～16行，while(p!=T)其实意思就是循环直到图中的④的出现，此时意味着p指向了头结点，于是与T相等（T是指向头结点的指针），结束循环，否则一直循环下去进行遍历操作。</p><p>3.第7～8行，while(p-&gt;LTag==Link)这个循环，就是由A→B→D→H，此时H结点的LTag不是Link（就是不等于0），所以结束此循环。</p><p>4.第9行，打印H。</p><p>5.第10～14行，while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)，由于结点H的RTag==Thread（就是等于1），且不是指向头结点。因此打印H的后继D，之后因为D的RTag是Link，因此退出循环。</p><p>6.第15行，p=p-&gt;rchild;意味着p指向了结点D的右孩子I。</p><p>7.……，就这样不断循环遍历，直到打印出HDIBJEAFCG，结束遍历操作。</p><p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。</p><p>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。<br>所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p>我们前面已经讲过了树的定义和存储结构，对于树来说，在满足树的条件下可以是任意形状，一个结点可以有任意多个孩子，显然对树的处理要复杂得多，去研究关于树的性质和算法，真的不容易。有没有简单的办法解决对树处理的难题呢？</p><p>我们前面也讲了二叉树，尽管它也是树，但由于每个结点最多只能有左孩子和右孩子，面对的变化就少很多了。因此很多性质和算法都被研究了出来。如果所有的树都像二叉树一样方便就好了。你还别说，真是可以这样做。</p><p>在讲树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的二叉链表也是相同的，只是解释不太一样而已。因此，只要我们设定一定的规则，用二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。<br>我们分别来看看它们之间的转换如何进行。</p><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将树转换为二叉树的步骤如下 ：<br>1.加线。在所有兄弟结点之间加一条连线。<br>2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。<br>3.层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><img src="/img/CSDataStructure/87.jpg"></p><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。<br>步骤如下：<br>1.把每个树转换为二叉树。<br>2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。<br>当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</p><p>如图，将森林的三棵树转化为一棵二叉树。<br><img src="/img/CSDataStructure/88.jpg"></p><h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。<br>如图所示。步骤如下：<br>1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。<br>2.去线。删除原二叉树中所有结点与其右孩子结点的连线。<br>3.层次调整。使之结构层次分明。<br><img src="/img/CSDataStructure/89.jpg"></p><h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>那么如果是转换成森林，步骤如下：<br>1.从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。<br>2.再将每棵分离后的二叉树转换为树即可。<br><img src="/img/CSDataStructure/90.jpg"></p><h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历分为两种方式：<br>1.一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。<br>2.另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。<br>比如图【二叉树转换为树】中右下方的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</p><p>森林的遍历也分为两种方式：<br>1.前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图【二叉树转换为森林】下面三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。<br>2.后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图【二叉树转换为森林】下面三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</p><p>可如果我们对图【二叉树转换为森林】的左侧二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p><p>这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。<br>这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。</p><h2 id="赫夫曼数及其应用"><a href="#赫夫曼数及其应用" class="headerlink" title="赫夫曼数及其应用"></a>赫夫曼数及其应用</h2><p>压缩而不出错是如何做到的呢？<br>简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。<br>尽管现在最新技术在编码上已经很好很强大，但这一切都来自于曾经的技术积累，我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。</p><h3 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h3><p>我们先把这两棵二叉树简化成叶子结点带权的二叉树（注：树结点间的边相关的数叫做权Weight），如图所示。<br>其中A表示不及格、B表示及格、C表示中等、D表示良好、E表示优秀。<br>每个叶子的分支线上的数字就是刚才我们提到的五级分制的成绩所占百分比。<br><img src="/img/CSDataStructure/91.jpg"><br>赫夫曼大叔说，从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。<br>    二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到结点D的路径长度为2。</p><p>树的路径长度就是从树根到每一结点的路径长度之和。<br>    二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16。</p><p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。<br>树的带权路径长度为树中所有叶子结点的带权路径长度之和。</p><p>假设有n个权值{w1,w2,…,wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称做赫夫曼树。</p><p>有了赫夫曼对带权路径长度的定义，我们来计算一下图中这两棵树的WPL值。<br>    二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>    注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>    二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>这样的结果意味着什么呢？<br>如果我们现在有10000个学生的百分制成绩需要计算五级分制成绩，用二叉树a的判断方法，需要做31500次比较，而二叉树b的判断方法，只需要22000次比较，差不多少了三分之一量，在性能上提高不是一点点。</p><p>那么现在的问题就是，图中的二叉树b这样的树是如何构造出来的，这样的二叉树是不是就是最优的赫夫曼树呢？<br>别急，赫夫曼大叔给了我们解决的办法。</p><ul><li>1．先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li><li>2．取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图所示。新结点的权值为两个叶子权值的和5+10=15。<br><img src="/img/CSDataStructure/92.jpg"></li><li>3．将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B 15，D 30，C 40。</li><li>4．重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图所示。N2的权值=15+15=30。<br><img src="/img/CSDataStructure/93.jpg"></li><li>5．将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N230，D30，C40。</li><li>6．重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图所示。N3的权值=30+30=60。<br><img src="/img/CSDataStructure/94.jpg"></li><li>7．将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N360。</li><li>8．重复步骤2。将C与N3作为一个新节点T的两个子结点，如图所示。由于T即是根结点，完成赫夫曼树的构造。<br><img src="/img/CSDataStructure/95.jpg"></li></ul><p>此时的图二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与之前的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。</p><p>不过现实总是比理想要复杂得多，图虽然是赫夫曼树，但由于每次判断都要两次比较（如根结点就是a&lt;80&amp;&amp;a&gt;=70，两次比较才能得到y或n的结果），所以总体性能上，反而不如图的二叉树性能高。当然这并不是我们要讨论的重点了。</p><p>通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p><ul><li>1.根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F={T1,T2,…,Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li><li>2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>3.在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>4.重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。<h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3>赫夫曼研究这种最优树的目的不是为了我们可以转化一下成绩。他的更大目的是为了解决当年远距离通信（主要是电报）的数据传输的最优化问题。</li></ul><p>比如我们有一段文字内容为“BADCADFEED”要网络传输给别人，显然用二进制的数字（0和1）来表示是很自然的想法。我们现在这段文字只有六个字母ABCDEF，那么我们可以用相应的二进制数据表示，如表所示。<br><img src="/img/CSDataStructure/96.jpg"><br>这样真正传输的数据就是编码后的“001000011010000011101100100011”，对方接收时可以按照3位一分来译码。<br>如果一篇文章很长，这样的二进制串也将非常的可怕。<br>而且事实上，不管是英文、中文或是其他语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母“ae i o u”，中文中的“的 了 有 在”等汉字都是频率极高。<br>假设六个字母的频率为A 27，B 8，C 15，D15，E 30，F 5，合起来正好是100%。<br>那就意味着，我们完全可以重新按照赫夫曼树来规划它们。</p><p><img src="/img/CSDataStructure/97.jpg"><br>左图为构造赫夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的赫夫曼树。</p><p><img src="/img/CSDataStructure/98.jpg"><br>此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如表所示这样的定义。</p><p>我们将文字内容为“BADCADFEED”再次编码，对比可以看到结果串变小了。<br>原编码二进制串：001000011010000011101100100011（共30个字符）<br>新编码二进制串：1001010010101001000111100（共25个字符）</p><p>也就是说，我们的数据被压缩了，节约了大约17%的存储或传输成本。随着字符的增加和多字符权重的不同，这种压缩会更加显出其优势。<br>当我们接收到1001010010101001000111100这样压缩过的新编码时，我们应该如何把它解码出来呢？</p><p>编码中非0即1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。<br>你仔细观察就会发现，上表中的编码就不存在容易与1001、1000混淆的“10”和“100”编码。</p><p>可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。</p><p>当我们接收到1001010010101001000111100时，由约定好的赫夫曼树可知，1001得到第一个字母是B，接下来01意味着第二个字符是A，如图6-12-10所示，其余的也相应的可以得到，从而成功解码。<br><img src="/img/CSDataStructure/99.jpg"><br>一般地，设需要编码的字符集为{d1,d2,…,dn}，各个字符在电文中出现的次数或频率集合为{w1,w2,…,wn}，以d1,d2,…,dn作为叶子结点，以w1,w2,…,wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p><h1 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h1><p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。<br>即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>开头我们提到了树的定义，讲到了递归在树定义中的应用。<br>提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>二叉树的建立自然也是可以通过递归来实现。<br>研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-6-树&quot;&gt;&lt;a href=&quot;#Chapter-6-树&quot; class=&quot;headerlink&quot; title=&quot;Chapter 6 树&quot;&gt;&lt;/a&gt;Chapter 6 树&lt;/h1&gt;&lt;p&gt;树：&lt;br&gt;    树（Tree）是n（n≥0）个结点的有限集。&lt;b</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="树" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E6%A0%91/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（查找）</title>
    <link href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure5(%E6%9F%A5%E6%89%BE)/"/>
    <id>https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure5(%E6%9F%A5%E6%89%BE)/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-21T14:54:59.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><h2 id="查找概述"><a href="#查找概述" class="headerlink" title="查找概述"></a>查找概述</h2><p>所有这些需要被查的数据所在的集合，我们给它一个统称叫查找表。<br>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。</p><p>关键字（Key）是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。<br>也可以标识一个记录的某个数据项（字段），我们称为关键码。</p><p>若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）。<br>注意这也就意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码。</p><p>那么对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（SecondaryKey），如图8-2-1中⑤所示。次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是次关键码。</p><p>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。<br>若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，或指示该记录在查找表中的位置。<br>若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。</p><p>查找表按照操作方式来分有两大种：静态查找表和动态查找表。<br>静态查找表（Static Search Table）：只作查找操作的查找表。它的主要操作有：（1）查询某个“特定的”数据元素是否在查找表中。（2）检索某个“特定的”数据元素和各种属性。<br>动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：（1）查找时插入数据元素。（2）查找时删除数据元素。</p><p>为了提高查找的效率，我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为查找结构。<br>从逻辑上来说，查找所基于的数据结构是集合，集合中的记录之间没有本质关系。可是要想获得较高的查找性能，我们就不能不改变数据元素之间的关系，在存储时可以将查找集合组织成表、树等结构。<br>例如，对于静态查找表来说，我们不妨应用线性表结构来组织数据，这样可以使用顺序查找算法，如果再对主关键字排序，则可以应用折半查找等技术进行高效的查找。<br>如果是需要动态查找，则会复杂一些，可以考虑二叉排序树的查找技术。<br>另外，还可以用散列表结构来解决一些查找问题，这些技术都将在后面的讲解中说明。</p><h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><p>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p><h3 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  顺序查找，a为数组，n为要查找的数组长度，key为要查找的关键字  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span>  *a,  <span class="keyword">int</span>  n,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;=  n;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (a[i]  ==  key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单，就是在数组a（注意元素值从下标1开始）中查看有没有关键字（key），当你需要查找复杂表结构的记录时，只需要把数组a与关键字key定义成你需要的表结构和数据类型即可。</p><h3 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h3><p>到这里并非足够完美，因为每次循环时都需要对i是否越界，即是否小于等于n作判断。事实上，还可以有更好一点的办法，设置一个哨兵，可以解决不需要每次让i与n作比较。看下面的改进后的顺序查找算法代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  有哨兵顺序查找  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span>  *a,  <span class="keyword">int</span>  n,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="comment">/*  设置a[0]为关键字值，我们称之为“哨兵”  */</span></span><br><span class="line">a[<span class="number">0</span>]  =  key;        </span><br><span class="line"><span class="comment">/*  循环从数组尾部开始  */</span></span><br><span class="line">i  =  n;                  </span><br><span class="line"><span class="keyword">while</span>  (a[i]  !=  key)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  返回0则说明查找失败  */</span></span><br><span class="line"><span class="keyword">return</span>  i;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时代码是从尾部开始查找，由于a[0]=key，也就是说，如果在a[i]中有key则返回i值，查找成功。否则一定在最终的a[0]处等于key，此时返回的是0，即说明a[1]～a[n]中没有关键字key，查找失败。</p><p>这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，“哨兵”也不一定就一定要在数组开始，也可以在末端。</p><p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法时间复杂度为O(1)，最坏的情况是在最后一位置才找到，需要n次比较，时间复杂度为O(n)，当查找不成功时，需要n+1次比较，时间复杂度为O(n)。我们之前推导过，关键字在任何一位置的概率是相同的，所以平均查找次数为(n+1)/2，所以最终时间复杂度还是O(n)。</p><p>很显然，顺序查找技术是有很大缺点的，n很大时，查找效率极为低下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。</p><p>另外，也正由于查找概率的不同，我们完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。</p><h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>折半查找（Binary Search）技术，又称为二分查找。<br>它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。</p><p>折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p><p>假设我们现在有这样一个有序表数组{0,1,16,24,35,47,59,62,73,88,99}，除0下标外共10个数字。对它进行查找是否存在62这个数。我们来看折半查找的算法是如何工作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  折半查找  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span>  *a,  <span class="keyword">int</span>  n,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  low,  high,  mid;</span><br><span class="line"><span class="comment">/*  定义最低下标为记录首位  */</span></span><br><span class="line">low  =  <span class="number">1</span>;                                              </span><br><span class="line"><span class="comment">/*  定义最高下标为记录末位  */</span></span><br><span class="line">high  =  n;                                            </span><br><span class="line"><span class="keyword">while</span>  (low  &lt;=  high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  折半  */</span></span><br><span class="line">mid  =  (low  +  high)  /  <span class="number">2</span>;        </span><br><span class="line"><span class="comment">/*  若查找值比中值小  */</span></span><br><span class="line"><span class="keyword">if</span>  (key  &lt;  a[mid])                    </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  最高下标调整到中位下标小一位  */</span></span><br><span class="line">high  =  mid  -  <span class="number">1</span>;</span><br><span class="line">&#125;                </span><br><span class="line"><span class="comment">/*  若查找值比中值大  */</span></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  &gt;  a[mid])          </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  最低下标调整到中位下标大一位  */</span></span><br><span class="line">low  =  mid  +  <span class="number">1</span>;</span><br><span class="line">&#125;                  </span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  若相等则说明mid即为查找到的位置  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  mid;</span><br><span class="line">&#125;                        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，参数a={0,1,16,24,35,47,59,62,73,88,99}，n=10，key=62，第3～5行，此时low=1，high=10。</p><p>2．<br>第6～15行循环，进行查找。</p><p>3．<br>第8行，mid计算得5，由于a[5]=47&lt;key，所以执行了第12行，low=5+1=6.</p><p>4．<br>再次循环，mid=(6+10)/2=8，此时a[8]=73&gt;key，所以执行第10行，high=8-1=7。</p><p>5．<br>再次循环，mid=(6+7)/2=6，此时a[6]=59&lt;key，所以执行12行，low=6+1=7。</p><p>6．<br>再次循环，mid=(7+7)/2=7，此时a[7]=62=key，查找成功，返回7。</p><p>该算法还是比较容易理解的，同时我们也能感觉到它的效率非常高。但到底高多少？关键在于此算法的时间复杂度分析。</p><p>首先，我们将这个数组的查找过程绘制成一棵二叉树，如图所示，从图上就可以理解，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据记录即可，等于工作量少了一半，然后继续折半查找，效率当然是非常高了。<br><img src="/img/CSDataStructure/160.jpg"><br>我们之前6.6节讲的二叉树的性质4，有过对“具有n个结点的完全二叉树的深度为「log2n」+1。”性质的推导过程。在这里尽管折半查找判定二叉树并不是完全二叉树，但同样相同的推导可以得出，最坏情况是查找到关键字或查找失败的次数为「log2n」+1。<br>有人还在问最好的情况？那还用说吗，当然是1次了。<br>因此最终我们折半算法的时间复杂度为O(logn)，它显然远远好于顺序查找的O(n)时间复杂度了。</p><p>不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p>现在我们的新问题是，为什么一定要折半，而不是折四分之一或者折更多呢？</p><p>看来，我们的折半查找，还是有改进空间的。</p><p>折半查找代码的第8句，我们略微等式变换后得到：<br><img src="/img/CSDataStructure/161.jpg"><br>也就是mid等于最低下标low加上最高下标high与low的差的一半。<br>算法科学家们考虑的就是将这个1/2进行改进，改进为下面的计算方案：<br><img src="/img/CSDataStructure/162.jpg"><br>将1/2改成了(key-a[low])/(a[high]-a[low])有什么道理呢？</p><p>假设a[11]={0,1,16,24,35,47,59,62,73,88,99}，low=1，high=10，则a[low]=1，a[high]=99，如果我们要找的是key=16时，按原来折半的做法，我们需要四次才可以得到结果，但如果用新办法，(key-a[low])/(a[high]-a[low])=(16-1)/(99-1)≈0.153，即mid≈1+0.153×(10-1)=2.377取整得到mid=2，我们只需要二次就查找到结果了，显然大大提高了查找的效率。</p><p>换句话说，我们只需要在折半查找算法的代码中更改一下第8行代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid=low+  (high-low)*(key-a[low])/(a[high]-a[low]);  <span class="comment">/*  插值  */</span></span><br></pre></td></tr></table></figure><p>就得到了另一种有序表查找算法，插值查找法。<br>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]-a[low])。<br>应该说，从时间复杂度来看，它也是O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。<br>反之，数组中如果分布类似{0,1,2,2000,2001,……,999998,999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。</p><h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p>还有没有其他办法？我们折半查找是从中间分，也就是说，每一次查找总是一分为二，无论数据偏大还是偏小，很多时候这都未必就是最合理的做法。<br>除了插值查找，我们再介绍一种有序查找，斐波那契查找（Fibonacci Search），它是利用了黄金分割原理来实现的。</p><p>为了能够介绍清楚这个查找算法，我们先需要有一个斐波那契数列的数组，如图所示。<br><img src="/img/CSDataStructure/163.jpg"><br>下面我们根据代码来看程序是如何运行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  斐波那契查找  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span>  *a,  <span class="keyword">int</span>  n,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  low,  high,  mid,  i,  k;</span><br><span class="line"><span class="comment">/*定义最低下标为记录首位  */</span>low  =  <span class="number">1</span>;                                                    </span><br><span class="line"><span class="comment">/*定义最高下标为记录末位  */</span>high  =  n;                                                  </span><br><span class="line">k  =  <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*  计算n位于斐波那契数列的位置  */</span></span><br><span class="line"><span class="keyword">while</span>  (n  &gt;  F[k]  -  <span class="number">1</span>)                            </span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将不满的数值补全  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  n;  i  &lt;  F[k]  -  <span class="number">1</span>;  i++)        </span><br><span class="line">&#123;</span><br><span class="line">a[i]  =  a[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  (low  &lt;=  high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  计算当前分隔的下标  */</span></span><br><span class="line">mid  =  low  +  F[k  -  <span class="number">1</span>]  -  <span class="number">1</span>;          </span><br><span class="line"><span class="comment">/*  若查找记录小于当前分隔记录  */</span></span><br><span class="line"><span class="keyword">if</span>  (key  &lt;  a[mid]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  最高下标调整到分隔下标mid-1处  */</span></span><br><span class="line">high  =  mid  -  <span class="number">1</span>;                      </span><br><span class="line"><span class="comment">/*  斐波那契数列下标减一位  */</span></span><br><span class="line">k  =  k  -  <span class="number">1</span>;                                </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  若查找记录大于当前分隔记录  */</span></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  &gt;  a[mid])                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  最低下标调整到分隔下标mid+1处  */</span></span><br><span class="line">low  =  mid  +  <span class="number">1</span>;                        </span><br><span class="line"><span class="comment">/*  斐波那契数列下标减两位  */</span></span><br><span class="line">k  =  k  -  <span class="number">2</span>;                                </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (mid  &lt;=  n)<span class="comment">/*  若相等则说明mid即为查找到的位置  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  mid;</span><br><span class="line">&#125;                      </span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  若mid&gt;n说明是补全数值，返回n  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  n;</span><br><span class="line">&#125;                          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，参数a={0,1,16,24,35,47,59,62,73,88,99}，n=10，要查找的关键字key=59。<br>注意此时我们已经有了事先计算好的全局变量数组F的具体数据，它是斐波那契数列，F={0,1,1,2,3,5,8,13,21,……}。<br><img src="/img/CSDataStructure/164.jpg"></p><p>2．<br>第6～8行是计算当前的n处于斐波那契数列的位置。现在n=10，F[6]&lt;n&lt;F[7]，所以计算得出k=7。</p><p>3．<br>第9～10行，由于k=7，计算时是以F[7]=13为基础，而a中最大的仅是a[10]，后面的a[11]，a[12]均未赋值，这不能构成有序数列，因此将它们都赋值为最大的数组值，所以此时a[11]=a[12]=a[10]=99（此段代码作用后面还有解释）。</p><p>4．<br>第11～31行查找正式开始。</p><p>5．<br>第13行，mid=1＋F[7-1]-1=8，也就是说，我们第一个要对比的数值是从下标为8开始的。</p><p>6．<br>由于此时key=59而a[8]=73，因此执行第16～17行，得到high=7，k=6。</p><p>7．<br>再次循环，mid=1＋F[6-1]-1=5。此时a[5]=47&lt;key，因此执行第21～22行，得到low=6，k=6-2=4。注意此时k下调2个单位。<br><img src="/img/CSDataStructure/165.jpg"></p><p>8．<br>再次循环，mid=6＋F[4-1]-1=7。此时a[7]=62&gt;key，因此执行第16～17行，得到high=6，k=4-1=3。<br><img src="/img/CSDataStructure/166.jpg"></p><p>9．<br>再次循环，mid=6＋F[3-1]-1=6。此时a[6]=59=key，因此执行第26～27行，得到返回值为6。程序运行结束。</p><p>如果key=99，此时查找循环第一次时，mid=8与上例是相同的，第二次循环时，mid=11，如果a[11]没有值就会使得与key的比较失败，为了避免这样的情况出现，第9～10行的代码就起到这样的作用。</p><p>斐波那契查找算法的核心在于：<br>1）当key=a[mid]时，查找就成功；<br>2）当key&lt;a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；<br>3）当key&gt;a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。<br><img src="/img/CSDataStructure/167.jpg"></p><p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。<br>所以尽管斐波那契查找的时间复杂也为O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。<br>可惜如果是最坏情况，比如这里key=1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。</p><p>还有比较关键的一点，折半查找是进行加法与除法运算（mid=(low＋high)/2），插值查找进行复杂的四则运算（mid=low＋(high-low)*(key-a[low])/(a[high]-a[low])），而斐波那契查找只是最简单加减法运算（mid=low＋F[k-1]-1），在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p><p>应该说，三种有序表的查找本质上是分隔点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做出选择。</p><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><p>我们前面讲的几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，如图所示，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据通常都是按先后顺序存储。</p><p>那么对于这样的查找表，我们如何能够快速查找到需要的数据呢？办法就是——索引。</p><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p><p>索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。<br>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。<br>我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。</p><h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如图所示。<br><img src="/img/CSDataStructure/168.jpg"><br>稠密索引要应对的可能是成千上万的数据，因此对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</p><p>索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。<br>比如上图中，我要查找关键字是18的记录，如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。<br>而如果是从左侧的索引表中查找，只需两次折半查找就可以得到18对应的指针，最终查找到结果。</p><p>这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p><h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。<br>为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。</p><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：<br>    块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。<br>    块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在        查找时带来效率。</p><p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。<br>如图所示，我们定义的分块索引的索引项结构分三个数据项：<br><img src="/img/CSDataStructure/169.jpg"><br>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；<br>存储了块中的记录个数，以便于循环时使用；<br>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</p><p>在分块索引表中查找，就是分两步进行：<br>    1.<br>        在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。<br>        例如，在上图的数据集中查找62，我们可以很快可以从左上角的索引表中由57&lt;62&lt;96得到62在第三个块中。<br>    2.<br>        根据块首指针找到相应的块，并在块中顺序查找关键码。<br>        因为块中可以是无序的，因此只能顺序查找。</p><p>我们再来分析一下分块索引的平均查找长度。<br>设n个记录的数据集被平均分成m块，每个块中有t条记录，显然n=m×t，或者说m=n/t。<br>再假设Lb为查找索引表的平均查找长度，因最好与最差的等概率原则，所以Lb的平均长度为(m+1)/2。<br>Lw为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2。</p><p>这样分块索引查找的平均查找长度为：<br><img src="/img/CSDataStructure/170.jpg"><br>注意上面这个式子的推导是为了让整个分块索引查找长度依赖n和t两个变量。<br>从这里了我们也就得到，平均长度不仅仅取决于数据集的总记录数n，还和每一个块的记录个数t相关。<br>最佳的情况就是分的块数m与块中的记录数t相同，此时意味着n=m×t=t2，即ASLw=1/2·(n/t+t)+1=t+1=sqrt(n)+1。</p><p>可见，分块索引的效率比之顺序查找的O(n)是高了不少，不过显然它与折半查找的O(logn)相比还有不小的差距。<br>因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。</p><p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>1.Books and friends should be few but good.（读书如交友，应求少而精。）<br>2.A good book is a good friend.（好书如挚友。）</p><table><thead><tr><th>英文单词</th><th>文章编号</th></tr></thead><tbody><tr><td>a</td><td>2</td></tr><tr><td>and</td><td>1</td></tr><tr><td>be</td><td>1</td></tr><tr><td>book</td><td>1,2</td></tr><tr><td>but</td><td>1</td></tr><tr><td>few</td><td>1</td></tr><tr><td>friend</td><td>1,2</td></tr><tr><td>good</td><td>1,2</td></tr><tr><td>is</td><td>2</td></tr><tr><td>should</td><td>1</td></tr></tbody></table><p>在这里这张单词表就是索引表，索引项的通用结构是：<br>    次关键码，例如上面的“英文单词”；<br>    记录号表，例如上面的“文章编号”。</p><p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。<br>这样的索引方法就是倒排索引（in-verted index）。<br>倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。<br>这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。<br>由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。</p><p>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。<br>但它的缺点是这个记录号不定长，比如上例有7个单词的文章编号只有一个，而“book”、“friend”、“good”有两个文章编号，若是对多篇文章所有单词建立倒排索引，那每个单词都将对应相当多的文章编号，维护比较困难，插入和删除操作都需要作相应的处理。</p><p>当然，现实中的搜索技术非常复杂，比如我们不仅要知道某篇文章有要搜索的关键字，还想知道这个关键字在文章中的哪些地方出现，这就需要我们对记录号表做一些改良。<br>再比如，文章编号上亿，如果都用长数字也没必要，可以进行压缩，比如三篇文章的编号是“112,115,119”，我们可以记录成“112,+3,+4”，即只记录差值，这样每个关键字就只占用一两个字节。<br>甚至关键字也可以压缩，比如前一条记录的关键字是“and”而后一条是“an-droid”，那么后面这个可以改成“&lt;3,roid&gt;”，这样也可以起到压缩数据的作用。<br>再比如搜索时，尽管告诉你有几千几万条查找到的记录，但其实真正显示给你看的，就只是当中的前10或者20条左右数据，只有在点击下一页时才会获得后面的部分索引记录，这也可以大大提高了整体搜索的效率。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样的效率也不错。<br>应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，但这样的表由于无序造成查找的效率很低，前面我们有讲解，这就不在啰嗦。</p><p>如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、斐波那契等查找算法来实现，可惜，因为有序，在插入和删除操作上，就需要耗费大量的时间。</p><p>有没有一种即可以使得插入和删除效率不错，又可以比较高效率地实现查找的算法呢？<br>还真有。</p><p>我们在8.2节把这种需要在查找时插入或删除的查找表称为动态查找表。<br>我们现在就来看看什么样的结构可以实现动态查找表的高效率。</p><p>如果在复杂的问题面前，我们束手无策的话，不妨先从最最简单的情况入手。<br>现在我们的目标是插入和查找同样高效。<br>假设我们的数据集开始只有一个数{62}，然后现在需要将88插入数据集，于是数据集成了{62,88}，还保持着从小到大有序。<br>再查找有没有58，没有则插入，可此时要想在线性表的顺序存储中有序，就得移动62和88的位置，如图左图，可不可以不移动呢？<br>嗯，当然是可以，那就是二叉树结构。<br>当我们用二叉树的方式时，首先我们将第一个数62定为根结点，88因为比62大，因此让它做62的右子树，58因比62小，所以成为它的左子树。<br>此时58的插入并没有影响到62与88的关系，如图右图所示。<br><img src="/img/CSDataStructure/171.jpg"></p><p>也就是说，若我们现在需要对集合{62,88,58,47,35,73,51,99,37,93}做查找，在我们打算创建此集合时就考虑用二叉树结构，而且是排好序的二叉树来创建。<br>如图所示，62、88、58创建好后，下一个数47因比58小，是它的左子树（见③），35是47的左子树（见④），73比62大，但却比88小，是88的左子树（见⑤），51比62小、比58小、比47大，是47的右子树（见⑥），99比62、88都大，是88的右子树（见⑦），37比62、58、47都小，但却比35大，是35的右子树（见⑧），93则因比62、88大是99的左子树（见⑨）。<br><img src="/img/CSDataStructure/172.jpg"><br>这样我们就得到了一棵二叉树，并且当我们对它进行中序遍历时，就可以得到一个有序的序列{35,37,47,51,58,62,73,88,93,99}，所以我们通常称它为二叉排序树。</p><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。<br>    若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；<br>    若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>    它的左、右子树也分别为二叉排序树。</p><p>从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。</p><p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。<br>不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。</p><h3 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h3><p>首先我们提供一个二叉树的结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉链表结点结构定义  */</span></span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>    <span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>                                  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数据  */</span></span><br><span class="line"><span class="keyword">int</span>  data;                                                      </span><br><span class="line"><span class="comment">/*  左右孩子指针  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span>        </span><br><span class="line">&#125;  BiTNode,  *BiTree;</span><br></pre></td></tr></table></figure><p>然后我们来看看二叉排序树的查找是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  递归查找二叉排序树T中是否存在key,  */</span></span><br><span class="line"><span class="comment">/*  指针f指向T的双亲，其初始调用值为NULL  */</span></span><br><span class="line"><span class="comment">/*  若查找成功，则指针p指向该数据元素结点，并返回TRUE  */</span></span><br><span class="line"><span class="comment">/*  否则指针p指向查找路径上访问的最后一个结点并返回FALSE  */</span></span><br><span class="line"><span class="function">Status  <span class="title">SearchBST</span><span class="params">(BiTree  T,  <span class="keyword">int</span>  key,  BiTree  f,  BiTree  *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (!T)<span class="comment">/*  查找不成功  */</span>                                                                                </span><br><span class="line">&#123;</span><br><span class="line">*p  =  f;</span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  ==  T-&gt;data) <span class="comment">/*  查找成功  */</span>                                       </span><br><span class="line">&#123;</span><br><span class="line">*p  =  T;</span><br><span class="line"><span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  &lt;  T-&gt;data)<span class="comment">/*  在左子树继续查找  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  SearchBST(T-&gt;lchild,  key,  T,  p);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  在右子树继续查找  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  SearchBST(T-&gt;rchild,  key,  T,  p);</span><br><span class="line">&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>SearchBST函数是一个可递归运行的函数，函数调用时的语句为SearchBST(T,93,NULL,p)，参数T是一个二叉链表，其中数据如图所示，key代表要查找的关键字，目前我们打算查找93，二叉树f指向T的双亲，当T指向根结点时，f的初值就为NULL，它在递归时有用，最后的参数p是为了查找成功后可以得到查找到的结点位置。<br><img src="/img/CSDataStructure/173.jpg"></p><p>2．第3～7行，是用来判断当前二叉树是否到叶子结点，显然图中告诉我们当前T指向根结点62的位置，T不为空，第5～6行不执行。</p><p>3．第8～12行是查找到相匹配的关键字时执行语句，显然93≠62，第10～11行不执行。</p><p>4．第13～14行是当要查找关键字小于当前结点值时执行语句，由于93&gt;62，第14行不执行。</p><p>5．第15～16行是当要查找关键字大于当前结点值时执行语句，由于93&gt;62，所以递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了62的右孩子88，如图所示。</p><p>6．此时第二层SearchBST，因93比88大，所以执行第16行，再次递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了88的右孩子99，如图所示。<br><img src="/img/CSDataStructure/174.jpg"></p><p>7．第三层的SearchBST，因93比99小，所以执行第14行，递归调用SearchBST(T-&gt;lchild,key,T,p)。此时T指向了99的左孩子93，如图所示。<br><img src="/img/CSDataStructure/175.jpg"></p><p>8．第四层SearchBST，因key等于T-&gt;data，所以执行第10～11行，此时指针p指向93所在的结点，并返回True到第三层、第二层、第一层，最终函数返回True。</p><h3 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时，  */</span></span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InsertBST</span><span class="params">(BiTree  *T,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree  p,  s;</span><br><span class="line"><span class="comment">/*  查找不成功  */</span></span><br><span class="line"><span class="keyword">if</span>  (!SearchBST(*T,  key,  <span class="literal">NULL</span>,  &amp;p))        </span><br><span class="line">&#123;</span><br><span class="line">s  =  (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">s-&gt;data  =  key;</span><br><span class="line">s-&gt;lchild  =  s-&gt;rchild  =  <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (!p)<span class="comment">/*  插入s为新的根结点  */</span></span><br><span class="line">&#123;</span><br><span class="line">*T  =  s;</span><br><span class="line">&#125;                                              </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  &lt;  p-&gt;data)<span class="comment">/*  插入s为左孩子  */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;lchild  =  s;</span><br><span class="line">&#125;                                </span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  插入s为右孩子  */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rchild  =  s;</span><br><span class="line">&#125;                                </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  树中已有关键字相同的结点，不再插入  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单。<br>如果你调用函数是“InsertBST(&amp;T,93);”，那么结果就是FALSE，如果是“InsertBST(&amp;T,95);”，那么一定就是在93的结点增加一个右孩子95，并且返回True。<br>如图所示。<br><img src="/img/CSDataStructure/176.jpg"></p><h3 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h3><p>如果需要查找并删除如37、51、73、93这些在二叉排序树中是叶子的结点，那是很容易的，毕竟删除它们对整棵树来说，其他结点的结构并未受到影响，如图所示。<br><img src="/img/CSDataStructure/177.jpg"></p><p>对于要删除的结点只有左子树或只有右子树的情况，相对也比较好解决。那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，可以理解为独子继承父业。<br>比如图，就是先删除35和99结点，再删除58结点的变化图，最终，整个结构还是一个二叉排序树。<br><img src="/img/CSDataStructure/178.jpg"></p><p>但是对于要删除的结点既有左子树又有右子树的情况怎么办呢？<br>比较好的办法就是，找到需要删除的结点p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除此结点s，如图所示。<br><img src="/img/CSDataStructure/179.jpg"></p><p>根据我们对删除结点三种情况的分析：<br>    叶子结点；<br>    仅有左或右子树的结点；<br>    左右子树都有的结点;</p><p>我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查找到时删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点,  */</span></span><br><span class="line"><span class="comment">/*  并返回TRUE；否则返回FALSE  */</span></span><br><span class="line"><span class="function">Status  <span class="title">DeleteBST</span><span class="params">(BiTree  *T,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (!*T)<span class="comment">/*  不存在关键字等于key的数据元素  */</span>                                            </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  找到关键字等于key的数据元素  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (key  ==  (*T)-&gt;data)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  Delete(T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (key  &lt;  (*T)-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  DeleteBST(&amp;(*T)-&gt;lchild,  key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  DeleteBST(&amp;(*T)-&gt;rchild,  key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别就在于第8行，此时执行的是Delete方法，对当前结点进行删除操作。<br>我们来看Delete的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  从二叉排序树中删除结点p，并重接它的左或右子树。  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Delete</span><span class="params">(BiTree  *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree  q,  s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  ((*p)-&gt;rchild  ==  <span class="literal">NULL</span>)<span class="comment">/*  右子树空则只需重接它的左子树  */</span>                  </span><br><span class="line">&#123;</span><br><span class="line">q  =  *p;  </span><br><span class="line">*p  =  (*p)-&gt;lchild;  </span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  ((*p)-&gt;lchild  ==  <span class="literal">NULL</span>)<span class="comment">/*  只需重接它的右子树  */</span>        </span><br><span class="line">&#123;</span><br><span class="line">q  =  *p;  </span><br><span class="line">*p  =  (*p)-&gt;rchild;  </span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  左右子树均不空  */</span>                                                            </span><br><span class="line">&#123;</span><br><span class="line">q  =  *p;  </span><br><span class="line">s  =  (*p)-&gt;lchild;</span><br><span class="line"><span class="comment">/*  转左，然后向右到尽头(找待删结点的前驱)  */</span></span><br><span class="line"><span class="keyword">while</span>  (s-&gt;rchild)                          </span><br><span class="line">&#123;</span><br><span class="line">q  =  s;  </span><br><span class="line">s  =  s-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  s指向被删结点的直接前驱  */</span></span><br><span class="line">(*p)-&gt;data  =  s-&gt;data;                  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (q  !=  *p)<span class="comment">/*  重接q的右子树  */</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rchild  =  s-&gt;lchild;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">else</span><span class="comment">/*  重接q的左子树  */</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;lchild  =  s-&gt;lchild;</span><br><span class="line">&#125; </span><br><span class="line">       </span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始执行，代码第4～7行目的是为了删除没有右子树只有左子树的结点。此时只需将此结点的左孩子替换它自己，然后释放此结点内存，就等于删除了。</p><p>2．<br>代码第8～11行是同样的道理处理只有右子树没有左子树的结点删除问题。</p><p>3．<br>第12～25行处理复杂的左右子树均存在的问题。</p><p>4．<br>第14行，将要删除的结点p赋值给临时的变量q，再将p的左孩子p-&gt;lchild赋值给临时的变量s。<br>此时q指向47结点，s指向35结点，如图所示。<br><img src="/img/CSDataStructure/180.jpg"></p><p>5．<br>第15～18行，循环找到左子树的右结点，直到右侧尽头。<br>就当前例子来说就是让q指向35，而s指向了37这个再没有右子树的结点，如图所示。<br><img src="/img/CSDataStructure/181.jpg"></p><p>6．第19行，此时让要删除的结点p的位置的数据被赋值为s-&gt;data，即让p-&gt;data=37，如图所示。<br><img src="/img/CSDataStructure/182.jpg"></p><p>7．<br>第20～23行，如果p和q指向不同，则将s-&gt;lchild赋值给q-&gt;rchild，否则就是将s-&gt;lchild赋值给q-&gt;lchild。<br>显然这个例子p不等于q，将s-&gt;lchild指向的36赋值给q-&gt;rchild，也就是让q-&gt;rchild指向36结点，如图所示。<br><img src="/img/CSDataStructure/183.jpg"></p><p>8．<br>第24行，free(s)，就非常好理解了，将37结点删除，如图所示。<br><img src="/img/CSDataStructure/184.jpg"></p><p>从这段代码也可以看出，我们其实是在找删除结点的前驱结点替换的方法，对于用后继结点来替换，方法上是一样的。</p><h3 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h3><p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。<br>而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。<br>极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。<br>也就是说，二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形状是不确定的。</p><p>例如{62,88,58,47,35,73,51,99,37,93}这样的数组，我们可以构建如图左图的二叉排序树。<br>但如果数组元素的次序是从小到大有序，如{35,37,47,51,58,62,73,88,93,99}，则二叉排序树就成了极端的右斜树，注意它依然是一棵二叉排序树，如图的右图。<br>此时，同样是查找结点99，左图只需要两次比较，而右图就需要10次比较才可以得到结果，二者差异很大。</p><p>也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为，那么查找的时间复杂也就为O(logn)，近似于折半查找，事实上，图的左图也不够平衡，明显的左重右轻。<br>不平衡的最坏情况就是像图右图的斜树，查找时间复杂度为O(n)，这等同于顺序查找。<br>因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。<br>这样我们就引申出另一个问题，如何让二叉排序树平衡的问题。<br><img src="/img/CSDataStructure/185.jpg"></p><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p>平衡二叉树（Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</p><p>从平衡二叉树的英文名字，你也可以体会到，它是一种高度平衡的二叉排序树。<br>那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。<br>我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor），那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。<br>只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p><p>看图，为什么图1是平衡二叉树，而图2却不是呢？<br>这里就是考查我们对平衡二叉树的定义的理解，它的前提首先是一棵二叉排序树，右上图的59比58大，却是58的左子树，这是不符合二叉排序树的定义的。<br>图3不是平衡二叉树的原因就在于，结点58的左子树高度为3，而右子树为空，二者差大于了绝对值1，因此它也不是平衡的。<br>而经过适当的调整后的图4，它就符合了定义，因此它是平衡二叉树。<br><img src="/img/CSDataStructure/186.jpg"></p><p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树。<br>下图中，当新插入结点37时，距离它最近的平衡因子绝对值超过1的结点是58（即它的左子树高度3减去右子树高度1），所以从58开始以下的子树为最小不平衡子树。<br><img src="/img/CSDataStructure/187.jpg"></p><h3 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h3><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。<br>在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p><p>为了能在讲解算法时轻松一些，我们先讲一个平衡二叉树构建过程的例子。<br>假设我们现在有一个数组a[10]={3,2,1,4,5,6,7,10,9,8}需要构建二叉排序树。<br>在没有学习平衡二叉树之前，根据二叉排序树的特性，我们通常会将它构建成如图的图1所示的样子。虽然它完全符合二叉排序树的定义，但是对这样高度达到8的二叉树来说，查找是非常不利的。<br>我们更期望能构建成如图图2的样子，高度为4的二叉排序树才可以提供高效的查找效率。<br>那么现在我们就来研究如何将一个数组构建出图2的树结构。<br><img src="/img/CSDataStructure/188.jpg"></p><p>对于数组a[10]={3,2,1,4,5,6,7,10,9,8}的前两位3和2，我们很正常地构建，到了第3个数“1”时，发现此时根结点“3”的平衡因子变成了2，此时整棵树都成了最小不平衡子树，因此需要调整，如图的图1（结点左上角数字为平衡因子BF值）。<br>因为BF值为正，因此我们将整个树进行右旋（顺时针旋转），此时结点2成了根结点，3成了2的右孩子，这样三个结点的BF值均为0，非常的平衡，如图的图2所示。<br><img src="/img/CSDataStructure/189.jpg"></p><p>然后我们再增加结点4，平衡因子没有超出限定范围（-1，0，1），如图3。<br>增加结点5时，结点3的BF值为-2，说明要旋转了。<br>由于BF是负值，所以我们对这棵最小平衡子树进行左旋（逆时针旋转），如图4，此时我们整个树又达到了平衡。</p><p>继续，增加结点6时，发现根结点2的BF值变成了-2，如图的图6。<br>所以我们对根结点进行了左旋，注意此时本来结点3是4的左孩子，由于旋转后需要满足二叉排序树特性，因此它成了结点2的右孩子，如图7。</p><p>增加结点7，同样的左旋转，使得整棵树达到平衡，如图8和图9所示。<br><img src="/img/CSDataStructure/190.jpg"></p><p>当增加结点10时，结构无变化，如图的图10。<br>再增加结点9，此时结点7的BF变成了-2，理论上我们只需要旋转最小不平衡子树7、9、10即可，但是如果左旋转后，结点9就成了10的右孩子，这是不符合二叉排序树的特性的，此时不能简单的左旋，如图11所示。<br><img src="/img/CSDataStructure/191.jpg"></p><p>仔细观察图11，发现根本原因在于结点7的BF是-2，而结点10的BF是1，也就是说，它们俩一正一负，符号并不统一，而前面的几次旋转，无论左还是右旋，最小不平衡子树的根结点与它的子结点符号都是相同的。这就是不能直接旋转的关键。那怎么办呢？</p><p>不统一，不统一就把它们先转到符号统一再说，于是我们先对结点9和结点10进行右旋，使得结点10成了9的右子树，结点9的BF为-1，此时就与结点7的BF值符号统一了，如图的图12所示。</p><p>这样我们再以结点7为最小不平衡子树进行左旋，得到图的图13。</p><p>接着插入8，情况与刚才类似，结点6的BF是-2，而它的右孩子9的BF是1，如图14，因此首先以9为根结点，进行右旋，得到图15，此时结点6和结点7的符号都是负，再以6为根结点左旋，最终得到最后的平衡二叉树，如图8-7-8的图16所示。<br><img src="/img/CSDataStructure/192.jpg"></p><p>通过刚才这个例子，你会发现，当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋，如上例中结点1、5、6、7的插入等。<br>插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作，如上例中结点9、8的插入时。</p><h3 id="平衡二叉树实现算法"><a href="#平衡二叉树实现算法" class="headerlink" title="平衡二叉树实现算法"></a>平衡二叉树实现算法</h3><p>好了，有这么多的准备工作，我们可以来讲解代码了。<br>首先是需要改进二叉排序树的结点结构，增加一个bf，用来存储平衡因子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  二叉树的二叉链表结点结构定义  */</span></span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>                                    </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  结点数据  */</span></span><br><span class="line"><span class="keyword">int</span>  data;</span><br><span class="line"><span class="comment">/*  结点的平衡因子  */</span></span><br><span class="line"><span class="keyword">int</span>  bf;                                                          </span><br><span class="line"><span class="comment">/*  左右孩子指针  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span>  *<span class="title">lchild</span>,  *<span class="title">rchild</span>;</span>        </span><br><span class="line">&#125;  BiTNode,  *BiTree;</span><br></pre></td></tr></table></figure><p>然后，对于右旋操作，我们的代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对以p为根的二叉排序树作右旋处理，  */</span></span><br><span class="line"><span class="comment">/*  处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">R_Rotate</span><span class="params">(BiTree  *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree  L;</span><br><span class="line"><span class="comment">/*  L指向P的左子树根结点  */</span></span><br><span class="line">L  =  (*P)-&gt;lchild;                        </span><br><span class="line"><span class="comment">/*  L的右子树挂接为P的左子树  */</span></span><br><span class="line">(*P)-&gt;lchild  =  L-&gt;rchild;</span><br><span class="line">        </span><br><span class="line">L-&gt;rchild  =  (*P);</span><br><span class="line"><span class="comment">/*  P指向新的根结点  */</span></span><br><span class="line">*P  =  L;                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数代码的意思是说，当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结点。<br>这样就完成了一次右旋操作，如图所示。<br>图中三角形代表子树，N代表新增结点。<br><img src="/img/CSDataStructure/193.jpg"></p><p>左旋操作代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对以P为根的二叉排序树作左旋处理，  */</span></span><br><span class="line"><span class="comment">/*  处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">L_Rotate</span><span class="params">(BiTree  *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree  R;</span><br><span class="line"><span class="comment">/*  R指向P的右子树根结点  */</span></span><br><span class="line">R  =  (*P)-&gt;rchild;                        </span><br><span class="line"><span class="comment">/*  R的左子树挂接为P的右子树  */</span></span><br><span class="line">(*P)-&gt;rchild  =  R-&gt;lchild;        </span><br><span class="line"></span><br><span class="line">R-&gt;lchild  =  (*P);</span><br><span class="line"><span class="comment">/*  P指向新的根结点  */</span></span><br><span class="line">*P  =  R;                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来看左平衡旋转处理的函数代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LH  +1    <span class="comment">/*  左高  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EH  0     <span class="comment">/*  等高  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RH  -1    <span class="comment">/*  右高  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理  */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">LeftBalance</span><span class="params">(BiTree  *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree  L,Lr;</span><br><span class="line"><span class="comment">/*  L指向T的左子树根结点  */</span></span><br><span class="line">L  =  (*T)-&gt;lchild;                              </span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>  (L-&gt;bf)<span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理  */</span></span><br><span class="line">&#123;                                                              </span><br><span class="line"><span class="keyword">case</span>  LH:<span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理  */</span>                                                </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  L-&gt;bf  =  EH;</span><br><span class="line">R_Rotate(T);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span>  RH:<span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理  */</span>                                                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  Lr指向T的左孩子的右子树根  */</span></span><br><span class="line">Lr  =  L-&gt;rchild;                          </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  修改T及其左孩子的平衡因子  */</span></span><br><span class="line"><span class="keyword">switch</span>  (Lr-&gt;bf)                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>  LH:  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  RH;</span><br><span class="line">L-&gt;bf  =  EH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span>  EH:  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  L-&gt;bf  =  EH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span>  RH:  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  EH;</span><br><span class="line">L-&gt;bf  =  LH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lr-&gt;bf  =  EH;</span><br><span class="line"><span class="comment">/*  对T的左子树作左旋平衡处理  */</span></span><br><span class="line">L_Rotate(&amp;(*T)-&gt;lchild);</span><br><span class="line"><span class="comment">/*  对T作右旋平衡处理  */</span></span><br><span class="line">R_Rotate(T);  </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了三个常数变量，分别代表1、0、-1。</p><p>1.<br>函数被调用，传入一个需调整平衡性的子树T。<br>由于LeftBalance函数被调用时，其实是已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高度。<br>换句话说，此时T的根结点应该是平衡因子BF的值大于1的数。</p><p>2.<br>第4行，我们将T的左孩子赋值给L。</p><p>3.<br>第5～27行是分支判断。</p><p>4.<br>当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，因此，第8行，将它们的BF值都改为0，并且第9行，进行右旋操作。<br>操作的方式如上图所示。</p><p>5.<br>当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。<br>第13～22行，针对L的右孩子Lr的BF作判断，修改根结点T和L的BF值。<br>第24行将当前Lr的BF改为0。</p><p>6.<br>第25行，对根结点的左子树进行左旋，如下图第二图所示。</p><p>7.<br>第26行，对根结点进行右旋，如下图的第三图所示，完成平衡操作。<br><img src="/img/CSDataStructure/194.jpg"><br>同样的，右平衡旋转处理的函数代码非常类似，直接看代码，不做讲解了。</p><p>有了这些准备，我们的主函数才算是正式登场了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个  */</span></span><br><span class="line"><span class="comment">/*  数据元素为e的新结点并返回1，否则返回0。若因插入而使二叉排序树  */</span></span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InsertAVL</span><span class="params">(BiTree  *T,  <span class="keyword">int</span>  e,  Status  *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (!*T)</span><br><span class="line">&#123;                                                                                               </span><br><span class="line"><span class="comment">/*  插入新结点，树“长高”，置taller为TRUE  */</span></span><br><span class="line">*T  =  (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;data  =  e;</span><br><span class="line">(*T)-&gt;lchild  =  (*T)-&gt;rchild  =  <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;bf  =  EH;</span><br><span class="line">*taller  =  TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (e  ==  (*T)-&gt;data)</span><br><span class="line">&#123;                                                                                               </span><br><span class="line"><span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入  */</span></span><br><span class="line">*taller  =  FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (e  &lt;  (*T)-&gt;data)</span><br><span class="line">&#123;                                                                                               </span><br><span class="line"><span class="comment">/*  应继续在T的左子树中进行搜索  */</span></span><br><span class="line"><span class="comment">/*  未插入  */</span></span><br><span class="line"><span class="keyword">if</span>  (!InsertAVL(&amp;(*T)-&gt;lchild,  e,  taller))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  已插入到T的左子树中且左子树“长高”  */</span></span><br><span class="line"><span class="keyword">if</span>  (*taller)                                                                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  检查T的平衡度  */</span></span><br><span class="line"><span class="keyword">switch</span>  ((*T)-&gt;bf)                                                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  原本左子树比右子树高，需要作左平衡处理  */</span></span><br><span class="line"><span class="keyword">case</span>  LH:                                                                  </span><br><span class="line">&#123;</span><br><span class="line">LeftBalance(T);</span><br><span class="line">*taller  =  FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  原本左右子树等高，现因左子树增高而树增高  */</span></span><br><span class="line"><span class="keyword">case</span>  EH:                                                                  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  LH;</span><br><span class="line">*taller  =  TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  原本右子树比左子树高，现左右子树等高  */</span></span><br><span class="line"><span class="keyword">case</span>  RH:                                                                  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  EH;</span><br><span class="line">*taller  =  FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                                                                               </span><br><span class="line"><span class="comment">/*  应继续在T的右子树中进行搜索  */</span></span><br><span class="line"><span class="comment">/*  未插入  */</span></span><br><span class="line"><span class="keyword">if</span>  (!InsertAVL(&amp;(*T)-&gt;rchild,  e,  taller))        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  已插入到T的右子树且右子树“长高”  */</span></span><br><span class="line"><span class="keyword">if</span>  (*taller)                                                                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  检查T的平衡度  */</span></span><br><span class="line"><span class="keyword">switch</span>  ((*T)-&gt;bf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  原本左子树比右子树高，现左、右子树等高  */</span></span><br><span class="line"><span class="keyword">case</span>  LH:                                                                  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  EH;</span><br><span class="line">*taller  =  FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  原本左右子树等高，现因右子树增高而树增高  */</span></span><br><span class="line"><span class="keyword">case</span>  EH:                                                                  </span><br><span class="line">&#123;</span><br><span class="line">(*T)-&gt;bf  =  RH;</span><br><span class="line">*taller  =  TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  原本右子树比左子树高，需要作右平衡处理  */</span></span><br><span class="line"><span class="keyword">case</span>  RH:                                                                </span><br><span class="line">&#123;</span><br><span class="line">RightBalance(T);</span><br><span class="line">*taller  =  FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<br>程序开始执行时，第3～10行是指当前T为空时，则申请内存新增一个结点。 </p><p>2.<br>第13～17行表示当存在相同结点，则不需要插入。 </p><p>3.<br>第18～40行，当新结点e小于T的根结点值时，则在T的左子树查找。 </p><p>4.<br>第20～21行，递归调用本函数，直到找到则返回false，否则说明插入结点成功，执行下面语句。 </p><p>5.<br>第22～39行，当taller为TRUE时，说明插入了结点，此时需要判断T的平衡因子，如果是1，说明左子树高于右子树，需要调用LeftBalance函数进行左平衡旋转处理。<br>如果为0或-1，则说明新插入结点没有让整棵二叉排序树失去平衡性，只需要修改相关的BF值即可。 </p><p>6.<br>第41～63行，说明新结点e大于T的根结点的值，在T的右子树查找。<br>代码上述类似，不再详述。</p><p>对于这段代码来说，我们只需要在需要构建平衡二叉树的时候执行如下列代码即可在内存中生成一棵与上图的图2相同的平衡的二叉树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="keyword">int</span>  a[<span class="number">10</span>]  =  &#123;  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">10</span>,  <span class="number">9</span>,  <span class="number">8</span>  &#125;;</span><br><span class="line">BiTree  T  =  <span class="literal">NULL</span>;</span><br><span class="line">Status  taller;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  <span class="number">10</span>;  i++)</span><br><span class="line">&#123;</span><br><span class="line">InsertAVL(&amp;T,  a[i],  &amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O(logn)，而插入和删除也为O(logn)。<br>这显然是比较理想的一种动态查找表算法。</p><h2 id="多路查找树（B树）"><a href="#多路查找树（B树）" class="headerlink" title="多路查找树（B树）"></a>多路查找树（B树）</h2><p>我们前面讨论过的数据结构，处理数据都是在内存中，因此考虑的都是内存中的运算时间复杂度。</p><p>但如若我们要操作的数据集非常大，大到内存已经没办法处理了怎么办呢？如数据库中的上千万条记录的数据表、硬盘中的上万个文件等。<br>在这种情况下，对数据的处理需要不断从硬盘等存储设备中调入或调出内存页面。</p><p>一旦涉及到这样的外部存储设备，关于时间复杂度的计算就会发生变化，访问该集合元素的时间已经不仅仅是寻找该元素所需比较次数的函数，我们必须考虑对硬盘等外部存储设备的访问时间以及将会对该设备做出多少次单独访问。</p><p>试想一下，为了要在一个拥有几十万个文件的磁盘中查找一个文本文件，你设计的算法需要读取磁盘上万次还是读取几十次，这是有本质差异的。<br>此时，为了降低对外存设备的访问次数，我们就需要新的数据结构来处理这样的问题。</p><p>我们之前谈的树，都是一个结点可以有多个孩子，但是它自身只存储一个元素。二叉树限制更多，结点最多只能有两个孩子。<br>一个结点只能存储一个元素，在元素非常多的时候，就使得要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，甚至两者都必须足够大才行。<br>这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制，为此引入了多路查找树的概念。</p><p>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。<br>由于它是查找树，所有元素之间存在某种特定的排序关系。<br>在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。<br>为此，我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。</p><p>一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。<br>不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。</p><p>一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p><p>并且2-3树中所有的叶子都在同一层次上。如图所示，就是一棵有效的2-3树。<br><img src="/img/CSDataStructure/195.jpg"><br>事实上，2-3树复杂的地方就在于新结点的插入和已有结点的删除。<br>毕竟，每个结点可能是2结点也可能是3结点，要保证所有叶子都在同一层次，是需要进行一番复杂操作的。</p><h4 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h4><p>对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p><p>2-3树插入可分为三种情况。<br>1）<br>对于空树，插入一个2结点即可，这很容易理解。</p><p>2）<br>插入结点到一个2结点的叶子上。<br>应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。<br>如图所示。我们希望从左图的2-3树中插入元素3，根据遍历可知，3比8小、比4小，于是就只能考虑插入到叶子结点1所在的位置，因此很自然的想法就是将此结点变成一个3结点，即右图这样完成插入操作。<br>当然，要视插入的元素与当前叶子结点的元素比较大小后，决定谁在左谁在右。例如，若插入的是0，则此结点就是“0”在左“1”在右了。<br><img src="/img/CSDataStructure/196.jpg"></p><p>3）<br>要往3结点中插入一个新元素。<br>因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。<br>复杂的情况也正在于此。</p><p>第一种情况，见下图，需要向左图中插入元素5。<br>经过遍历可得到元素5比8小比4大，因此它应该是需要插入在拥有6、7元素的3结点位置。问题就在于，6和7结点已经是3结点，不能再加。<br>此时发现它的双亲结点4是个2结点，因此考虑让它升级为3结点，这样它就得有三个孩子，于是就想到，将6、7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子，如图的右图所示。<br><img src="/img/CSDataStructure/197.jpg"></p><p>另一种情况，如下图所示，需要向左图中插入元素11。<br>经过遍历可得到元素11比12、14小比9、10大，因此它应该是需要插入在拥有9、10元素的3结点位置。<br>同样道理，9和10结点不能再增加结点。此时发现它的双亲结点12、14也是一个3结点，也不能再插入元素了。<br>再往上看，12、14结点的双亲，结点8是个2结点。<br>于是就想到，将9、10拆分，12、14也拆分，让根结点8升级为3结点，最终形成如图的右图样子。<br><img src="/img/CSDataStructure/198.jpg"></p><p>再来看个例子，如图所示，需要在左图中插入元素2。<br>经过遍历可得到元素2比4小、6比1大，因此它应该是需要插入在拥有1、3元素的3结点位置。<br>与上例一样，你会发现，1、3结点，4、6结点都是3结点，都不能再插入元素了，再往上看，8、12结点还是一个3结点，那就意味着，当前我们的树结构是三层已经不能满足当前结点增加的需要了。<br>于是将1、3拆分，4、6拆分，连根结点8、12也拆分，最终形成如图的右图样子。<br><img src="/img/CSDataStructure/199.jpg"><br>通过这个例子，也让我们发现，如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加。</p><h4 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h4><p>对于2-3树的删除来说，如果对前面插入的理解足够到位的话，应该不是难事了。<br>2-3树的删除也分为三种情况。<br>与插入相反，我们从3结点开始说起。</p><p>1）<br>所删除元素位于一个3结点的叶子结点上， 这非常简单，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。<br>如图所示，删除元素9，只需要将此结点改成只有元素10的2结点即可。<br><img src="/img/CSDataStructure/200.jpg"></p><p>2）<br>所删除的元素位于一个2结点上，即要删除的是一个只有一个元素的结点。<br>如果按照以前树的理解，删除即可，可现在的2-3树的定义告诉我们这样做是不可以的。<br>比如图所示，如果我们删除了结点1，那么结点4本来是一个2结点（它拥有两个孩子），此时它就不满足定义了。<br><img src="/img/CSDataStructure/201.jpg"></p><p>因此，对于删除叶子是2结点的情况，我们需要分四种情形来处理。</p><p>情形一，此结点的双亲也是2结点，且拥有一个3结点的右孩子。<br>如图所示，删除结点1，那么只需要左旋，即6成为双亲，4成为6的左孩子，7是6的右孩子。<br><img src="/img/CSDataStructure/202.jpg"></p><p>情形二，此结点的双亲是2结点，它的右孩子也是2结点。<br>如图所示，此时删除结点4，如果直接左旋会造成没有右孩子，因此需要对整棵树变形，办法就是，我们目标是让结点7变成3结点，那就得让比7稍大的元素8下来，随即就得让比元素8稍大的元素9补充结点8的位置，于是就有了图的中间图，于是再用左旋的方式，变成右图结果。<br><img src="/img/CSDataStructure/203.jpg"></p><p>情形三，此结点的双亲是一个3结点。<br>如图所示，此时删除结点10，意味着双亲12、14这个结点不能成为3结点了，于是将此结点拆分，并将12与13合并成为左孩子。<br><img src="/img/CSDataStructure/204.jpg"></p><p>情形四，如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足2-3树的定义。<br>如图所示，删除叶子结点8时（其实删除任何一个结点都一样），就不得不考虑要将2-3的层数减少，办法是将8的双亲和其左子树6合并为一3个结点，再将14与9合并为3结点，最后成为右图的样子。<br><img src="/img/CSDataStructure/205.jpg"></p><p>3）<br>所删除的元素位于非叶子的分支结点。此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。</p><p>如果我们要删除的分支结点是2结点。<br>如图所示我们要删除4结点，分析后得到它的前驱是1后继是6，显然，由于6、7是3结点，只需要用6来补位即可，如图右图所示。<br><img src="/img/CSDataStructure/206.jpg"></p><p>如果我们要删除的分支结点是3结点的某一元素，如图所示我们要删除12、14结点的12，此时，经过分析，显然应该是将是3结点的左孩子的10上升到删除位置合适。<br><img src="/img/CSDataStructure/207.jpg"></p><p>当然，如果对2-3树的插入和删除等所有的情况进行讲解，既占篇幅，又没必要，总的来说它是有规律的，需要你们在上面的这些例子中多去体会后掌握。</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。<br>一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。<br>如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p><p>由于2-3-4树和2-3树是类似的，我们这里就简单介绍一下，如果我们构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程，如图所示。<br>图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。<br>之后的图其实就是在元素不断插入时最后形成了图7的2-3-4树。<br><img src="/img/CSDataStructure/208.jpg"></p><p>下图是对一个2-3-4树的删除结点的演变过程，删除顺序是1、6、3、4、5、2、9。<br><img src="/img/CSDataStructure/209.jpg"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树（B-tree）是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。<br>结点最大的孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。</p><p>一个m阶的B树具有如下属性：<br>    如果根结点不是叶结点，则其至少有两棵子树。<br>    每一个非根的分支结点都有k-1个元素和k个孩子，其中。每一个叶子结点n都有k-1个元素，其中。<br>    所有叶子结点都位于同一层次。<br>    所有分支结点包含下列信息数据</p><p>（n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n)为关键字，且Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n)为指向子树根结点的指针，且指针Ai-1所指子树中所有结点的关键字均小于Ki(i=1,2,…,n)，An所指子树中所有结点的关键字均大于Kn，n(≤n≤m-1)为关键字的个数（或n+1为子树的个数）。</p><p>例如，在讲2-3-4树时插入9个数后的图转成B树示意就如图的右图所示。左侧灰色方块表示当前结点的元素个数。<br><img src="/img/CSDataStructure/210.jpg"></p><p>在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。</p><p>比方说，我们要查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过A2再读取外存的6、7结点，查找到所要的元素。<br>至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已。</p><p>我们在本节的开头提到，如果内存与外存交换数据次数频繁，会造成了时间效率上的瓶颈，那么B树结构怎么就可以做到减少次数呢？</p><p>我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是211到214个字节。</p><p>在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得B树的阶数（或结点的元素）与硬盘存储的页面大小相匹配。<br>比如说一棵B树的阶为1001（即1个结点包含1000个关键字），高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。</p><p>这就好比我们普通人数钱都是一张一张的数，而银行职员数钱则是五张、十张，甚至几十张一数，速度当然是比常人快了不少。<br>通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。<br>由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。<br>可以说，B树的数据结构就是为内外存的数据交互准备的。</p><p>那么对于n个关键字的m阶B树，最坏情况是要查找几次呢？我们来作一分析。<br>第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有|m/2|棵子树，则第三层至少有2×|m/2|个结点，……，这样第k+1层至少有2×(|m/2|)k-1个结点，而实际上，k+1层的结点就是叶子结点。若m阶B树有n个关键字，那么当你找到了叶子结点，其实也就等于查找不成功的结点为n+1，因此n+1≥2×(|m/2|)k-1，即：<br><img src="/img/CSDataStructure/211.jpg"><br>也就是说，在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过log|m/2|((n+1)/2)+1。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>尽管前面我们已经讲了B树的诸多好处，但其实它还是有缺陷的。<br>对于树结构来说，我们都可以通过中序遍历来顺序查找树中的元素，这一切都是在内存中进行。</p><p>可是在B树结构中，我们往返于每个结点之间也就意味着，我们必须得在硬盘的页面之间进行多次访问，如图所示，我们希望遍历这棵B树，假设每个结点都属于硬盘的不同页面，我们为了中序遍历所有的元素，页面2→页面1→页面3→页面1→页面4→页面1→页面5。<br>而且我们每次经过结点遍历时，都会对结点中的元素进行一次遍历，这就非常糟糕。<br>有没有可能让遍历时每个元素只访问一次呢？<br><img src="/img/CSDataStructure/212.jpg"></p><p>为了能够解决所有元素遍历等基本问题，我们在原有的B树结构基础上，加上了新的元素组织方式，这就是B+树。</p><p>B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。<br>在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。<br>而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。<br>另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p><p>例如图所示，就是一棵B+树的示意，灰色关键字即是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。<br><img src="/img/CSDataStructure/213.jpg"></p><p>一棵m阶的B+树和m阶的B树的差异在于：<br>    有n棵子树的结点中包含有n个关键字；<br>    所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；<br>    所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。</p><p>这样的数据结构最大的好处就在于，如果是要随机查找，我们就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p><p>如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。</p><p>B+树的结构特别适合带有范围的查找。比如查找我们学校18～22岁的学生人数，我们可以通过从根结点出发找到第一个18岁的学生，然后再在叶子结点按顺序查找到符合范围的所有记录。</p><p>B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已。</p><h2 id="散列表查找（哈希表）概述"><a href="#散列表查找（哈希表）概述" class="headerlink" title="散列表查找（哈希表）概述"></a>散列表查找（哈希表）概述</h2><p>在本章前面的顺序表查找时，我们曾经说过，如果你要查找某个关键字的记录，就是从表头开始，挨个的比较记录a[i]与key的值是“=”还是“≠”，直到有相等才算是查找成功，返回i。<br>到了有序表查找时，我们可以利用a[i]与key的“&lt;”或“&gt;”来折半查找，直到相等时查找成功返回i。<br>最终我们的目的都是为了找到那个i，其实也就是相对的下标，再通过顺序存储的存储位置计算方法，LOC(ai)=LOC(a1)＋(i-1)×c，也就是通过第一个元素内存存储位置加上i-1个单元位置，得到最后的内存地址。<br>此时我们发现，为了查找到结果，之前的方法“比较”都是不可避免的，但这是否真的有必要？能否直接通过关键字key得到要查找的记录内存存储位置呢？</p><h3 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h3><p>也就是说，我们只需要通过某个函数f，使得<br>存储位置=f（关键字）<br>那样我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。这就是一种新的存储技术——散列技术。</p><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）。<br>查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。</p><p>这里我们把这种对应关系f称为散列函数，又称为哈希（Hash）函数。<br>按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。<br>那么关键字对应的记录存储位置我们称为散列地址。</p><h3 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h3><p>整个散列过程其实就是两步。<br>（1）<br>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。<br>总之，不管什么记录，我们都需要用同一个散列函数计算出地址再存储。</p><p>（2）<br>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。<br>说起来很简单，在哪存的，上哪去找，由于存取用的是同一个散列函数，因此结果当然也是相同的。</p><p>所以说，散列技术既是一种存储方法，也是一种查找方法。<br>然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。</p><p>因此，散列主要是面向查找的存储结构。<br>散列技术最适合的求解问题是查找与给定值相等的记录。<br>对于查找来说，简化了比较过程，效率就会大大提高。<br>但万事有利就有弊，散列技术不具备很多常规数据结构的能力。</p><p>我们说了这么多，散列函数应该如何设计？这个我们需要重点来讲解，总之设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。</p><p>另一个问题是冲突。<br>在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。<br>我们时常会碰到两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象我们称为冲突（colli-sion），并把key1和key2称为这个散列函数的同义词（synonym）。<br>出现了冲突当然非常糟糕，那将造成数据查找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能的少，但是不能完全避免。<br>于是如何处理冲突就成了一个很重要的课题，这在我们后面也需要详细讲解。</p><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>不管做什么事要达到最优都不容易，既要付出尽可能的少，又要得到最大化的多。那么什么才算是好的散列函数呢？这里我们有两个原则可以参考。<br>1．计算简单<br>你说设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很复杂的计算，会耗费很多时间，这对于需要频繁地查找来说，就会大大降低查找的效率了。因此散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。<br>2．散列地址分布均匀<br>我们刚才也提到冲突带来的问题，最好的办法就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>如果我们现在要对0～100岁的人口数字统计表，如下表所示，那么我们对年龄这个关键字就可以直接用年龄的数字作为地址。此时f(key)=key。</p><table><thead><tr><th>地址</th><th>年龄人数</th></tr></thead><tbody><tr><td>0</td><td>0500万</td></tr><tr><td>1</td><td>1600万</td></tr><tr><td>2</td><td>2450万</td></tr><tr><td>……</td><td>……</td></tr><tr><td>2020</td><td>1500万</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>如果我们现在要统计的是80后出生年份的人口数，如下表所示，那么我们对出生年份这个关键字可以用年份减去1980来作为地址。此时f(key)=key-1980。</p><table><thead><tr><th>地址</th><th>出生</th><th>年份人数</th></tr></thead><tbody><tr><td>0</td><td>1980</td><td>1500万</td></tr><tr><td>1</td><td>1981</td><td>1600万</td></tr><tr><td>2</td><td>1982</td><td>1300万</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>2000</td><td>2000</td><td>800万</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>也就是说，我们可以取关键字的某个线性函数值为散列地址，即<br>f(key)=a×key+b（a、b为常数）</p><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合查找表较小且连续的情况。<br>由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>如果我们的关键字是位数较多的数字，比如我们的11位手机号“130xxxx1234”，其中前三位是接入号，一般对应不同运营商公司的子品牌，如130是联通如意通、136是移动神州行、153是电信等；中间四位是HLR识别号，表示用户号的归属地；后四位才是真正的用户号，如表所示。<br><img src="/img/CSDataStructure/214.jpg"><br>若我们现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是相同的。<br>那么我们选择后面的四位成为散列地址就是不错的选择。<br>如果这样的抽取工作还是容易出现冲突问题，还可以对抽取出来的数字再进行反转（如1234改成4321）、右环位移（如1234改成4123）、左环位移、甚至前两数与后两数叠加（如1234改成12+34=46）等方法。<br>总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各位置。<br>这里我们提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。</p><p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。<br>再比如关键字是4321，那么它的平方就是18671041，抽取中间的3位就可以是671，也可以是710，用做散列地址。</p><p>平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br>比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再求后3位得到散列地址为962。<br>有时可能这还不能够保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。<br>比如我们将987和321反转，再与654和0相加，变成789+654+123+0=1566，此时散列地址为566。</p><p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>此方法为最常用的构造散列函数方法。</p><p>对于散列表长为m的散列函数公式为：<br>f(key)=key mod p(p≤m)</p><p>mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p><p>很显然，本方法的关键就在于选择合适的p，p如果选得不好，就可能会容易产生同义词。</p><p>例如下表，我们对于有12个记录的关键字构造散列表时，就用了f(key)=key mod 12的方法。比如29 mod 12=5，所以它存储在下标为5的位置。<br><img src="/img/CSDataStructure/215.jpg"></p><p>不过这也是存在冲突的可能的，因为12=2×6=3×4。如果关键字中有像18(3×6)、30(5×6)、42(7×6)等数字，它们的余数都为6，这就和78所对应的下标位置冲突了。<br>甚至极端一些，对于下表的关键字，如果我们让p为12的话，就可能出现下面的情况，所有的关键字都得到了0这个地址数，这未免也太糟糕了点。<br><img src="/img/CSDataStructure/216.jpg"></p><p>我们不选用p=12来做除留余数法，而选用p=11，如下表所示。<br><img src="/img/CSDataStructure/217.jpg"></p><p>此就只有12和144有冲突，相对来说，就要好很多。</p><p>因此根据前辈们的经验，若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数。</p><h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址。<br>也就是f(key)=random(key)。<br>这里random是随机函数。</p><p>当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p><p>有同学问，那如果关键字是字符串如何处理？其实无论是英文字符，还是中文字符，也包括各种各样的符号，它们都可以转化为某种数字来对待，比如ASCII码或者Unicode码等，因此也就可以使用上面的这些方法。</p><p>总之，现实中，应该视不同的情况采用不同的散列函数。</p><p>我们只能给出一些考虑的因素来提供参考：<br>1.计算散列地址所需的时间。<br>2.关键字的长度。<br>3.散列表的大小。<br>4.关键字的分布情况。<br>5.记录查找的频率。</p><p>综合这些因素，才能决策选择哪种散列函数更合适。</p><h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><p>那么当我们在使用散列函数后发现两个关键字key1≠key2，但是却有f(key1)=f(key2)，即有冲突时，怎么办呢？我们可以从生活中找寻思路。</p><p>试想一下，当你观望很久很久，终于看上一套房打算要买了，正准备下订金，人家告诉你，这房子已经被人买走了，你怎么办？</p><p>对呀，再找别的房子呗！这其实就是一种处理冲突的方法——开放定址法。</p><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><p>它的公式是：<br>fi(key)=(f(key)+di)MOD  m(di=1,2,3,……,m-1)</p><p>比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34}，表长为12。我们用散列函数f(key)=key mod 12。<br>当计算前5个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入，如下表所示。<br><img src="/img/CSDataStructure/218.jpg"><br>计算key=37时，发现f(37)=1，此时就与25所在的位置冲突。于是我们应用上面的公式f(37)=(f(37)+1)mod 12=2。于是将37存入下标为2的位置。这其实就是房子被人买了于是买下一间的作法，如表所示。<br><img src="/img/CSDataStructure/219.jpg"><br>接下来22,29,15,47都没有冲突，正常的存入，如表所示。<br><img src="/img/CSDataStructure/220.jpg"><br>到了key=48，我们计算得到f(48)=0，与12所在的0位置冲突了，不要紧，我们f(48)=(f(48)+1)mod 12=1，此时又与25所在的位置冲突。<br>于是f(48)=(f(48)+2)mod 12=2，还是冲突……一直到f(48)=(f(48)+6)mod 12=6时，才有空位，机不可失，赶快存入，如表所示。<br><img src="/img/CSDataStructure/221.jpg"></p><p>我们把这种解决冲突的开放定址法称为线性探测法。</p><p>从这个例子我们也看到，我们在解决冲突的时候，还会碰到如48和37这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。<br>很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。</p><p>考虑深一步，如果发生这样的情况，当最后一个key=34，f(key)=10，与22所在的位置冲突，可是22后面没有空位置了，反而它的前面有一个空位置，尽管可以不断地求余数后得到结果，但效率很差。<br>因此我们可以改进di=12,-12,22,-22,……,q2,-q2,(q≤m/2)，这样就等于是可以双向寻找到可能的空位置。<br>对于34来说，我们取di=-1即可找到空位置了。</p><p>另外增加平方运算的目的是为了不让关键字都聚集在某一块区域。我们称这种方法为二次探测法。<br>fi(key)=(f(key)+di)MOD  m(di=12,-12,22,-22,…,q2,-q2,q≤m/2)</p><p>还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法。</p><p>此时一定有人问，既然是随机，那么查找的时候不也随机生成di吗？如何可以获得相同的地址呢？这是个问题。这里的随机其实是伪随机数。伪随机数是说，如果我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，相同的di当然可以得到相同的散列地址。</p><p>fi(key)=(f(key)+di)MOD  m(di是一个随机数列)<br>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。</p><h4 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h4><p>对于我们的散列表来说，我们事先准备多个散列函数。<br>fi(key)=RHi(key)(i=1,2,…,k)</p><p>这里RHi就是不同的散列函数，你可以把我们前面说的什么除留余数、折叠、平方取中全部用上。<br>每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。<br>这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>思路还可以再换一换，为什么有冲突就要换地方呢，我们直接就在原地想办法不可以吗？于是我们就有了链地址法。</p><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。<br>对于关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}，我们用前面同样的12为除数，进行除留余数法，可得到如下图结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。<br><img src="/img/CSDataStructure/222.jpg"></p><p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。<br>当然，这也就带来了查找时需要遍历单链表的性能损耗。</p><h4 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h4><p>这个方法其实就更加好理解，你不是冲突吗？好吧，凡是冲突的都跟我走，我给你们这些冲突找个地儿待着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。<br>就前面的例子而言，我们共有三个关键字{37,48,34}与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如图8-11-2所示。<br><img src="/img/CSDataStructure/223.jpg"><br>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；<br>如果不相等，则到溢出表去进行顺序查找。<br>如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。</p><h3 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h3><p>说了这么多散列表查找的思想，我们就来看看查找的实现代码。</p><h4 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h4><p>首先是需要定义一个散列表的结构以及一些相关的常数。<br>其中HashTable就是散列表结构。<br>结构当中的elem为一个动态数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SUCCESS  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  UNSUCCESS  0</span></span><br><span class="line"><span class="comment">/*  定义散列表长为数组的长度  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  HASHSIZE  12        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  NULLKEY  -32768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  数据元素存储基址，动态分配数组  */</span></span><br><span class="line"><span class="keyword">int</span>  *elem;                  </span><br><span class="line"><span class="comment">/*  当前数据元素个数  */</span></span><br><span class="line"><span class="keyword">int</span>  count;                  </span><br><span class="line">&#125;  HashTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  散列表表长，全局变量  */</span></span><br><span class="line"><span class="keyword">int</span>  m  =  <span class="number">0</span>;           </span><br></pre></td></tr></table></figure><p>有了结构的定义，我们可以对散列表进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始化散列表  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InitHashTable</span><span class="params">(HashTable  *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line">m  =  HASHSIZE;</span><br><span class="line">H-&gt;count  =  m;</span><br><span class="line">H-&gt;elem  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(m  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  m;  i++)</span><br><span class="line">&#123;</span><br><span class="line">H-&gt;elem[i]  =  NULLKEY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  散列函数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Hash</span><span class="params">(<span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  除留余数法  */</span></span><br><span class="line"><span class="keyword">return</span>  key  %  m;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后，我们可以对散列表进行插入操作。<br>假设我们插入的关键字集合就是前面的{12,67,56,16,25,37,22,29,15,47,48,34}。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入关键字进散列表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InsertHash</span><span class="params">(HashTable  *H,  <span class="keyword">int</span>  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  求散列地址  */</span></span><br><span class="line"><span class="keyword">int</span>  addr  =  Hash(key);    </span><br><span class="line">                          </span><br><span class="line"><span class="comment">/*  如果不为空，则冲突  */</span></span><br><span class="line"><span class="keyword">while</span>  (H-&gt;elem[addr]  !=  NULLKEY)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  开放定址法的线性探测  */</span></span><br><span class="line">addr  =  (addr  +  <span class="number">1</span>)  %  m;</span><br><span class="line">&#125;                   </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*  直到有空位后插入关键字  */</span></span><br><span class="line">H-&gt;elem[addr]  =  key;                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。<br>此时我们应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其他解决冲突的办法。</p><p>散列表存在后，我们在需要时就可以通过散列表查找要的记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  散列表查找关键字  */</span></span><br><span class="line"><span class="function">Status  <span class="title">SearchHash</span><span class="params">(HashTable  H,  <span class="keyword">int</span>  key,  <span class="keyword">int</span>  *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  求散列地址  */</span></span><br><span class="line">*addr  =  Hash(key);  </span><br><span class="line">                          </span><br><span class="line"><span class="comment">/*  如果不为空，则冲突  */</span></span><br><span class="line"><span class="keyword">while</span>  (H.elem[*addr]  !=  key)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  开放定址法的线性探测  */</span></span><br><span class="line">*addr  =  (*addr  +  <span class="number">1</span>)  %  m;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (H.elem[*addr]  ==  NULLKEY  ||  *addr  ==  Hash(key))</span><br><span class="line">&#123;                                                      </span><br><span class="line"><span class="comment">/*  如果循环回到原点  */</span></span><br><span class="line"><span class="comment">/*  则说明关键字不存在  */</span></span><br><span class="line"><span class="keyword">return</span>  UNSUCCESS;              </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的代码与插入的代码非常类似，只需做一个不存在关键字的判断而已。</p><h4 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h4><p>最后，我们对散列表查找的性能作一个简单分析。<br>如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)。<br>可惜，我说的只是“如果”，没有冲突的散列只是一种理想，在实际的应用中，冲突是不可避免的。</p><p>那么散列查找的平均查找长度取决于哪些因素呢？</p><p>1．散列函数是否均匀<br>散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</p><p>2．处理冲突的方法<br>相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。<br>比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</p><p>3．散列表的装填因子<br>所谓的装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满的程度。当填入表中的记录越多，α就越大，产生冲突的可能性就越大。比如我们前面的例子，如果你的散列表长度是12，而填入表中的记录个数为11，那么此时的装填因子α=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。<br>不管记录个数n有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是O(1)了。<br>为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;p&gt;查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。&lt;/p&gt;
&lt;h2 id=&quot;查找概述</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="查找" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（图）</title>
    <link href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure4(%E5%9B%BE)/"/>
    <id>https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure4(%E5%9B%BE)/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-21T14:54:36.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-图"><a href="#Chapter-7-图" class="headerlink" title="Chapter 7 图"></a>Chapter 7 图</h1><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><h2 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>对于图的定义，我们需要明确几个注意的地方。<br>    线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。<br>    线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。<br>    线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</p><h2 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h2><h3 id="无向边"><a href="#无向边" class="headerlink" title="无向边"></a>无向边</h3><p>若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对(vi,vj)来表示。<br>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。<br><img src="/img/CSDataStructure/100.jpg"><br>上图就是一个无向图，由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D)，也可以写成(D,A)。<br>对于图中的无向图G1来说，G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}</p><p>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2条边。</p><h3 id="有向边"><a href="#有向边" class="headerlink" title="有向边"></a>有向边</h3><p>若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧（Arc）。<br>用有序偶&lt;vi,vj&gt;来表示，vi称为弧尾（Tail），vj称为弧头（Head）。<br>如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。<br><img src="/img/CSDataStructure/101.jpg"><br>上图就是一个有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，注意不能写成&lt;D,A&gt;。<br>对于图中的有向图G2来说，G2=(V2,{E2})，其中顶点集合V2={A,B,C,D}；弧集合E2={&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;}。<br>无向边用小括号“()”表示，而有向边则是用尖括号“&lt;&gt;”表示。<br>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</p><p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×(n-1)条边。<br>从这里也可以得到结论，对于具有n个顶点和e条边数的图，无向图0≤e≤n(n-1)/2，有向图0≤e≤n(n-1)。</p><p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网（Network）。</p><p>假设有两个图G=(V,{E})和G’=(V’,{E’})，如果V’V且E’E，则称G’为G的子图（Sub-graph）。例如图，带底纹的图均为左侧无向图与有向图的子图。<br><img src="/img/CSDataStructure/102.jpg"></p><h2 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h2><p>对于无向图G=(V,{E})，如果边(v,v’)∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。<br>边(v,v’)依附（incident）于顶点v和v’，或者说(v,v’)与顶点v和v’相关联。<br>顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。</p><p><img src="/img/CSDataStructure/103.jpg"><br>例如图左侧上方的无向图，顶点A与B互为邻接点，边(A,B)依附于顶点A与B上，顶点A的度为3。而此图的边数是5，各个顶点度的和=3+2+3+2=10，推敲后发现，边数其实就是各顶点度数和的一半，多出的一半是因为重复两次记数。</p><p>对于有向图G=(V,{E})，如果弧&lt;v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v,v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID(v)；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)；顶点v的度为TD(v)=ID(v)+OD(v)。</p><p>无向图G=(V,{E})中从顶点v到顶点v’的路径（Path）是一个顶点序列(v=vi,0,vi,1,…,vi,m=v’)，其中(vi,j-1,vi,j)∈E，1≤j≤m。例如图中就列举了顶点B到顶点D四种不同的路径。<br>如果G是有向图，则路径也是有向的，顶点序列应满足&lt;vi,j-1,vi,j&gt;∈E，1≤j≤m。</p><p>第一个顶点和最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p><h2 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h2><p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图（Connected Graph）。</p><p>无向图中的极大连通子图称为连通分量。注意连通分量的概念，它强调：<br>要是子图；<br>子图要是连通的；<br>连通子图含有极大顶点数；<br>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</p><p>在有向图G中，如果对于每一对vi、vj∈V、vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。</p><p>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。<br>比如图的图1是一普通图，但显然它不是生成树，当去掉两条构成环的边后，比如图2或图3，就满足n个顶点n-1条边且连通的定义了。它们都是一棵生成树。<br>从这里也可知道，如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1边条，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。<br>比如图2和图3，随便加哪两顶点的边都将构成环。不过有n-1条边并不一定是生成树，比如图4。<br><img src="/img/CSDataStructure/104.jpg"></p><p>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一个有向树。<br>对有向树的理解比较容易，所谓入度为0其实就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个。<br>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。<br>如图的图1是一棵有向图。去掉一些弧后，它可以分解为两棵有向树，如图2和图3，这两棵就是图1有向图的生成森林。<br><img src="/img/CSDataStructure/105.jpg"></p><h2 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h2><p>图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。</p><p>图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</p><p>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。</p><p>图上的边或弧上带权则称为网。</p><p>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。<br>若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。<br>图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。</p><p>无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</p><h2 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT  图(Graph)</span><br><span class="line">Data</span><br><span class="line">顶点的有穷非空集合和边的集合。</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">CreateGraph</span><span class="params">(*G,  V,  VR)</span>:  按照顶点集V和边弧集VR的定义构造图G。</span></span><br><span class="line"><span class="function"><span class="title">DestroyGraph</span><span class="params">(*G)</span>:          图G存在则销毁。</span></span><br><span class="line"><span class="function"><span class="title">LocateVex</span><span class="params">(G,  u)</span>:          若图G中存在顶点u，则返回图中的位置。</span></span><br><span class="line"><span class="function"><span class="title">GetVex</span><span class="params">(G,  v)</span>:             返回图G中顶点v的值。</span></span><br><span class="line"><span class="function"><span class="title">PutVex</span><span class="params">(G,  v,  value)</span>:     将图G中顶点v赋值value。</span></span><br><span class="line"><span class="function"><span class="title">FirstAdjVex</span><span class="params">(G,  *v)</span>:       返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。</span></span><br><span class="line"><span class="function"><span class="title">NextAdjVex</span><span class="params">(G,  v,  *w)</span>:    返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。</span></span><br><span class="line"><span class="function"><span class="title">InsertVex</span><span class="params">(*G,  v)</span>:         在图G中增添新顶点v。</span></span><br><span class="line"><span class="function"><span class="title">DeleteVex</span><span class="params">(*G,  v)</span>:         删除图G中顶点v及其相关的弧。</span></span><br><span class="line"><span class="function"><span class="title">InsertArc</span><span class="params">(*G,  v,  w)</span>:     在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。</span></span><br><span class="line"><span class="function"><span class="title">DeleteArc</span><span class="params">(*G,  v,  w)</span>:     在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。</span></span><br><span class="line"><span class="function"><span class="title">DFSTraverse</span><span class="params">(G)</span>:            对图G中进行深度优先遍历，在遍历过程对每个顶点调用。</span></span><br><span class="line"><span class="function"><span class="title">HFSTraverse</span><span class="params">(G)</span>:            对图G中进行广度优先遍历，在遍历过程对每个顶点调用。</span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></table></figure><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。<br>而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是有问题的。<br>如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不便。<br>因此，对于图来说，如何对它实现物理存储是个难题，不过我们的前辈们已经解决了，现在我们来看前辈们提供的五种不同的存储结构。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>考虑到图是由顶点和边或弧两部分组成。<br>合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。<br>顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。<br>而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。<br>于是我们的邻接矩阵的方案就诞生了。</p><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。<br>一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p><p>设图G有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：<br><img src="/img/CSDataStructure/106.jpg"></p><p>我们来看一个实例，左图就是一个无向图。<br><img src="/img/CSDataStructure/107.jpg"><br>我们可以设置两个数组，顶点数组为ver-tex[4]={v0,v1,v2,v3}，边数组arc[4][4]为右图这样的一个矩阵。<br>简单解释一下，对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点到自身的边，比如v0到v0。<br>arc[0][1]=1是因为v0到v1的边存在，而arc[1][3]=0是因为v1到v3的边不存在。<br>并且由于是无向图，v1到v3的边不存在，意味着v3到v1的边也不存在。所以无向图的边数组是一个对称矩阵。</p><p>有了这个矩阵，我们就可以很容易地知道图中的信息。<br>1.我们要判定任意两顶点是否有边无边就非常容易了。<br>2.我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。<br>3.求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。</p><p>我们再来看一个有向图样例，如图所示的左图。<br><img src="/img/CSDataStructure/108.jpg"><br>顶点数组为vertex[4]={v0,v1,v2,v3}，弧数组arc[4][4]为右图这样的一个矩阵。主对角线上数值依然为0。<br>但因为是有向图，所以此矩阵并不对称，比如由v1到v0有弧，得到arc[1][0]=1，而v0到v1没有弧，因此arc[0][1]=0。</p><p>有向图讲究入度与出度，顶点v1的入度为1，正好是第v1列各数之和。顶点v1的出度为2，即第v1行的各数之和。</p><p>与无向图同样的办法，判断顶点vi到vj是否存在弧，只需要查找矩阵中arc[i][j]是否为1即可。<br>要求vi的所有邻接点就是将矩阵第i行元素扫描一遍，查找arc[i][j]为1的顶点。</p><p>在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。</p><p>设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：这里wij表示（vi,vj）或&lt;vi,vj&gt;上的权值。<br>∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。<br><img src="/img/CSDataStructure/109.jpg"></p><p>那么邻接矩阵是如何实现图的创建的呢？我们先来看看图的邻接矩阵存储的结构，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  顶点类型应由用户定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">char</span>  VertexType;                          </span><br><span class="line"><span class="comment">/*  边上的权值类型应由用户定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  EdgeType;                                </span><br><span class="line"><span class="comment">/*  最大顶点数，应由用户定义  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXVEX  100                                      </span></span><br><span class="line"><span class="comment">/*  用65535来代表∞  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  INFINITY  65535</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  顶点表  */</span></span><br><span class="line">VertexType  vexs[MAXVEX];                  </span><br><span class="line"><span class="comment">/*  邻接矩阵，可看作边表  */</span></span><br><span class="line">EdgeType  arc[MAXVEX][MAXVEX];        </span><br><span class="line"><span class="comment">/*  图中当前的顶点数和边数  */</span></span><br><span class="line"><span class="keyword">int</span>  numVertexes,  numEdges;              </span><br><span class="line">&#125;  MGraph;</span><br></pre></td></tr></table></figure><p>有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  建立无向网图的邻接矩阵表示  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateMGraph</span><span class="params">(MGraph  *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j,  k,  w;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输入顶点数和边数  */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,  &amp;G-&gt;numVertexes,  &amp;G-&gt;numEdges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  读入顶点信息，建立顶点表  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G-&gt;numVertexes;  i++)                       <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G-&gt;numVertexes;  i++)<span class="keyword">for</span>  (j  =  <span class="number">0</span>;  j  &lt;G-&gt;numVertexes;  j++) <span class="comment">/*  邻接矩阵初始化  */</span>G-&gt;arc[i][j]  =  INFINITY;  </span><br><span class="line">    <span class="comment">/*  读入numEdges条边，建立邻接矩阵  */</span></span><br><span class="line"><span class="keyword">for</span>  (k  =  <span class="number">0</span>;  k  &lt;  G-&gt;numEdges;  k++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i，下标j和权w:\n&quot;</span>);</span><br><span class="line"><span class="comment">/*  输入边(vi,vj)上的权w  */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,  &amp;i,  &amp;j,  &amp;w); </span><br><span class="line">G-&gt;arc[i][j]  =  w;</span><br><span class="line"><span class="comment">/*  因为是无向图，矩阵对称  */</span></span><br><span class="line">G-&gt;arc[j][i]  =  G-&gt;arc[i][j];                                    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n2+e)，其中对邻接矩阵G.arc的初始化耗费了O(n2)的时间。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。</p><p>因此我们考虑另外一种存储结构方式。回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。</p><p>再回忆我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题。这个思路同样适用于图的存储。我们把这种数组与链表相结合的存储方法称为邻接表（Ad-jacency List）。</p><p>邻接表的处理办法是这样。<br>1.图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。<br>另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。<br>2.图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p><p>例如图所示的就是一个无向图的邻接表结构。<br><img src="/img/CSDataStructure/110.jpg"><br>从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。<br>边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。<br>比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。<br><img src="/img/CSDataStructure/111.jpg"></p><p>有了这些结构的图，下面关于结点定义的代码就很好理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  顶点类型应由用户定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">char</span>  VertexType;                    </span><br><span class="line"><span class="comment">/*  边上的权值类型应由用户定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  EdgeType; </span><br><span class="line">                         </span><br><span class="line"><span class="comment">/*  边表结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">EdgeNode</span>                      </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  邻接点域，存储该顶点对应的下标  */</span></span><br><span class="line"><span class="keyword">int</span>  adjvex;                                      </span><br><span class="line"><span class="comment">/*  用于存储权值，对于非网图可以不需要  */</span></span><br><span class="line">EdgeType  weight;                            </span><br><span class="line"><span class="comment">/*  链域，指向下一个邻接点　  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">EdgeNode</span>  *<span class="title">next</span>;</span>                </span><br><span class="line">&#125;  EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  顶点表结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">VertexNode</span>                  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  顶点域，存储顶点信息  */</span></span><br><span class="line">VertexType  data;                            </span><br><span class="line"><span class="comment">/*  边表头指针  */</span>EdgeNode  *firstedge;                    </span><br><span class="line">&#125;  VertexNode,  AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">AdjList  adjList;</span><br><span class="line"><span class="comment">/*  图中当前顶点数和边数  */</span></span><br><span class="line"><span class="keyword">int</span>  numVertexes,  numEdges;        </span><br><span class="line">&#125;  GraphAdjList;</span><br></pre></td></tr></table></figure><p>无向图的邻接表创建代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  建立图的邻接表结构  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">CreateALGraph</span><span class="params">(GraphAdjList  *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j,  k;</span><br><span class="line">EdgeNode  *e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line"><span class="comment">/*  输入顶点数和边数  */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,  &amp;G-&gt;numVertexes,  &amp;G-&gt;numEdges);       </span><br><span class="line"><span class="comment">/*  读入顶点信息，建立顶点表  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G-&gt;numVertexes;  i++)                       </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  输入顶点信息  */</span></span><br><span class="line"><span class="built_in">scanf</span>(&amp;G-&gt;adjList[i].data);                                      </span><br><span class="line"><span class="comment">/*  将边表置为空表  */</span></span><br><span class="line">G-&gt;adjList[i].firstedge  =  <span class="literal">NULL</span>;                              </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  建立边表  */</span></span><br><span class="line"><span class="keyword">for</span>  (k  =  <span class="number">0</span>;  k  &lt;  G-&gt;numEdges;  k++)                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的顶点序号:\n&quot;</span>);</span><br><span class="line"><span class="comment">/*  输入边(vi,vj)上的顶点序号  */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,  &amp;i,  &amp;j);</span><br><span class="line">       <span class="comment">/*  向内存申请空间，  */</span></span><br><span class="line"><span class="comment">/*  生成边表结点  */</span></span><br><span class="line">e  =  (EdgeNode  *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));          </span><br><span class="line"><span class="comment">/*  邻接序号为j  */</span></span><br><span class="line">e-&gt;adjvex  =  j;                                                  </span><br><span class="line"><span class="comment">/*  将e指针指向当前顶点指向的结点  */</span></span><br><span class="line">e-&gt;next  =  G-&gt;adjList[i].firstedge; </span><br><span class="line"><span class="comment">/*  将当前顶点的指针指向e  */</span></span><br><span class="line">G-&gt;adjList[i].firstedge  =  e;                                    </span><br><span class="line"><span class="comment">/*  向内存申请空间，  */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O(n+e)。    </span><br></pre></td></tr></table></figure><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>那么对于有向图来说，邻接表是有缺陷的。<br>关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。<br>有没有可能把邻接表与逆邻接表结合起来呢？答案是肯定的，就是把它们整合在一起。<br>这就是我们现在要讲的有向图的一种存储方法：十字链表（Orthogonal List）。</p><p>我们重新定义顶点表结点结构如表所示。<br>data  firstin  firstout<br>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p>重新定义的边表结点结构如表所示。<br>tailvex headvex headlink taillink<br>其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。<br>如果是网，还可以再增加一个weight域来存储权值。</p><p><img src="/img/CSDataStructure/112.jpg"><br>如图，顶点依然是存入一个一维数组{v0,v1,v2,v3}。<br>就以顶点v0来说，firstout指向的是出边表中的第一个结点v3。所以v0边表结点的headvex=3，而tailvex其实就是当前顶点v0的下标0，由于v0只有一个出边顶点，所以headlink和taillink都是空。</p><p>我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。<br>对于v0来说，它有两个顶点v1和v2的入边。因此v0的firstin指向顶点v1的边表结点中headvex为0的结点，如图7-4-10右图中的①。<br>接着由入边结点的headlink指向下一个入边顶点v2，如图中的②。<br>对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如图中的③。<br>顶点v2和v3也是同样有一个入边顶点，如图中④和⑤。</p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。<br>而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？<br>如果我们在无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注边的操作，比如对已访问过的边做标记，删除某一条边等操作，那就意味着，需要找到这条边的两个边表结点进行操作，这其实还是比较麻烦的。<br>比如图，若要删除左图的(v0,v2)这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较烦琐的。<br><img src="/img/CSDataStructure/113.jpg"></p><p>因此，我们也仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。<br>重新定义的边表结点结构如下所示。<br>ivex    ilink    jvex    jlink<br>其中ivex和jvex是与某条边依附的两个顶点在顶点表中的下标。<br>ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。<br>这就是邻接多重表结构。</p><p>我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表构造原理了。<br>如图所示，左图告诉我们它有4个顶点和5条边，显然，我们就应该先将4个顶点和5条边的边表结点画出来。<br>由于是无向图，所以ivex是0、jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的顶点下标相同。<br><img src="/img/CSDataStructure/114.jpg"></p><p>我们开始连线，如图所示。<br>首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，这很好理解。<br>接着，由于顶点v0的(v0,v1)边的邻边有(v0,v3)和(v0,v2)。因此⑤⑥的连线就是满足指向下一条依附于顶点v0的边的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。<br>同样的道理，连线⑦就是指(v1,v0)这条边，它是相当于顶点v1指向(v1,v2)边后的下一条。<br>v2有三条边依附，所以在③之后就有了⑧⑨。<br>连线⑩的就是顶点v3在连线④之后的下一条边。<br>左图一共有5条边，所以右图有10条连线，完全符合预期。<br><img src="/img/CSDataStructure/115.jpg"><br>到这里，大家应该可以明白，邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。<br>这样对边的操作就方便多了，若要删除左图的(v0,v2)这条边，只需要将图中的⑥⑨的链接指向改为∧即可。</p><h3 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h3><p>边集数组是由两个一维数组构成。<br>一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成，如图所示。<br>显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。<br>因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。<br><img src="/img/CSDataStructure/116.jpg"></p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历（Depth_First_Search），也有称为深度优先搜索，简称为DFS。<br><img src="/img/CSDataStructure/117.jpg"><br>如果我们用的是邻接矩阵的方式，则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Boolean是布尔类型，其值是TRUE或FALSE  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  Boolean;                         </span><br><span class="line"><span class="comment">/*  访问标志的数组  */</span></span><br><span class="line">Boolean  visited[MAX];</span><br><span class="line">                        </span><br><span class="line"><span class="comment">/*  邻接矩阵的深度优先递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DFS</span><span class="params">(MGraph  G,  <span class="keyword">int</span>  i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j;</span><br><span class="line">visited[i]  =  TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印顶点，也可以其他操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  G.vexs[i]);  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">0</span>;  j  &lt;  G.numVertexes;  j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (G.arc[i][j]  ==  <span class="number">1</span>  &amp;&amp;  !visited[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  对为访问的邻接顶点递归调用  */</span></span><br><span class="line">DFS(G,  j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;                      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  邻接矩阵的深度遍历操作  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DFSTraverse</span><span class="params">(MGraph  G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始所有顶点状态都是未访问过状态  */</span>visited[i]  =  FALSE; </span><br><span class="line">&#125;           </span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  对未访问过的顶点调用DFS，若是连通图，只会执行一次  */</span></span><br><span class="line"><span class="keyword">if</span>  (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line"> DFS(G,  i);</span><br><span class="line">&#125;                 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图结构是邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  邻接表的深度优先递归算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DFS</span><span class="params">(GraphAdjList  GL,  <span class="keyword">int</span>  i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode  *p;</span><br><span class="line">visited[i]  =  TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印顶点，也可以其他操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  GL-&gt;adjList[i].data); </span><br><span class="line">       </span><br><span class="line">p  =  GL-&gt;adjList[i].firstedge;</span><br><span class="line"><span class="keyword">while</span>  (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (!visited[p-&gt;adjvex])<span class="comment">/*  对未访问的邻接顶点递归调用  */</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(GL,  p-&gt;adjvex);</span><br><span class="line">&#125;                        </span><br><span class="line">p  =  p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  邻接表的深度遍历操作  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DFSTraverse</span><span class="params">(GraphAdjList  GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始所有顶点状态都是未访问过状态  */</span></span><br><span class="line">visited[i]  =  FALSE;</span><br><span class="line">&#125;                                </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  对未访问过的顶点调用DFS，若是连通图，只会执行一次  */</span></span><br><span class="line"><span class="keyword">if</span>  (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line">DFS(GL,  i);</span><br><span class="line">&#125;                                      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n2)的时间。<br>而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。<br><img src="/img/CSDataStructure/118.jpg"><br>以下是邻接矩阵结构的广度优先遍历算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  邻接矩阵的广度遍历算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BFSTraverse</span><span class="params">(MGraph  G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line">Queue  Q;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line">visited[i]  =  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  初始化一辅助用的队列  */</span></span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对每一个顶点做循环  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numVertexes;  i++)                            </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若是未访问过就处理  */</span></span><br><span class="line"><span class="keyword">if</span>  (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  设置当前顶点访问过  */</span></span><br><span class="line">visited[i]=TRUE;                                                  </span><br><span class="line"><span class="comment">/*  打印顶点，也可以其他操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  G.vexs[i]);                                </span><br><span class="line"><span class="comment">/*  将此顶点入队列  */</span></span><br><span class="line">EnQueue(&amp;Q,i);                                                      </span><br><span class="line"><span class="comment">/*  若当前队列不为空  */</span></span><br><span class="line"><span class="keyword">while</span>  (!QueueEmpty(Q))                                      </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将队中元素出队列，赋值给i  */</span></span><br><span class="line">DeQueue(&amp;Q,  &amp;i);                                          </span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">0</span>;  j  &lt;  G.numVertexes;  j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  判断其他顶点若与当前顶点存在边且未访问过  */</span></span><br><span class="line"><span class="keyword">if</span>  (G.arc[i][j]  ==  <span class="number">1</span>  &amp;&amp;  !visited[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将找到的此顶点标记为已访问  */</span></span><br><span class="line">visited[j]=TRUE;                          </span><br><span class="line"><span class="comment">/*  打印顶点  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  G.vexs[j]);        </span><br><span class="line"><span class="comment">/*  将找到的此顶点入队列  */</span></span><br><span class="line">EnQueue(&amp;Q,j); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">```</span><br><span class="line">对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*  邻接表的广度遍历算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BFSTraverse</span><span class="params">(GraphAdjList  GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line">EdgeNode  *p;</span><br><span class="line">Queue  Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line">visited[i]  =  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line">visited[i]  =  TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印顶点，也可以其他操作  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  GL-&gt;adjList[i].data);        </span><br><span class="line">EnQueue(&amp;Q,  i);</span><br><span class="line"><span class="keyword">while</span>  (!QueueEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;Q,  &amp;i);</span><br><span class="line"><span class="comment">/*  找到当前顶点边表链表头指针  */</span></span><br><span class="line">p  =  GL-&gt;adjList[i].firstedge;           </span><br><span class="line"> <span class="keyword">while</span>  (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若此顶点未被访问  */</span></span><br><span class="line"><span class="keyword">if</span>  (!visited[p-&gt;adjvex])              </span><br><span class="line">&#123;</span><br><span class="line">visited[p-&gt;adjvex]  =  TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>,  GL-&gt;adjList[p-&gt;adjvex].data);</span><br><span class="line"><span class="comment">/*  将此顶点入队列  */</span>EnQueue(&amp;Q,  p-&gt;adjvex);       </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*  指针指向下一个邻接点  */</span></span><br><span class="line">p  =  p-&gt;next;                                      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。<br>可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。<br>不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。<br>深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost SpanningTree）。</p><h3 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h3><p><img src="/img/CSDataStructure/119.jpg"><br>普里姆（Prim）算法代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Prim算法生成最小生成树  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph  G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  min,  i,  j,  k;</span><br><span class="line"><span class="comment">/*  保存相关顶点下标  */</span></span><br><span class="line"><span class="keyword">int</span>  adjvex[MAXVEX];                                                </span><br><span class="line"><span class="comment">/*  保存相关顶点间边的权值  */</span></span><br><span class="line"><span class="keyword">int</span>  lowcost[MAXVEX];                                              </span><br><span class="line"><span class="comment">/*  初始化第一个权值为0，即v0加入生成树  */</span></span><br><span class="line"><span class="comment">/*  lowcost的值为0，在这里就是此下标的顶点已经加入生成树  */</span></span><br><span class="line">lowcost[<span class="number">0</span>]  =  <span class="number">0</span>;                                                        </span><br><span class="line"><span class="comment">/*  初始化第一个顶点下标为0  */</span></span><br><span class="line">adjvex[<span class="number">0</span>]  =  <span class="number">0</span>;</span><br><span class="line">                                                          </span><br><span class="line"><span class="comment">/*  循环除下标为0外的全部顶点  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  G.numVertexes;  i++)            </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将v0顶点与之有边的权值存入数组  */</span></span><br><span class="line">lowcost[i]  =  G.arc[<span class="number">0</span>][i];                            </span><br><span class="line"><span class="comment">/*  初始化都为v0的下标  */</span></span><br><span class="line">adjvex[i]  =  <span class="number">0</span>;                                       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  G.numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始化最小权值为∞，  */</span></span><br><span class="line"><span class="comment">/*  通常设置为不可能的大数字如32767、65535等  */</span></span><br><span class="line">min  =  INFINITY;                                      </span><br><span class="line">j  =  <span class="number">1</span>;  k  =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  循环全部顶点  */</span></span><br><span class="line"><span class="keyword">while</span>  (j  &lt;  G.numVertexes)                           </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  如果权值不为0且权值小于min  */</span></span><br><span class="line"><span class="keyword">if</span>  (lowcost[j]  !=  <span class="number">0</span>  &amp;&amp;  lowcost[j]  &lt;  min)</span><br><span class="line">&#123;                                                      </span><br><span class="line"><span class="comment">/*  则让当前权值成为最小值  */</span></span><br><span class="line">min  =  lowcost[j];                            </span><br><span class="line"><span class="comment">/*  将当前最小值的下标存入k  */</span></span><br><span class="line">k  =  j;                                               </span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印当前顶点边中权值最小边  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,  adjvex[k],  k);              </span><br><span class="line"><span class="comment">/*  将当前顶点的权值设置为0，表示此顶点已经完成任务  */</span></span><br><span class="line">lowcost[k]  =  <span class="number">0</span>; </span><br><span class="line">                                     </span><br><span class="line"><span class="comment">/*  循环所有顶点  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">1</span>;  j  &lt;  G.numVertexes;  j++)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值  */</span></span><br><span class="line"><span class="keyword">if</span>  (lowcost[j]  !=  <span class="number">0</span>  &amp;&amp;  G.arc[k][j]  &lt;  lowcost[j])</span><br><span class="line">&#123;                                                      </span><br><span class="line"><span class="comment">/*  将较小权值存入lowcost  */</span></span><br><span class="line">lowcost[j]  =  G.arc[k][j];            </span><br><span class="line"><span class="comment">/*  将下标为k的顶点存入adjvex  */</span></span><br><span class="line">adjvex[j]  =  k;                                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，我们由第4～5行，创建了两个一维数组lowcost和adjvex，长度都为顶点个数9。</p><p>2．<br>第6～7行我们分别给这两个数组的第一个下标位赋值为0，adjvex[0]=0其实意思就是我们现在从顶点v0开始（事实上，最小生成树从哪个顶点开始计算都无所谓，我们假定从v0开始），lowcost[0]=0就表示v0已经被纳入到最小生成树中，之后凡是lowcost数组中的值被设置为0就是表示此下标的顶点被纳入最小生成树。</p><p>3．<br>第8～12行表示我们读取邻接矩阵的第一行数据。<br>将数值赋值给lowcost数组，所以此时lowcost数组值为{0,10,65535,65535,65535,11,65535,65535,65535}，而adjvex则全部为0。<br>此时，我们已经完成了整个初始化的工作，准备开始生成。</p><p>4．<br>第13～36行，整个循环过程就是构造最小生成树的过程。</p><p>5．<br>第15～16行，将min设置为了一个极大值65535，它的目的是为了之后找到一定范围内的最小权值。<br>j是用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标。</p><p>6．<br>第17～25行，循环中不断修改min为当前lowcost数组中最小值，并用k保留此最小值的顶点下标。经过循环后，min=10，k=1。<br>注意19行if判断的lowcost[j]!=0表示已经是生成树的顶点不参与最小权值的查找。</p><p>7．<br>第26行，因k=1，adjvex[1]=0，所以打印结果为(0,1)，表示v0至v1边为最小生成树的第一条边。如图所示。<br><img src="/img/CSDataStructure/120.jpg"></p><p>8．<br>第27行，此时因k=1我们将lowcost[k]=0就是说顶点v1纳入到最小生成树中。<br>此时lowcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}。</p><p>9．<br>第28～35行，j循环由1至8，因k=1，查找邻接矩阵的第v1行的各个权值，与low-cost的对应值比较，若更小则修改low-cost值，并将k值存入adjvex数组中。<br>因第v1行有18、16、12均比65535小，所以最终lowcost数组的值为：{0,0,18,65535,65535,11,16,65535,12}。adjvex数组的值为：{0,0,1,0,0,0,1,0,1}。<br>这里第30行if判断的lowcost[j]!=0也说明v0和v1已经是生成树的顶点不参与最小权值的比对了。</p><p>10．再次循环，由第15行到第26行，此时min=11，k=5，adjvex[5]=0。因此打印结构为(0,5)。<br>表示v0至v5边为最小生成树的第二条边，如图所示。<br><img src="/img/CSDataStructure/121.jpg"></p><p>11．接下来执行到36行，lowcost数组的值为：{0,0,18,65535,26,0,16,65535,12}。ad-jvex数组的值为：{0,0,1,0,5,0,1,0,1}。</p><p>12．之后，相信大家也都会自己去模拟了。通过不断的转换，构造的过程如图中图1～图6所示。<br><img src="/img/CSDataStructure/122.jpg"></p><p>有了这样的讲解，再来介绍普里姆（Prim）算法的实现定义可能就容易理解一些。</p><p>假设N=(V,{E})是连通网，TE是N上最小生成树中边的集合。算法从U={u0}(u0∈V)，TE={}开始。重复执行下述操作：在所有u∈U,v∈V-U的边(u,v)∈E中找一条代价最小的边(u0,v0)并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树。</p><p>由算法代码中的循环嵌套可得知此算法的时间复杂度为O(n2)。</p><h3 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h3><p>现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。</p><p>同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。<br>此时我们就用到了图的存储结构中的边集数组结构。</p><p>以下是edge边集数组结构的定义代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对边集数组Edge结构的定义  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>  begin;</span><br><span class="line"><span class="keyword">int</span>  end;</span><br><span class="line"><span class="keyword">int</span>  weight;</span><br><span class="line">&#125;  Edge;</span><br></pre></td></tr></table></figure><p>我们将之前的邻接矩阵通过程序转化为下图右图的边集数组，并且对它们按权值从小到大排序。<br><img src="/img/CSDataStructure/123.jpg"></p><p>于是克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。<br>其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。<br>现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入上图右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Kruskal算法生成最小生成树  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  生成最小生成树  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MiniSpanTree_Kruskal</span><span class="params">(MGraph  G)</span>          </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  n,  m;</span><br><span class="line"><span class="comment">/*  定义边集数组  */</span></span><br><span class="line">Edge  edges[MAXEDGE];                                </span><br><span class="line"><span class="comment">/*  定义一数组用来判断边与边是否形成环路  */</span></span><br><span class="line"><span class="keyword">int</span>  parent[MAXVEX];                                  </span><br><span class="line"><span class="comment">/*  此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始化数组值为0  */</span></span><br><span class="line">parent[i]  =  <span class="number">0</span>;     </span><br><span class="line">&#125;</span><br><span class="line">                               </span><br><span class="line"><span class="comment">/*  循环每一条边  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  G.numEdges;  i++)        </span><br><span class="line">&#123;</span><br><span class="line">n  =  Find(parent,  edges[i].begin);</span><br><span class="line">m  =  Find(parent,  edges[i].end);</span><br><span class="line"><span class="comment">/*  假如n与m不等，说明此边没有与现有生成树形成环路  */</span></span><br><span class="line"><span class="keyword">if</span>  (n  !=  m)                                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将此边的结尾顶点放入下标为起点的parent中  */</span></span><br><span class="line"><span class="comment">/*  表示此顶点已经在生成树集合中  */</span></span><br><span class="line">parent[n]  =  m;                            </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,  %d)  %d  &quot;</span>,  edges[i].begin,  edges[i].end,  edges[i].weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  查找连线顶点的尾部下标  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Find</span><span class="params">(<span class="keyword">int</span>  *parent,  <span class="keyword">int</span>  f)</span>                        </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>  (parent[f]  &gt;  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">f  =  parent[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，第5行之后，我们省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，在第5行开始，我们已经有了结构为edge，数据内容是前图的右图的一维数组edges。</p><p>2．<br>第5～7行，我们声明一个数组parent，并将它的值都初始化为0，它的作用我们后面慢慢说。</p><p>3．<br>第8～17行，我们开始对边集数组做循环遍历，开始时，i=0。</p><p>4．<br>第10行，我们调用了第19～25行的函数Find，传入的参数是数组parent和当前权值最小边(v4,v7)的begin:4。<br>因为parent中全都是0所以传出值使得n=4。</p><p>5．<br>第11行，同样作法，传入(v4,v7)的end:7。<br>传出值使得m=7。</p><p>6．<br>第12～16行，很显然n与m不相等，因此parent[4]=7。<br>此时parent数组值为{0,0,0,0,7,0,0,0,0}，并且打印得到“(4,7)7”。<br>此时我们已经将边(v4,v7)纳入到最小生成树中，如图所示。<br><img src="/img/CSDataStructure/124.jpg"></p><p>7．<br>循环返回，执行10～16行，此时i=1，edge[1]得到边(v2,v8)，n=2，m=8，parent[2]=8，打印结果为“(2,8)8”，此时parent数组值为{0,0,8,0,7,0,0,0,0}，这也就表示边(v4,v7)和边(v2,v8)已经纳入到最小生成树，如图所示。<br><img src="/img/CSDataStructure/125.jpg"></p><p>8．<br>再次执行10～16行，此时i=2，edge[2]得到边(v0,v1)，n=0，m=1，parent[0]=1，打印结果为“(0,1)10”，此时parent数组值为{1,0,8,0,7,0,0,0,0}，此时边(v4,v7)、(v2,v8)和(v0,v1)已经纳入到最小生成树，如图所示。<br><img src="/img/CSDataStructure/126.jpg"></p><p>9．<br>当i=3、4、5、6时，分别将边(v0,v5)、(v1,v8)、(v3,v7)、(v1,v6)纳入到最小生成树中，如图所示。<br>此时parent数组值为{1,5,8,7,7,8,0,0,6}，怎么去解读这个数组现在这些数字的意义呢？<br><img src="/img/CSDataStructure/127.jpg"><br>从上图的右下方的图i=6的粗线连线可以得到，我们其实是有两个连通的边集合A与B中纳入到最小生成树中的，如下图所示。<br>当parent[0]=1，表示v0和v1已经在生成树的边集合A中。<br>此时将parent[0]=1的1改为下标，由parent[1]=5，表示v1和v5在边集合A中，parent[5]=8表示v5与v8在边集合A中，parent[8]=6表示v8与v6在边集合A中，parent[6]=0表示集合A暂时到头，此时边集合A有v0、v1、v5、v8、v6。<br>我们查看parent中没有查看的值，parent[2]=8表示v2与v8在一个集合中，因此v2也在边集合A中。<br>再由parent[3]=7、parent[4]=7和parent[7]=0可知v3、v4、v7在另一个边集合B中。</p><p>10．<br>当i=7时，第10行，调用Find函数，会传入参数edges[7].begin=5。<br>此时第21行，parent[5]=8&gt;0，所以f=8，再循环得parent[8]=6。<br>因parent[6]=0所以Find返回后第10行得到n=6。<br>而此时第11行，传入参数edges[7].end=6得到m=6。此时n=m，不再打印，继续下一循环。<br>这就告诉我们，因为边(v5,v6)使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</p><p>11．<br>当i=8时，与上面相同，由于边(v1,v2)使得边集合A形成了环路。<br>因此不能将它纳入到最小生成树中，如上图所示。</p><p>12．<br>当i=9时，边(v6,v7)，第10行得到n=6，第11行得到m=7，因此parent[6]=7，打印“(6,7)19”。此时parent数组值为{1,5,8,7,7,8,7,0,6}，如图所示。</p><p>13．<br>此后边的循环均造成环路，最终最小生成树即为图所示。<br><img src="/img/CSDataStructure/128.jpg"></p><p>好了，我们来把克鲁斯卡尔（Kruskal）算法的实现定义归纳一下结束这一节的讲解。</p><p>假设N=(V,{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。</p><p>此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次。所以克鲁斯卡尔算法的时间复杂度为O(eloge)。</p><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>在网图和非网图中，最短路径的含义是不同的。<br>由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。<br>显然，我们研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。<br>而非网图完全可以理解为所有的边的权值都为1的网。</p><h3 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h3><p>这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。</p><p>比如说要求下图中顶点v0到顶点v1的最短距离，没有比这更简单的了，答案就是1，路径就是直接v0连线到v1。<br><img src="/img/CSDataStructure/129.jpg"></p><p>由于顶点v1还与v2、v3、v4连线，所以此时我们同时求得了v0→v1→v2=1+3=4，v0→v1→ v3=1+7=8，v0→v1→v4=1+5=6。<br>现在，我问v0到v2的最短距离，如果你不假思索地说是5，那就犯错了。<br>因为边上都有权值，刚才已经有v0→v1→v2的结果是4，比5还要小1个单位，它才是最短距离，如图所示。<br><img src="/img/CSDataStructure/130.jpg"></p><p>由于顶点v2还与v4、v5连线，所以此时我们同时求得了v0→v2→v4其实就是v0→v1→v2→v4=4+1=5，v0→v2→v5=4+7=11。<br>这里v0→v2我们用的是刚才计算出来的较小的4。<br>此时我们也发现v0→v1→v2→v4=5要比v0→v1→v4=6还要小。<br>所以v0到v4目前的最小距离是5，如图所示。<br><img src="/img/CSDataStructure/131.jpg"></p><p>当我们要求v0到v3的最短距离时，通向v3的三条边，除了v6没有研究过外，v0→v1→v3的结果是8，而v0→v4→v3=5+2=7。<br>因此，v0到v3的最短距离是7，如图所示。<br><img src="/img/CSDataStructure/132.jpg"></p><p>好了，我想你大致明白，这个迪杰斯特拉（Di-jkstra）算法是如何干活的了。<br>它并不是一下子就求出了v0到v8的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXVEX  9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  INFINITY  65535</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  </span><br><span class="line"><span class="comment">/*  用于存储最短路径下标的数组  */</span></span><br><span class="line">Patharc[MAXVEX];                                              </span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  </span><br><span class="line"><span class="comment">/*  用于存储到各点最短路径的权值和  */</span></span><br><span class="line">ShortPathTable[MAXVEX];</span><br><span class="line">                                </span><br><span class="line"><span class="comment">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v]  */</span></span><br><span class="line"><span class="comment">/*  P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和。  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph  G,  <span class="keyword">int</span>  v0,  Patharc  *P,  ShortPathTable  *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  v,  w,  k,  min;</span><br><span class="line"><span class="comment">/*  final[w]=1表示求得顶点v0至vw的最短路径  */</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">final</span>[MAXVEX];                                                    </span><br><span class="line"><span class="comment">/*  初始化数据  */</span></span><br><span class="line"><span class="keyword">for</span>  (v  =  <span class="number">0</span>;  v  &lt;  G.numVertexes;  v++)                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  全部顶点初始化为未知最短路径状态  */</span></span><br><span class="line"><span class="keyword">final</span>[v]  =  <span class="number">0</span>;                                                      </span><br><span class="line"><span class="comment">/*  将与v0点有连线的顶点加上权值  */</span></span><br><span class="line">(*D)[v]  =  G.arc[v0][v];                                  </span><br><span class="line"><span class="comment">/*  初始化路径数组P为-1  */</span></span><br><span class="line">(*P)[v]  =  <span class="number">-1</span>;                                                      </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  v0至v0路径为0  */</span></span><br><span class="line">(*D)[v0]  =  <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/*  v0至v0不需要求路径  */</span></span><br><span class="line"><span class="keyword">final</span>[v0]  =  <span class="number">1</span>;</span><br><span class="line">                                                            </span><br><span class="line"><span class="comment">/*  开始主循环，每次求得v0到某个v顶点的最短路径  */</span></span><br><span class="line"><span class="keyword">for</span>  (v  =  <span class="number">1</span>;  v  &lt;  G.numVertexes;  v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  当前所知离v0顶点的最近距离  */</span></span><br><span class="line">min=INFINITY;                                                      </span><br><span class="line"><span class="comment">/*  寻找离v0最近的顶点  */</span></span><br><span class="line"><span class="keyword">for</span>  (w  =  <span class="number">0</span>;  w  &lt;  G.numVertexes;  w++)          </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (!<span class="keyword">final</span>[w]  &amp;&amp;  (*D)[w]  &lt;  min)</span><br><span class="line">&#123;</span><br><span class="line">k=w;</span><br><span class="line"><span class="comment">/*  w顶点离v0顶点更近  */</span></span><br><span class="line">min  =  (*D)[w];                                    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  将目前找到的最近的顶点置为1  */</span></span><br><span class="line"><span class="keyword">final</span>[k]  =  <span class="number">1</span>;                                                      </span><br><span class="line"><span class="comment">/*  修正当前最短路径及距离  */</span></span><br><span class="line"><span class="keyword">for</span>  (w  =  <span class="number">0</span>;  w  &lt;  G.numVertexes;  w++)          </span><br><span class="line">&#123;      </span><br><span class="line"><span class="comment">/*  如果经过v顶点的路径比现在这条路径的长度短的话  */</span></span><br><span class="line"><span class="keyword">if</span>  (!<span class="keyword">final</span>[w]  &amp;&amp;  (min  +  G.arc[k][w]  &lt;  (*D)[w]))</span><br><span class="line">&#123;                                                                      </span><br><span class="line"><span class="comment">/*  说明找到了更短的路径，修改D[w]和P[w]  */</span></span><br><span class="line"><span class="comment">/*  修改当前路径长度  */</span></span><br><span class="line">(*D)[w]  =  min  +  G.arc[k][w];        </span><br><span class="line">(*P)[w]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此函数前，我们需要为下图的左图准备邻接矩阵MGraph的G，如下图的右图，并且定义参数v0为0。<br><img src="/img/CSDataStructure/133.jpg"></p><p>1．<br>程序开始运行，第4行final数组是为了v0到某顶点是否已经求得最短路径的标记，如果v0到vw已经有结果，则final[w]=1。</p><p>2．<br>第5～10行，是在对数据进行初始化的工作。<br>此时final数组值均为0，表示所有的点都未求得最短路径。<br>D数组为{65535,1,5,65535,65535,65535,65535,65535,65535}。<br>因为v0与v1和v2的边权值为1和5。<br>P数组全为0，表示目前没有路径。</p><p>3．<br>第11行，表示v0到v0自身，权值和结果为0。<br>D数组为{0,1,5,65535,65535,65535,65535,65535,65535}。<br>第12行，表示v0点算是已经求得最短路径，因此final[0]=1。<br>此时final数组为{1,0,0,0,0,0,0,0,0}。此时整个初始化工作完成。</p><p>4．<br>第13～33行，为主循环，每次循环求得v0与一个顶点的最短路径。因此v从1而不是0开始。</p><p>5．<br>第15～23行，先令min为65535的极大值，通过w循环，与D[w]比较找到最小值min=1，k=1。</p><p>6．<br>第24行，由k=1，表示与v0最近的顶点是v1，并且由D[1]=1，知道此时v0到v1的最短距离是1。因此将v1对应的final[1]设置为1。此时final数组为{1,1,0,0,0,0,0,0,0}。</p><p>7．<br>第25～32行是一循环，此循环甚为关键。<br>它的目的是在刚才已经找到v0与v1的最短路径的基础上，对v1与其他顶点的边进行计算，得到v0与它们的当前最短距离，如图所示。<br>因为min=1，所以本来D[2]=5，现在v0→v1→v2=D[2]=min+3=4，v0→v1→v3=D[3]=min+7=8，v0→v1→v4=D[4]=min+5=6，因此，D数组当前值为{0,1,4,8,6,65535,65535,65535,65535}。<br>而P[2]=1，P[3]=1，P[4]=1，它表示的意思是v0到v2、v3、v4点的最短路径它们的前驱均是v1。<br>此时P数组值为：{0,0,1,1,1,0,0,0,0}。<br><img src="/img/CSDataStructure/134.jpg"></p><p>8．<br>重新开始循环，此时v=2。<br>第15～23行，对w循环，注意因为final[0]=1和final[1]=1，由第18行的!final[w]可知，v0与v1并不参与最小值的获取。通过循环比较，找到最小值min=4，k=2。</p><p>9．<br>第24行，由k=2，表示已经求出v0到v2的最短路径，并且由D[2]=4，知道最短距离是4。<br>因此将v2对应的final[2]设置为1，此时final数组为：{1,1,1,0,0,0,0,0,0}。</p><p>10．<br>第25～32行。在刚才已经找到v0与v2的最短路径的基础上，对v2与其他顶点的边，进行计算，得到v0与它们的当前最短距离，如图所示。<br>因为min=4，所以本来D[4]=6，现在v0→v2→v4=D[4]=min+1=5，v0→v2→v5=D[5]=min+7=11，因此，D数组当前值为：{0,1,4,8,5,11,65535,65535,65535}。<br>而原本P[4]=1，此时P[4]=2，P[5]=2，它表示v0到v4、v5点的最短路径它们的前驱均是v2。此时P数组值为：{0,0,1,1,2,2,0,0,0}。<br><img src="/img/CSDataStructure/135.jpg"></p><p>11．<br>重新开始循环，此时v=3。<br>第15～23行，通过对w循环比较找到最小值min=5，k=4。</p><p>12．<br>第24行，由k=4，表示已经求出v0到v4的最短路径，并且由D[4]=5，知道最短距离是5。因此将v4对应的final[4]设置为1。<br>此时final数组为：{1,1,1,0,1,0,0,0,0}。</p><p>13．<br>第25～32行。对v4与其他顶点的边进行计算，得到v0与它们的当前最短距离，如图所示。<br>因为min=5，所以本来D[3]=8，现在v0→v4→v3=D[3]=min+2=7，本来D[5]=11，现在v0→v4→v5=D[5]=min+3=8，另外v0→v4→v6=D[6]=min+6=11，v0→v4→v7=D[7]=min+9=14，因此，D数组当前值为：{0,1,4,7,5,8,11,14,65535}。<br>而原本P[3]=1，此时P[3]=4，原本P[5]=2，此时P[5]=4，另外P[6]=4，P[7]=4，它表示v0到v3、v5、v6、v7点的最短路径它们的前驱均是v4。此时P数组值为：{0,0,1,4,2,4,4,4,0}。<br><img src="/img/CSDataStructure/136.jpg"></p><p>14．<br>之后的循环就完全类似了。得到最终的结果，如图所示。<br>此时final数组为：{1,1,1,1,1,1,1,1,1}，它表示所有的顶点均完成了最短路径的查找工作。<br>此时D数组为：{0,1,4,7,5,8,10,12,16}，它表示v0到各个顶点的最短路径数，比如D[8]=1+3+1+2+3+2+4=16。<br>此时的P数组为：{0,0,1,4,2,4,3,6,7}，这串数字可能略为难理解一些。比如P[8]=7，它的意思是v0到v8的最短路径，顶点v8的前驱顶点是v7，再由P[7]=6表示v7的前驱是v6，P[6]=3，表示v6的前驱是v3。这样就可以得到，v0到v8的最短路径为v8←v7←v6←v3←v4←v2←v1←v0，即v0→v1→v2→v4→v3→v6→v7→v8。</p><p>其实最终返回的数组D和数组P，是可以得到v0到任意一个顶点的最短路径和路径长度的。<br>例如v0到v8的最短路径并没有经过v5，但我们已经知道v0到v5的最短路径了。<br>由D[5]=8可知它的路径长度为8，由P[5]=4可知v5的前驱顶点是v4，所以v0到v5的最短路径是v0→v1→v2→v4→v5。</p><p>也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。<br>从循环嵌套可以很容易得到此算法的时间复杂度为O(n2)，尽管有同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是O(n2)。</p><h3 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h3><p>为了能讲明白弗洛伊德（Floyd）算法的精妙所在，我们先来看最简单的案例。<br><img src="/img/CSDataStructure/137.jpg"><br>我们先定义两个二维数组D[3][3]和P[3][3]，D代表顶点到顶点的最短路径权值和的矩阵。P代表对应顶点的最小路径的前驱矩阵，用来存储路径。<br>在未分析任何顶点之前，我们将D命名为D-1，其实它就是初始的图的邻接矩阵。将P命名为P-1，初始化为图中所示的矩阵。</p><p>首先我们来分析，所有的顶点经过v0后到达另一顶点的最短路径。<br>因为只有三个顶点，因此需要查看v1→v0→v2，得到D-1[1][0]+D-1[0][2]=2+1=3。<br>D-1[1][2]表示的是v1→v2的权值为5，我们发现D-1[1][2]&gt;D-1[1][0]+D-1[0][2]，通俗的话讲就是v1→v0→v2比直接v1→v2距离还要近。<br>所以我们就让D-1[1][2]=D-1[1][0]+D-1[0][2]=3，同样的D-1[2][1]=3，于是就有了D0的矩阵。<br>因为有变化，所以P矩阵对应的P-1[1][2]和P-1[2][1]也修改为当前中转的顶点v0的下标0，于是就有了P0。<br>也就是说D0[v][w]=min{D-1[v][w],D-1[v][0]+D-1[0][w]}</p><p>接下来，其实也就是在D0和P0的基础上继续处理所有顶点经过v1和v2后到达另一顶点的最短路径，得到D1和P1、D2和P2完成所有顶点到所有顶点的最短路径计算工作。</p><p>如果我就用这么简单的图形来讲解代码，大家一定会觉得不能说明什么问题。所以我们还是以前面的复杂网图为例，来讲解弗洛伊德（Floyd）算法。</p><p>首先我们针对下图的左网图准备两个矩阵D-1和P-1，D-1就是网图的邻接矩阵，P-1初设为P[i][j]=j这样的矩阵，它主要用来存储路径。<br><img src="/img/CSDataStructure/138.jpg"><br>代码如下，注意因为是求所有顶点到所有顶点的最短路径，因此Pathmatirx和ShortPathTable都是二维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  Pathmatirx[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph  G,  Pathmatirx  *P,  ShortPathTable  *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  v,  w,  k;</span><br><span class="line"><span class="comment">/*  初始化D与P  */</span></span><br><span class="line"><span class="keyword">for</span>  (v  =  <span class="number">0</span>;  v  &lt;  G.numVertexes;  ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (w  =  <span class="number">0</span>;  w  &lt;  G.numVertexes;  ++w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  D[v][w]值即为对应点间的权值  */</span></span><br><span class="line">(*D)[v][w]  =  G.matirx[v][w];</span><br><span class="line"><span class="comment">/*  初始化P  */</span></span><br><span class="line">(*P)[v][w]  =  w;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>  (k  =  <span class="number">0</span>;  k  &lt;  G.numVertexes;  ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (v  =  <span class="number">0</span>;  v  &lt;  G.numVertexes;  ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (w  =  <span class="number">0</span>;  w  &lt;  G.numVertexes;  ++w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  ((*D)[v][w]  &gt;  (*D)[v][k]  +  (*D)[k][w])</span><br><span class="line">&#123;                                                              </span><br><span class="line"><span class="comment">/*  如果经过下标为k顶点路径比原两点间路径更短  */</span></span><br><span class="line"><span class="comment">/*  将当前两点间权值设为更小的一个  */</span></span><br><span class="line">(*D)[v][w]  =  (*D)[v][k]  +  (*D)[k][w];</span><br><span class="line"><span class="comment">/*  路径设置经过下标为k的顶点  */</span></span><br><span class="line">(*P)[v][w]  =  (*P)[v][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，第4～11行就是初始化了D和P，使得它们成为上图的两个矩阵。<br>从矩阵也得到，v0→v1路径权值是1，v0→v2路径权值是5，v0→v3无边连线，所以路径权值为极大值65535。</p><p>2．<br>第12～25行，是算法的主循环，一共三层嵌套，k代表的就是中转顶点的下标。<br>v代表起始顶点，w代表结束顶点。</p><p>3．<br>当K=0时，也就是所有的顶点都经过v0中转，计算是否有最短路径的变化。<br>可惜结果是，没有任何变化，如图所示。<br><img src="/img/CSDataStructure/139.jpg"></p><p>4．<br>当K=1时，也就是所有的顶点都经过v1中转。<br>此时，当v=0时，原本D[0][2]=5，现在由于D[0][1]+D[1][2]=4。<br>因此由代码的第20行，二者取其最小值，得到D[0][2]=4，同理可得D[0][3]=8、D[0][4]=6，当v=2、3、4时，也修改了一些数据，参考下图左图中虚线框数据。<br>由于这些最小权值的修正，所以在路径矩阵P上，也要作处理，将它们都改为当前的P[v][k]值，见代码第21行。<br><img src="/img/CSDataStructure/140.jpg"></p><p>5.<br>接下来就是k=2一直到8结束，表示针对每个顶点做中转得到的计算结果，当然，我们也要清楚，D0是以D-1为基础，D1是以D0为基础，……，D8是以D7为基础，它们是有联系的，路径矩阵P也是如此。<br>最终当k=8时，两矩阵数据如图所示。<br><img src="/img/CSDataStructure/141.jpg"></p><p>至此，我们的最短路径就算是完成了，你可以看到矩阵第v0行的数值与迪杰斯特拉（Dijkstra）算法求得的D数组的数值是完全相同，都是{0,1,4,7,5,8,10,12,16}。<br>而且这里是所有顶点到所有顶点的最短路径权值和都可以计算出。<br>那么如何由P这个路径数组得出具体的最短路径呢？以v0到v8为例，从上图的右图第v8列，P[0][8]=1，得到要经过顶点v1，然后将1取代0得到P[1][8]=2，说明要经过v2，然后将2取代1得到P[2][8]=4，说明要经过v4，然后将4取代2得到P[4][8]=3，说明要经过v3，……，这样很容易就推导出最终的最短路径值为v0→v1→v2→v4→v3→v6→v7→v8。<br>求最短路径的显示代码可以这样写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  (v  =  <span class="number">0</span>;  v  &lt;  G.numVertexes;  ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (w  =  v  +  <span class="number">1</span>;  w  &lt;  G.numVertexes;  w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d  weight:  %d  &quot;</span>,  v,  w,  D[v][w]);</span><br><span class="line"><span class="comment">/*  获得第一个路径顶点下标  */</span></span><br><span class="line">k  =  P[v][w];                                </span><br><span class="line"><span class="comment">/*  打印源点  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  path:  %d&quot;</span>,  v);          </span><br><span class="line"><span class="comment">/*  如果路径顶点下标不是终点  */</span></span><br><span class="line"><span class="keyword">while</span>  (k  !=  w)                            </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  打印路径顶点  */</span><span class="built_in">printf</span>(<span class="string">&quot;  -&gt;  %d&quot;</span>,  k);        </span><br><span class="line"><span class="comment">/*  获得下一个路径顶点下标  */</span></span><br><span class="line">k  =  P[k][w];                        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  打印终点  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  -&gt;  %d\n&quot;</span>,  w);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="拓扑排序介绍"><a href="#拓扑排序介绍" class="headerlink" title="拓扑排序介绍"></a>拓扑排序介绍</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（ActivityOn Vertex Network）。<br>AOV网中的弧表示活动之间存在的某种制约关系。<br>比如演职人员确定了，场地也联系好了，才可以开始进场拍摄。<br>另外就是AOV网中不能存在回路。<br>刚才已经举了例子，让某个活动的开始要以自己完成作为先决条件，显然是不可以的。<br><img src="/img/CSDataStructure/142.jpg"><br>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1，v2，……，vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们称这样的顶点序列为一个拓扑序列。</p><p>上图这样的AOV网的拓扑序列不止一条。序列v0v1v2v3v4v5v6v7v8v9v10v11v12v13v14v15v16是一条拓扑序列，而v0v1v4v3v2v7v6v5v8v10v9v12v11v14v13v15v16也是一条拓扑序列。</p><p>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。<br>构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网。</p><p>一个不存在回路的AOV网，我们可以将它应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要，所以实现拓扑排序的算法就很有价值了。</p><h3 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h3><p>对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。</p><p>首先我们需要确定一下这个图需要使用的数据结构。<br>前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。<br>因此我们需要为AOV网建立一个邻接表。<br>考虑到算法过程中始终要查找入度为0的顶点，我们在原来顶点表结点结构中，增加一个入度域in，结构如下所示，其中in就是入度的数字。</p><p>indata  first  edge  </p><p>因此对于下图的第一幅图AOV网，我们可以得到如第二幅图的邻接表数据结构。<br><img src="/img/CSDataStructure/143.jpg"></p><p>在拓扑排序算法中，涉及的结构代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  边表结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">EdgeNode</span>                    </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  邻接点域，存储该顶点对应的下标  */</span></span><br><span class="line"><span class="keyword">int</span>  adjvex;                                    </span><br><span class="line"><span class="comment">/*  用于存储权值，对于非网图可以不需要  */</span></span><br><span class="line"><span class="keyword">int</span>  weight;                                    </span><br><span class="line"><span class="comment">/*  链域，指向下一个邻接点  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">EdgeNode</span>  *<span class="title">next</span>;</span>              </span><br><span class="line">&#125;  EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  顶点表结点  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">VertexNode</span>                </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  顶点入度*/</span></span><br><span class="line"><span class="keyword">int</span>  in;                                            </span><br><span class="line"><span class="comment">/*  顶点域，存储顶点信息  */</span></span><br><span class="line"><span class="keyword">int</span>  data;                                        </span><br><span class="line"><span class="comment">/*  边表头指针  */</span></span><br><span class="line">EdgeNode  *firstedge;                  </span><br><span class="line">&#125;  VertexNode,  AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AdjList  adjList;</span><br><span class="line"><span class="comment">/*  图中当前顶点数和边数  */</span></span><br><span class="line"><span class="keyword">int</span>  numVertexes,numEdges;        </span><br><span class="line">&#125;  graphAdjList,  *GraphAdjList;</span><br></pre></td></tr></table></figure><p>在算法中，我还需要辅助的数据结构—栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。<br>现在我们来看代码，并且模拟运行它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">TopologicalSort</span><span class="params">(GraphAdjList  GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode  *e;</span><br><span class="line"><span class="keyword">int</span>  i,  k,  gettop;</span><br><span class="line"><span class="comment">/*  用于栈指针下标  */</span></span><br><span class="line"><span class="keyword">int</span>  top  =  <span class="number">0</span>;      </span><br><span class="line"><span class="comment">/*  用于统计输出顶点的个数  */</span></span><br><span class="line"><span class="keyword">int</span>  count  =  <span class="number">0</span>;                                                                                                   </span><br><span class="line"><span class="comment">/*  建栈存储入度为0的顶点  */</span></span><br><span class="line"><span class="keyword">int</span>  *<span class="built_in">stack</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">stack</span>  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(GL-&gt;numVertexes  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (GL-&gt;adjList[i].in  ==  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将入度为0的顶点入栈  */</span></span><br><span class="line"><span class="built_in">stack</span>[++top]  =  i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;                                                    </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  (top  !=  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  出栈  */</span></span><br><span class="line">gettop  =  <span class="built_in">stack</span>[top--];                                                  </span><br><span class="line"><span class="comment">/*  打印此顶点  */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  -&gt;  &quot;</span>,  GL-&gt;adjList[gettop].data);        </span><br><span class="line"><span class="comment">/*  统计输出顶点数  */</span></span><br><span class="line">count++;                                                                              </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对此顶点弧表遍历  */</span></span><br><span class="line"><span class="keyword">for</span>  (e  =  GL-&gt;adjList[gettop].firstedge;  e;  e  =  e-&gt;next)</span><br><span class="line">&#123;                                                                                            </span><br><span class="line">k  =  e-&gt;adjvex;</span><br><span class="line"><span class="comment">/*  将k号顶点邻接点的入度减1  */</span></span><br><span class="line"><span class="keyword">if</span>  (!(--GL-&gt;adjList[k].in))                                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*若为0则入栈，以便于下次循环输出  */</span></span><br><span class="line"><span class="built_in">stack</span>[++top]  =  k;</span><br><span class="line">&#125;                                            </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果count小于顶点数，说明存在环  */</span></span><br><span class="line"><span class="keyword">if</span>  (count  &lt;  GL-&gt;numVertexes)                                              </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，第3～7行都是变量的定义，其中stack是一个栈，用来存储整型的数字。</p><p>2．<br>第8～10行，作了一个循环判断，把入度为0的顶点下标都入栈，从下图可知，此时stack应该为：{0,1,3}，即v0、v1、v3的顶点入度为0，如图所示。</p><p>3．<br>第12～23行，while循环，当栈中有数据元素时，始终循环。</p><p>4．<br>第14～16行，v3出栈得到gettop=3。并打印此顶点，然后count加1。</p><p>5．<br>第17～22行，循环其实是对v3顶点对应的弧链表进行遍历，即下图中的灰色部分，找到v3连接的两个顶点v2和v13，并将它们的入度减少一位，此时v2和v13的in值都为1。<br>它的目的是为了将v3顶点上的弧删除。<br><img src="/img/CSDataStructure/144.jpg"></p><p>6．<br>再次循环，第12～23行。此时处理的是顶点v1。经过出栈、打印、count=2后，我们对v1到v2、v4、v8的弧进行了遍历。<br>并同样减少了它们的入度数，此时v2入度为0，于是由第20～21行知，v2入栈，如图所示。<br>试想，如果没有在顶点表中加入in这个入度数据域，20行的判断就必须要是循环，这显然是要消耗时间的，我们利用空间换取了时间。<br><img src="/img/CSDataStructure/145.jpg"></p><p>7．<br>接下来，就是同样的处理方式了。<br>下图展示了v2v6v0v4v5v8的打印删除过程，后面还剩几个顶点都类似，就不图示了。<br><img src="/img/CSDataStructure/146.jpg"></p><p>8．<br>最终拓扑排序打印结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;8-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11。<br>当然这结果并不是唯一的一种拓扑排序方案。</p><p>分析整个算法，对一个具有n个顶点e条弧的AOV网来说，第8～10行扫描顶点表，将入度为0的顶点入栈的时间复杂为O(n)，而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O(n+e)。</p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>因此，我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，并且找到当中最关键的流程，这个流程的时间就是最短时间。</p><p>因此在前面讲了AOV网的基础上，我们来介绍一个新的概念。<br>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Net-work）。<br>我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。<br>由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE网只有一个源点一个汇点。<br>例如下图就是一个AOE网。<br>其中v0即是源点，表示一个工程的开始，v9是汇点，表示整个工程的结束，顶点v0，v1，……，v9分别表示事件，弧&lt;v0,v1&gt;，&lt;v0,v2&gt;，……，&lt;v8,v9&gt;都表示一个活动，用a0，a1，……，a12表示，它们的值代表着活动持续的时间，比如弧&lt;v0,v1&gt;就是从源点开始的第一个活动a0，它的时间是3个单位。<br><img src="/img/CSDataStructure/147.jpg"><br>既然AOE网是表示工程流程的，所以它就具有明显的工程的特性。<br>如有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。<br>只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生。</p><p>尽管AOE网与AOV网都是用来对工程建模的，但它们还是有很大的不同，主要体现在AOV网是顶点表示活动的网，它只描述活动之间的制约关系，而AOE网是用边表示活动的网，边上的权值表示活动持续的时间，如下图所示两图的对比。<br>因此，AOE网是要建立在活动之间制约关系没有矛盾的基础之上，再来分析完成整个工程至少需要多少时间，或者为缩短完成工程所需时间，应当加快哪些活动等问题。<br><img src="/img/CSDataStructure/148.jpg"><br>我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。显然就上图的AOE网而言，开始→发动机完成→部件集中到位→组装完成就是关键路径，路径长度为5.5。</p><h3 id="关键路径算法原理"><a href="#关键路径算法原理" class="headerlink" title="关键路径算法原理"></a>关键路径算法原理</h3><p>也就是说，我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。<br>为此，我们需要定义如下几个参数。</p><p>1.<br>事件的最早发生时间etv（earliest time ofvertex）：即顶点vk的最早发生时间。<br>2.<br>事件的最晚发生时间ltv（latest time ofvertex）：即顶点vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。<br>3.<br>活动的最早开工时间ete（earliest time ofedge）：即弧ak的最早发生时间。<br>4.<br>活动的最晚开工时间lte（latest time ofedge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。</p><p>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否是关键活动。</p><h3 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h3><p>我们将之前的AOE网转化为邻接表结构如图所示，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了weight域，用来存储弧的权值。<br><img src="/img/CSDataStructure/149.jpg"><br><img src="/img/CSDataStructure/150.jpg"><br>求事件的最早发生时间etv的过程，就是我们从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列列表。<br>为此，我们首先在程序开始处声明几个全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  *etv,  *ltv;        <span class="comment">/*  事件最早发生时间和最迟发生时间数组  */</span></span><br><span class="line"><span class="keyword">int</span>  *stack2;            <span class="comment">/*  用于存储拓扑序列的栈  */</span></span><br><span class="line"><span class="keyword">int</span>  top2;               <span class="comment">/*  用于stack2的指针  */</span></span><br></pre></td></tr></table></figure><p>其中stack2用来存储拓扑序列，以便后面求关键路径时使用。<br>下面是改进过的求拓扑序列算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  拓扑排序，用于关键路径计算  */</span></span><br><span class="line"><span class="function">Status  <span class="title">TopologicalSort</span><span class="params">(GraphAdjList  GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode  *e;</span><br><span class="line"><span class="keyword">int</span>  i,  k,  gettop;</span><br><span class="line"><span class="comment">/*  用于栈指针下标  */</span></span><br><span class="line"><span class="keyword">int</span>  top  =  <span class="number">0</span>;                                                                                 </span><br><span class="line"><span class="comment">/*  用于统计输出顶点的个数  */</span></span><br><span class="line"><span class="keyword">int</span>  count  =  <span class="number">0</span>;                                                                               </span><br><span class="line"><span class="comment">/*  建栈将入度为0的顶点入栈  */</span></span><br><span class="line"><span class="keyword">int</span>  *<span class="built_in">stack</span>;                                                                                    </span><br><span class="line"><span class="built_in">stack</span>  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(GL-&gt;numVertexes  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (<span class="number">0</span>  ==  GL-&gt;adjList[i].in)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stack</span>[++top]  =  i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  初始化为0  */</span></span><br><span class="line">top2  =  <span class="number">0</span>;                                                                                     </span><br><span class="line"><span class="comment">/*  事件最早发生时间  */</span></span><br><span class="line">etv  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(GL-&gt;numVertexes  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));              </span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始化为0  */</span></span><br><span class="line">etv[i]  =  <span class="number">0</span>;</span><br><span class="line">&#125;                                                                                      </span><br><span class="line"><span class="comment">/*  初始化  */</span></span><br><span class="line">stack2  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(GL-&gt;numVertexes  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">while</span>  (top  !=  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">gettop  =  <span class="built_in">stack</span>[top--];</span><br><span class="line">count++;</span><br><span class="line"><span class="comment">/*  将弹出的顶点序号压入拓扑序列的栈  */</span></span><br><span class="line">stack2[++top2]  =  gettop;                                                            </span><br><span class="line"><span class="keyword">for</span>  (e  =  GL-&gt;adjList[gettop].firstedge;  e;  e  =  e-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">k  =  e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>  (!(--GL-&gt;adjList[k].in))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stack</span>[++top]  =  k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  求各顶点事件最早发生时间值  */</span></span><br><span class="line"><span class="keyword">if</span>  ((etv[gettop]  +  e-&gt;weight)  &gt;  etv[k])                      </span><br><span class="line">&#123;</span><br><span class="line">etv[k]  =  etv[gettop]  +  e-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (count  &lt;  GL-&gt;numVertexes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>第11～15行为初始化全局变量etv数组、top2和stack2的过程。</p><p>第21行就是将本是要输出的拓扑序列压入全局栈stack2中。</p><p>第27～28行很关键，它是求etv数组的每一个元素的值。</p><p>比如说，假如我们已经求得顶点v0对应的etv[0]=0，顶点v1对应的etv[1]=3，顶点v2对应的etv[2]=4，现在我们需要求顶点v3对应的etv[3]，其实就是求etv[1]+len&lt;v1,v3&gt;与etv[2]+len&lt;v2,v3&gt;的较大值。显然3+5&lt;4+8，得到etv[3]=12，如下图所示。在代码中e-&gt;weight就是当前弧的长度。<br><img src="/img/CSDataStructure/151.jpg"><br>由此我们也可以得出计算顶点vk即求etv[k]的最早发生时间的公式是：<br>其中P[K]表示所有到达顶点vk的弧的集合。比如上图的P[3]就是&lt;v1,v3&gt;和&lt;v2,v3&gt;两条弧。len&lt;vi,vk&gt;是弧&lt;vi,vk&gt;上的权值。<br>下面我们来看求关键路径的算法代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  求关键路径，GL为有向网，输出GL的各项关键活动  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CriticalPath</span><span class="params">(GraphAdjList  GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode  *e;</span><br><span class="line"><span class="keyword">int</span>  i,  gettop,  k,  j;</span><br><span class="line"><span class="comment">/*  声明活动最早发生时间和最迟发生时间变量  */</span></span><br><span class="line"><span class="keyword">int</span>  ete,  lte; </span><br><span class="line">                                                                                </span><br><span class="line"><span class="comment">/*  求拓扑序列，计算数组etv和stack2的值  */</span></span><br><span class="line">TopologicalSort(GL);   </span><br><span class="line">                                                                   </span><br><span class="line"><span class="comment">/*  事件最晚发生时间  */</span></span><br><span class="line">ltv  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(GL-&gt;numVertexes  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));        </span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  GL-&gt;numVertexes;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始化ltv  */</span></span><br><span class="line">ltv[i]  =  etv[GL-&gt;numVertexes  -  <span class="number">1</span>];</span><br><span class="line">&#125;                                  </span><br><span class="line"><span class="comment">/*  计算ltv  */</span></span><br><span class="line"><span class="keyword">while</span>  (top2  !=  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将拓扑序列出栈，后进先出  */</span></span><br><span class="line">gettop  =  stack2[top2--];                                                      </span><br><span class="line"><span class="keyword">for</span>  (e  =  GL-&gt;adjList[gettop].firstedge;  e;  e  =  e-&gt;next)</span><br><span class="line">&#123;                                                                                               </span><br><span class="line"><span class="comment">/*  求各顶点事件的最迟发生时间ltv值  */</span></span><br><span class="line">k  =  e-&gt;adjvex;</span><br><span class="line"><span class="comment">/*  求各顶点事件最晚发生时间ltv  */</span></span><br><span class="line"><span class="keyword">if</span>  (ltv[k]  -  e-&gt;weight  &lt;  ltv[gettop])                    </span><br><span class="line">&#123;</span><br><span class="line">ltv[gettop]  =  ltv[k]  -  e-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  求ete，lte和关键活动  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">0</span>;  j  &lt;  GL-&gt;numVertexes;  j++)                                    </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (e  =  GL-&gt;adjList[j].firstedge;  e;  e  =  e-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">k  =  e-&gt;adjvex;          </span><br><span class="line"><span class="comment">/*  活动最早发生时间  */</span></span><br><span class="line">ete  =  etv[j];                                                                    </span><br><span class="line"><span class="comment">/*  活动最迟发生时间  */</span></span><br><span class="line">lte  =  ltv[k]  -  e-&gt;weight;                                            </span><br><span class="line"><span class="comment">/*  两者相等即在关键路径上  */</span></span><br><span class="line"><span class="keyword">if</span>  (ete  ==  lte)                                                                </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;v%d,v%d&gt;  length:  %d  ,  &quot;</span>,GL-&gt;adjList[j].data,  GL-&gt;adjList[k].data,  e-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始执行。第5行，声明了ete和lte两个活动最早最晚发生时间变量。</p><p>2．<br>第6行，调用求拓扑序列的函数。<br>执行完毕后，全局变量数组etv和栈stack的值如下图所示，top2=10。<br>也就是说，对于每个事件的最早发生时间，我们已经计算出来了。<br><img src="/img/CSDataStructure/152.jpg"></p><p>3．<br>第7～9行为初始化全局变量ltv数组，因为etv[9]=27，所以数组ltv当前的值为：{27,27,27,27,27,27,27,27,27,27}。</p><p>4．<br>第10～19行为计算ltv的循环。<br>第12行，先将stack2的栈头出栈，由后进先出得到gettop=9。根据邻接表中，v9没有弧表，所以第13～18行循环体未执行。</p><p>5．<br>再次来到第12行，gettop=8，在第13～18行的循环中，v8的弧表只有一条&lt;v8,v9&gt;，第15行得到k=9，因为ltv[9]-3&lt;ltv[8]，所以ltv[8]=ltv[9]-3=24，如图所示。<br><img src="/img/CSDataStructure/153.jpg"></p><p>6．<br>再次循环，当gettop=7、5、6时，同理可算出ltv相对应的值为19、13、25，此时ltv值为：{27，27，27，27，27，13，25，19，24，27}</p><p>7．<br>当gettop=4时，由邻接表可得到v4有两条弧&lt;v4,v6&gt;、&lt;v4,v7&gt;，通过第13～18行的循环，可以得到ltv[4]=min(ltv[7]-4,ltv[6]-9)=min(19-4,25-9)=15，如图所示。<br><img src="/img/CSDataStructure/154.jpg"><br>此时你应该发现，我们在计算ltv时，其实是把拓扑序列倒过来进行的。因此我们可以得出计算顶点vk即求ltv[k]的最晚发生时间的公式是：<br><img src="/img/CSDataStructure/155.jpg"><br>其中S[K]表示所有从顶点vk出发的弧的集合。<br>比如上图的S[4]就是&lt;v4,v6&gt;和&lt;v4,v7&gt;两条弧，en&lt;vk,vj&gt;是弧&lt;vk,vj&gt;上的权值。<br>就这样，当程序执行到第20行时，相关变量的值如下图所示，比如etv[1]=3而ltv[1]=7，表示的意思就是如果时间单位是天的话，哪怕v1这个事件在第7天才开始，也可以保证整个工程的按期完成，你可以提前v1事件开始时间，但你最早也只能在第3天开始。<br><img src="/img/CSDataStructure/156.jpg"></p><p>8．<br>第20～31行是来求另两个变量活动最早开始时间ete和活动最晚开始时间lte，并对相同下标的它们做比较。<br>两重循环嵌套是对邻接表的顶点和每个顶点的弧表遍历。</p><p>9．<br>当j=0时，从v0点开始，有&lt;v0,v2&gt;和&lt;v0,v1&gt;两条弧。<br>当k=2时，ete=etv[j]=etv[0]=0。lte=ltv[k]-e-&gt;weight=ltv[2]-len&lt;v0,v2&gt;=4-4=0，此时ete=lte，表示弧&lt;v0,v2&gt;是关键活动，因此打印。<br>当k=1时，ete=etv[j]=etv[0]=0。lte=ltv[k]-e-&gt;weight=ltv[1]-len&lt;v0,v1&gt;=7-3=4，此时ete≠lte，因此&lt;v0,v1&gt;并不是关键活动，如图所示。<br><img src="/img/CSDataStructure/157.jpg"><br>这里需要解释一下，ete本来是表示活动&lt;vk,vj&gt;的最早开工时间，是针对弧来说的。<br>但只有此弧的弧尾顶点vk的事件发生了，它才可以开始，因此ete=etv[k]。<br>而lte表示的是活动&lt;vk,vj&gt;的最晚开工时间，但此活动再晚也不能等vj事件发生才开始，而必须要在vj事件之前发生，所以lte=ltv[j]-len&lt;vk,vj&gt;。<br>所以最终，其实就是判断ete与lte是否相等，相等意味着活动没有任何空闲，是关键活动，否则就不是。</p><p>10．<br>j=1一直到j=9为止，做法是完全相同的，关键路径打印结果为“&lt;v0,v2&gt;4,&lt;v2,v3&gt;8,&lt;v3,v4&gt;3,&lt;v4,v7&gt;4,&lt;v7,v8&gt;5,&lt;v8,v9&gt;3,”，最终关键路径如图所示。<br><img src="/img/CSDataStructure/158.jpg"></p><p>分析整个求关键路径的算法，第6行是拓扑排序，时间复杂度为O(n+e)，第8～9行时间复杂度为O(n)，第10～19行时间复杂度为O(n+e)，第20～31行时间复杂也为O(n+e)，根据我们对时间复杂度的定义，所有的常数系数可以忽略，所以最终求关键路径算法的时间复杂度依然是O(n+e)。</p><h1 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h1><p>图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来定义的。<br>由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队列、树等之前学的几乎所有数据结构。<br>因此从某种角度来说，学好了图，基本就等于理解了数据结构这门课的精神。</p><p>图的存储结构我们一共讲了五种，如图所示，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。<br>十字链表是针对有向图邻接表结构的优化，邻接多重表是针对无向图邻接表结构的优化。<br>边集数组更多考虑的是对边的关注。<br>用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。<br><img src="/img/CSDataStructure/159.jpg"></p><p>图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时，是着重深度还是看重广度，总是很难说得清楚。</p><p>图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。</p><p>最小生成树，我们讲了两种算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。</p><p>最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉（Dijkstra）算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德（Floyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。</p><p>有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-7-图&quot;&gt;&lt;a href=&quot;#Chapter-7-图&quot; class=&quot;headerlink&quot; title=&quot;Chapter 7 图&quot;&gt;&lt;/a&gt;Chapter 7 图&lt;/h1&gt;&lt;p&gt;图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="图" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E5%9B%BE/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（排序）</title>
    <link href="https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure6(%E6%8E%92%E5%BA%8F)/"/>
    <id>https://afoolzwt.github.io/2022/07/21/CSDataStructure/DataStructure6(%E6%8E%92%E5%BA%8F)/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-21T14:55:12.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>假设含有n个记录的序列为{r1,r2,……,rn}，其相应的关键字分别为{k1,k2,……,kn}，需确定1,2,……,n的一种排列p1,p2,……,pn，使其相应的关键字满足kp1≤kp2≤……≤kpn（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,……,rpn}，这样的操作就称为排序。</p><h2 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h2><p>假设含有n个记录的序列为{r1,r2,……,rn}，其相应的关键字分别为{k1,k2,……,kn}，需确定1,2,……,n的一种排列p1,p2,……,pn，使其相应的关键字满足kp1≤kp2≤……≤kpn（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,……,rpn}，这样的操作就称为排序。</p><p>注意我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p><p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p><p>这里关键字ki可以是记录r的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，我们给出了稳定与不稳定排序的定义。</p><p>假设ki=kj(1≤i≤n,1≤j≤n,i≠j），且在排序前的序列中ri领先于rj（即i&lt;j）。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。</p><p>如图所示，经过对总分的降序排序后，总分高的排在前列。此时对于令狐冲和张无忌而言，未排序时是令狐冲在前，那么它们总分排序后，分数相等的令狐冲依然应该在前，这样才算是稳定的排序，如果他们二者颠倒了，则此排序是不稳定的了。</p><p>只要有一组关键字实例发生类似情况，就可认为此排序方法是不稳定的。排序算法是否稳定的，要通过分析后才能得出。<br><img src="/img/CSDataStructure/224.jpg"></p><h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p><p>我们这里主要就介绍内排序的多种方法。</p><p>对于内排序来说，排序算法的性能主要是受3个方面影响：<br>1．时间性能<br>排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。<br>移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免（这个我们在讲解具体的算法时再谈）。<br>总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。<br>2．辅助空间<br>评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。<br>辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。<br>3．算法的复杂性<br>注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</p><p>根据排序过程中借助的主要操作，我们把内排序分为：插入排序、交换排序、选择排序和归并排序。<br>可以说，这些都是比较成熟的排序技术，已经被广泛地应用于许许多多的程序语言或数据库当中，甚至它们都已经封装了关于排序算法的实现代码。<br>因此，我们学习这些排序算法的目的更多并不是为了去在现实中编程排序算法，而是通过学习来提高我们编写算法的能力，以便于去解决更多复杂和灵活的应用性问题。</p><p>本章一共要讲解七种排序的算法，按照算法的复杂度分为两大类，冒泡排序、简单选择排序和直接插入排序属于简单算法，而希尔排序、堆排序、归并排序、快速排序属于改进算法。后面我们将依次讲解。</p><h2 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h2><p>为了讲清楚排序算法的代码，我先提供一个用于排序用的顺序表结构，此结构也将用于之后我们要讲的所有排序算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  用于要排序数组个数最大值，可根据需要修改  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  10                  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  用于存储要排序数组，r[0]用作哨兵或临时变量  */</span></span><br><span class="line"><span class="keyword">int</span>  r[MAXSIZE  +  <span class="number">1</span>];        </span><br><span class="line"><span class="comment">/*  用于记录顺序表的长度  */</span></span><br><span class="line"><span class="keyword">int</span>  length;                     </span><br><span class="line">&#125;  SqList;</span><br></pre></td></tr></table></figure><p>另外，由于排序最最常用到的操作是数组两元素的交换，我们将它写成函数，在之后的讲解中会大量的用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  交换L中数组r的下标为i和j的值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">swap</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  i,  <span class="keyword">int</span>  j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  temp  =  L-&gt;r[i];</span><br><span class="line">L-&gt;r[i]  =  L-&gt;r[j];</span><br><span class="line">L-&gt;r[j]  =  temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，说了这么多，我们来看第一个排序算法。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="最简单排序实现"><a href="#最简单排序实现" class="headerlink" title="最简单排序实现"></a>最简单排序实现</h3><p>冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><p>冒泡的实现在细节上可以有很多种变化，我们将分别就3种不同的冒泡实现代码，来讲解冒泡排序的思想。</p><p>这里，我们就先来看看比较容易理解的一段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作交换排序(冒泡排序初级版)  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BubbleSort0</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  L-&gt;length;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (j  =  i  +  <span class="number">1</span>;  j  &lt;=  L-&gt;length;  j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[i]  &gt;  L-&gt;r[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换L-&gt;r[i]与L-&gt;r[j]的值  */</span></span><br><span class="line">swap(L,  i,  j);        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码严格意义上说，不算是标准的冒泡排序算法，因为它不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最最简单的交换排序而已。</p><p>它的思路就是让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。</p><p>如图所示，假设我们待排序的关键字序列是{9,1,5,8,3,7,4,6,2}，当i=1时，9与1交换后，在第一位置的1与后面的关键字比较都小，因此它就是最小值。<br>当i=2时，第二位置先后由9换成5，换成3，换成2，完成了第二小的数字交换。后面的数字变换类似，不再介绍。<br><img src="/img/CSDataStructure/225.jpg"><br>它应该算是最最容易写出的排序代码了，不过这个简单易懂的代码，却是有缺陷的。<br>观察后发现，在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。<br>也就是说，这个算法的效率是非常低的。</p><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><p>我们来看看正宗的冒泡算法，有没有什么改进的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作冒泡排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BubbleSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  L-&gt;length;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  注意j是从后往前循环  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  L-&gt;length  -  <span class="number">1</span>;  j  &gt;=  i;j--)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若前者大于后者(注意这里与上一算法差异)  */</span></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[j]  &gt;  L-&gt;r[j  +  <span class="number">1</span>])                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换L-&gt;r[j]与L-&gt;r[j+1]的值  */</span></span><br><span class="line">swap(L,  j,  j  +  <span class="number">1</span>);                          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然假设我们待排序的关键字序列是{9,1,5,8,3,7,4,6,2}，当i=1时，变量j由8反向循环到1，逐个比较，将较小值交换到前面，直到最后找到最小值放置在了第1的位置。</p><p>如图所示，当i=1、j=8时，我们发现6&gt;2，因此交换了它们的位置，j=7时，4&gt;2，所以交换……直到j=2时，因为1&lt;2，所以不交换。j=1时，9&gt;1，交换，最终得到最小值1放置第一的位置。</p><p>事实上，在不断循环的过程中，除了将关键字1放到第一的位置，我们还将关键字2从第九位置提到了第三的位置，显然这一算法比前面的要有进步，在上十万条数据的排序过程中，这种差异会体现出来。</p><p>图中较小的数字如同气泡般慢慢浮到上面，因此就将此算法命名为冒泡算法。<br><img src="/img/CSDataStructure/226.jpg"></p><p>当i=2时，变量j由8反向循环到2，逐个比较，在将关键字2交换到第二位置的同时，也将关键字4和3有所提升。<br><img src="/img/CSDataStructure/227.jpg"><br>后面的数字变换很简单，这里就不在详述了。</p><h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>这样的冒泡程序是否还可以优化呢？答案是肯定的。<br>试想一下，如果我们待排序的序列是{2,1,3,4,5,6,7,8,9}，也就是说，除了第一和第二的关键字需要交换外，别的都已经是正常的顺序。<br>当i=1时，交换了2和1，此时序列已经有序，但是算法仍然不依不饶地将i=2到9以及每个循环中的j循环都执行了一遍，尽管并没有交换数据，但是之后的大量比较还是大大地多余了，如图所示。<br><img src="/img/CSDataStructure/228.jpg"><br>当i=2时，我们已经对9与8，8与7，……，3与2作了比较，没有任何数据交换，这就说明此序列已经有序，不需要再继续后面的循环判断工作了。<br>为了实现这个想法，我们需要改进一下代码，增加一个标记变量flag来实现这一算法的改进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作改进冒泡算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BubbleSort2</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line"><span class="comment">/*  flag用来作为标记  */</span></span><br><span class="line">Status  flag  =  TRUE;                                                </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若flag为true说明有过数据交换，否则停止循环  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  L-&gt;length  &amp;&amp;  flag;  i++)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始为false  */</span></span><br><span class="line">flag  =  FALSE;                                                    </span><br><span class="line"><span class="keyword">for</span>  (j  =  L-&gt;length  -  <span class="number">1</span>;  j  &gt;=  i;  j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[j]  &gt;  L-&gt;r[j  +  <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换L-&gt;r[j]与L-&gt;r[j+1]的值  */</span></span><br><span class="line">swap(L,  j,  j  +  <span class="number">1</span>);                          </span><br><span class="line"><span class="comment">/*  如果有数据交换，则flag为true  */</span></span><br><span class="line">flag  =  TRUE;                                      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p><h3 id="冒泡排序复杂度分析"><a href="#冒泡排序复杂度分析" class="headerlink" title="冒泡排序复杂度分析"></a>冒泡排序复杂度分析</h3><p>分析一下它的时间复杂度。</p><p>当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。<br>当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。</p><p>因此，总的时间复杂度为O(n2)。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选择排序的基本思想是每一趟在n-i＋1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。<br>我们这里先介绍的是简单选择排序法。</p><h3 id="简单选择排序算法"><a href="#简单选择排序算法" class="headerlink" title="简单选择排序算法"></a>简单选择排序算法</h3><p>简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i＋1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录交换之。</p><p>我们来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作简单选择排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SelectSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j,  min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;  L-&gt;length;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将当前下标定义为最小值下标  */</span></span><br><span class="line">min  =  i;                                                                </span><br><span class="line"><span class="comment">/*  循环之后的数据  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  i  +  <span class="number">1</span>;  j  &lt;=  L-&gt;length;  j++)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  如果有小于当前最小值的关键字  */</span></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[min]  &gt;  L-&gt;r[j])                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将此关键字的下标赋值给min  */</span></span><br><span class="line">min  =  j;</span><br><span class="line">&#125;                                                        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若min不等于i，说明找到最小值，交换  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  !=  min)                                                      </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换L-&gt;r[i]与L-&gt;r[min]的值  */</span></span><br><span class="line">swap(L,  i,  min);</span><br><span class="line">&#125;                                        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码应该说不难理解，针对待排序的关键字序列是{9,1,5,8,3,7,4,6,2}，对i从1循环到8。</p><p>当i=1时，L.r[i]=9，min开始是1，然后与j=2到9比较L.r[min]与L.r[j]的大小，因为j=2时最小，所以min=2。<br>最终交换了L.r[2]与L.r[1]的值。<br>如图所示，注意，这里比较了8次，却只交换数据操作一次。<br><img src="/img/CSDataStructure/229.jpg"></p><p>当i=2时，L.r[i]=9，min开始是2，经过比较后，min=9，交换L.r[min]与L.r[i]的值。<br>如图所示，这样就找到了第二位置的关键字。<br><img src="/img/CSDataStructure/230.jpg"></p><p>当i=3时，L.r[i]=5，min开始是3，经过比较后，min=5，交换L.r[min]与L.r[i]的值。<br>如图所示。<br><img src="/img/CSDataStructure/231.jpg"><br>之后的数据比较和交换完全雷同，最多经过8次交换，就可完成排序工作。</p><h4 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h4><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。<br>分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。</p><p>应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><p>顾名思义，从名称上也可以知道它是一种插入排序的方法。我们来看直接插入排序法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作直接插入排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InsertSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">2</span>;  i  &lt;=  L-&gt;length;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  需将L-&gt;r[i]插入有序子表  */</span></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[i]  &lt;  L-&gt;r[i  -  <span class="number">1</span>])                </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  设置哨兵  */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>]  =  L-&gt;r[i];</span><br><span class="line">                        </span><br><span class="line"><span class="keyword">for</span>  (j  =  i  -  <span class="number">1</span>;  L-&gt;r[j]  &gt;  L-&gt;r[<span class="number">0</span>];  j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  记录后移  */</span></span><br><span class="line">L-&gt;r[j  +  <span class="number">1</span>]  =  L-&gt;r[j];</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">/*  插入到正确位置  */</span></span><br><span class="line">L-&gt;r[j  +  <span class="number">1</span>]  =  L-&gt;r[<span class="number">0</span>];                </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，此时我们传入的SqList参数的值为length=6,r[6]={0,5,3,4,6,2}，其中r[0]=0将用于后面起到哨兵的作用。</p><p>2．<br>第4～13行就是排序的主循环。<br>i从2开始的意思是我们假设r[1]=5已经放好位置，后面的牌其实就是插入到它的左侧还是右侧的问题。</p><p>3．<br>第6行，此时i=2，L.r[i]=3比L.r[i-1]=5要小，因此执行第8～11行的操作。<br>第8行，我们将L.r[0]赋值为L.r[i]=3的目的是为了起到第9～10行的循环终止的判断依据。<br>如图所示。图中下方的虚线箭头，就是第10行，L.r[j+1]=L.r[j]的过程，将5右移一位。<br><img src="/img/CSDataStructure/232.jpg"></p><p>4．<br>此时，第10行就是在移动完成后，空出了空位，然后第11行L.r[j+1]=L.r[0]，将哨兵的3赋值给j=0时的L.r[j+1]，<br>也就是说，将扑克牌3放置到L.r[1]的位置，如图所示。<br><img src="/img/CSDataStructure/233.jpg"></p><p>5．<br>继续循环，第6行，因为此时i=3，L.r[i]=4比L.r[i-1]=5要小，因此执行第8～11行的操作，将5再右移一位，将4放置到当前5所在位置，如图所示。<br><img src="/img/CSDataStructure/234.jpg"></p><p>6．<br>再次循环，此时i=4。因为L.r[i]=6比L.r[i-1]=5要大，于是第8～11行代码不执行，此时前三张牌的位置没有变化，如图所示。<br><img src="/img/CSDataStructure/235.jpg"></p><p>7．<br>再次循环，此时i=5，因为L.r[i]=2比L.r[i-1]=6要小，因此执行第8～11行的操作。<br>由于6、5、4、3都比2小，它们都将右移一位，将2放置到当前3所在位置。<br>如图所示。此时我们的排序也就完成了。<br><img src="/img/CSDataStructure/236.jpg"></p><h4 id="直接插入排序复杂度分析"><a href="#直接插入排序复杂度分析" class="headerlink" title="直接插入排序复杂度分析"></a>直接插入排序复杂度分析</h4><p>我们来分析一下这个算法，从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。</p><p>当最好的情况，也就是要排序的表本身就是有序的，比如纸牌拿到后就是{2,3,4,5,6}，那么我们比较次数，其实就是代码第6行每个L.r[i]与L.r[i-1]的比较，共比较了(n-1)sigma(i=2, n, 1)次，由于每次都是L.r[i]&gt;L.r[i-1]，因此没有移动的记录，时间复杂度为O(n)。</p><p>当最坏的情况，即待排序表是逆序的情况，比如{6,5,4,3,2}，此时需要比较sigma(i=2, n, i)=2+3+…+n=(n+2)(n-1)/2次，而记录的移动次数也达到最大值sigma(i=2, n, i+1)=(n+4)(n-1)/2次。</p><p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为n2/4次。<br>因此，我们得出直接插入排序法的时间复杂度为O(n2)。<br>从这里也看出，同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="希尔排序原理"><a href="#希尔排序原理" class="headerlink" title="希尔排序原理"></a>希尔排序原理</h3><p>现在，我要讲解的算法叫希尔排序（ShellSort）。<br>希尔排序是D.L.Shell于1959年提出来的一种排序算法，在这之前排序算法的时间复杂度基本都是O(n2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p><p>我们前一节讲的直接插入排序，应该说，它的效率在某些时候是很高的，比如，我们的记录本身就是基本有序的，我们只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也比较明显。</p><p>可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。<br>不过别急，有条件当然是好，条件不存在，我们创造条件也是可以去做的。<br>于是科学家希尔研究出了一种排序方法，对直接插入排序改进后可以增加效率。</p><p>如何让待排序的记录个数较少呢？很容易想到的就是将原本有大量记录数的记录进行分组。<br>分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。</p><p>此时一定有同学开始疑惑了。这不对呀，比如我们现在有序列是{9,1,5,8,3,7,4,6,2}，现在将它分成三组，{9,1,5}，{8,3,7}，{4,6,2}，哪怕将它们各自排序排好了，变成{1,5,9}，{3,7,8}，{2,4,6}，再合并它们成{1,5,9,3,7,8,2,4,6}，此时，这个序列还是杂乱无序，谈不上基本有序，要排序还是重来一遍直接插入有序，这样做有用吗？</p><p>需要强调一下，所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,6,4,7,5,8,9}这样可以称为基本有序了。<br>但像{1,5,9,3,7,8,2,4,6}这样的9在第三位，2在倒数第三位就谈不上基本有序。</p><p>问题其实也就在这里，我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。而如上面这样分完组后就各自排序的方法达不到我们的要求。<br>因此，我们需要采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</p><h3 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h3><p>好了，为了能够真正弄明白希尔排序的算法，我们还是老办法——模拟计算机在执行算法时的步骤，还研究算法到底是如何进行排序的。</p><p>希尔排序算法代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作希尔排序  */</span><span class="function"><span class="keyword">void</span>  <span class="title">ShellSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i,  j;</span><br><span class="line"><span class="keyword">int</span>  increment  =  L-&gt;length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  增量序列  */</span></span><br><span class="line">increment  =  increment  /  <span class="number">3</span>  +  <span class="number">1</span>;                                </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  (i  =  increment  +  <span class="number">1</span>;  i  &lt;=  L-&gt;length;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[i]  &lt;  L-&gt;r[i  -  increment])</span><br><span class="line">&#123;                                                                                  </span><br><span class="line"><span class="comment">/*  需将L-&gt;r[i]插入有序增量子表  */</span></span><br><span class="line"><span class="comment">/*  暂存在L-&gt;r[0]  */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>]  =  L-&gt;r[i];                                        </span><br><span class="line"><span class="keyword">for</span>  (j  =  i  -  increment;  j  &gt;  <span class="number">0</span>  &amp;&amp;  L-&gt;r[<span class="number">0</span>]  &lt;  L-&gt;r[j];  j  -=  increment)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  记录后移，查找插入位置  */</span></span><br><span class="line">L-&gt;r[j  +  increment]  =  L-&gt;r[j];</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">/*  插入  */</span></span><br><span class="line">L-&gt;r[j  +  increment]  =  L-&gt;r[<span class="number">0</span>];                </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>  (increment  &gt;  <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始运行，此时我们传入的SqList参数的值为length=9,r[10]={0,9,1,5,8,3,7,4,6,2}。这就是我们需要等待排序的序列，如图所示。<br><img src="/img/CSDataStructure/237.jpg"></p><p>2．<br>第4行，变量increment就是那个“增量”，我们初始值让它等于待排序的记录数。</p><p>3．<br>第5～19行是一个do循环，它的终止条件是increment不大于1时，其实也就是增量为1时就停止循环了。</p><p>4．<br>第7行，这一句很关键，但也是难以理解的地方，我们后面还要谈到它，先放一放。这里执行完成后，increment=9/3+1=4。</p><p>5．<br>第8～17行是一个for循环，i从4+1=5开始到9结束。</p><p>6．<br>第10行，判断L.r[i]与L.r[i - increment]大小，L.r[5]=3小于L.r[i - increment]=L.r[1]=9，满足条件，第12行，将L.r[5]=3暂存入L.r[0]。<br>第13～14行的循环只是为了将L.r[1]=9的值赋给L.r[5]，由于循环的增量是j-=increment，其实它就循环了一次，此时j=-3。<br>第15行，再将L.r[0]=3赋值给L.r[j+incre-ment]=L.r[-3+4]=L.r[1]=3。</p><p>如图所示，事实上，这一段代码就干了一件事，就是将第5位的3和第1位的9交换了位置。<br><img src="/img/CSDataStructure/238.jpg"></p><p>7．<br>循环继续，i=6，L.r[6]=7&gt;L.r[i-incre-ment]=L.r[2]=1，因此不交换两者数据。<br>如图所示。<br><img src="/img/CSDataStructure/239.jpg"></p><p>8．<br>循环继续，i=7，L.r[7]=4&lt;L.r[i-incre-ment]=L.r[3]=5，交换两者数据。<br>如图所示。<br><img src="/img/CSDataStructure/240.jpg"></p><p>9．<br>循环继续，i=8，L.r[8]=6&lt;L.r[i-incre-ment]=L.r[4]=8，交换两者数据。<br>如图所示。<br><img src="/img/CSDataStructure/241.jpg"></p><p>10．<br>循环继续，i=9，L.r[9]=2&lt;L.r[i-incre-ment]=L.r[5]=9，交换两者数据。<br>注意，第13～14行是循环，此时还要继续比较L.r[5]与L.r[1]的大小，因为2&lt;3，所以还要交换L.r[5]与L.r[1]的数据，如图所示。<br><img src="/img/CSDataStructure/242.jpg"><br>最终第一轮循环后，数组的排序结果为图所示。<br>细心的同学会发现，我们的数字1、2等小数字已经在前两位，而8、9等大数字已经在后两位，也就是说，通过这样的排序，我们已经让整个序列基本有序了。<br>这其实就是希尔排序的精华所在，它将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，从而使得每次完成一轮循环后，整个序列就朝着有序坚实地迈进一步。<br><img src="/img/CSDataStructure/243.jpg"></p><p>11．<br>我们继续，在完成一轮do循环后，此时由于increment=4&gt;1因此我们需要继续do循环。<br>第7行得到increment=4/3+1=2。<br>第8～17行for循环，i从2+1=3开始到9结束。<br>当i=3、4时，不用交换，当i=5时，需要交换数据，如图所示。<br><img src="/img/CSDataStructure/244.jpg"></p><p>12．<br>此后，i=6、7、8、9均不用交换，如图所示。<br><img src="/img/CSDataStructure/245.jpg"></p><p>13．<br>再次完成一轮do循环，increment=2&gt;1，再次do循环，第7行得到increment=2/3+1=1，此时这就是最后一轮do循环了。<br>尽管第8～17行for循环，i从 1+1=2开始到9结束，但由于当前序列已经基本有序，可交换数据的情况大为减少，效率其实很高。<br>如图所示，图中箭头连线为需要交换的关键字。<br><img src="/img/CSDataStructure/246.jpg"></p><p>最终完成排序过程，如图所示。<br><img src="/img/CSDataStructure/247.jpg"></p><h4 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h4><p>通过这段代码的剖析，相信大家有些明白，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。</p><p>这里“增量”的选取就非常关键了。我们在代码中第7行，是用increment=increment/3+1;的方式选取增量的，可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。<br>不过大量的研究表明，当增量序列为dlta[k]=2t-k+1-1（0≤k≤t≤）时，可以获得不错的效率，其时间复杂度O(n^（1.3—2）)，要好于直接排序的O(n2)。<br>需要注意的是，增量序列的最后一个增量值必须等于1才行。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p><p>不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度为O(n2)），之后，相应的更为高效的排序算法也就相继出现了。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>我们前面讲到简单选择排序，它在待排序的n个记录中选择一个最小的记录需要比较n-1次。本来这也可以理解，查找第一个数据需要比较这么多次是正常的，否则如何知道它是最小的记录。</p><p>可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。</p><p>如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会非常高了。<br>而堆排序（HeapSort），就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。<br>堆排序算法是Floyd和Williams在1964年共同发明的，同时，他们发明了“堆”这样的数据结构。</p><p>我们这里要介绍的“堆”结构相当于把数字符号堆成一个塔型的结构。当然，这绝不是简单的堆砌。大家看图所示，能够找到什么规律吗？<br><img src="/img/CSDataStructure/248.jpg"><br>很明显，我们可以发现它们都是二叉树，如果观察仔细些，还能看出它们都是完全二叉树。<br>左图中根结点是所有元素中最大的，右图的根结点是所有元素中最小的。<br>再细看看，发现左图每个结点都比它的左右孩子要大，右图每个结点都比它的左右孩子要小。<br>这就是我们要讲的堆结构。</p><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆（例如图左图所示）；<br>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆（例如图右图所示）。</p><p>这里需要注意从堆的定义可知，根结点一定是堆中所有结点最大（小）者。<br>较大（小）的结点靠近根结点（但也不绝对，比如右图小顶堆中60、40均小于70，但它们并没有70靠近根结点）。</p><p>如果按照层序遍历的方式给结点从1开始编号，则结点之间满足如下关系：<br><img src="/img/CSDataStructure/249.jpg"><br>这里为什么i要小于等于呢（n/2）？<br>相信大家可能都忘记了二叉树的性质5，其实忘记也不奇怪，这个性质在我们讲完之后，就再也没有提到过它。<br>可以说，这个性质仿佛就是在为堆准备的。<br>性质5的第一条就说一棵完全二叉树，如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。<br>那么对于有n个结点的二叉树而言，它的i值自然就是小于等于了。<br>性质5的第二、三条，也是在说明下标i与2i和2i+1的双亲子女关系。<br>如果完全忘记的同学不妨去复习一下。</p><p>如果将上图的大顶堆和小顶堆用层序遍历存入数组，则一定满足上面的关系表达，如下图所示。<br><img src="/img/CSDataStructure/250.jpg"></p><h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的方法。<br>它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。<br>将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。<br>如此反复执行，便能得到一个有序序列了。</p><p>例如图所示，图①是一个大顶堆，90为最大值，将90与20（末尾元素）互换，如图②所示，此时90就成了整个堆序列的最后一个元素，将20经过调整，使得除90以外的结点继续满足大顶堆定义（所有结点都大于等于其子孩子），见图③，然后再考虑将30与80互换……<br><img src="/img/CSDataStructure/251.jpg"></p><p>相信大家有些明白堆排序的基本思想了，不过要实现它还需要解决两个问题： 1.如何由一个无序序列构建成一个堆？ 2.如果在输出堆顶元素后，调整剩余元素成为一个新的堆？</p><p>要解释清楚它们，让我们来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L进行堆排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">HeapSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="comment">/*  把L中的r构建成一个大顶堆  */</span></span><br><span class="line"><span class="keyword">for</span>  (i  =  L-&gt;length  /  <span class="number">2</span>;  i  &gt;  <span class="number">0</span>;  i--)        </span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(L,  i,  L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>  (i  =  L-&gt;length;  i  &gt;  <span class="number">1</span>;  i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将堆顶记录和当前未经排序子序列的最后一个记录交换  */</span></span><br><span class="line">swap(L,  <span class="number">1</span>,  i);                                          </span><br><span class="line"><span class="comment">/*  将L-&gt;r[1..i-1]重新调整为大顶堆  */</span></span><br><span class="line">HeapAdjust(L,  <span class="number">1</span>,  i  -  <span class="number">1</span>);                      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出，整个排序过程分为两个for循环。<br>第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。<br>第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。</p><p>假设我们要排序的序列是{50,10,90,30,70,40,80,60,20}，那么L.length=9，第一个for循环，代码第4行，i是从=4开始，4→3→2→1的变量变化。<br>为什么不是从1到9或者从9到1，而是从4到1呢？<br>其实我们看了下图就明白了，它们都有什么规律？<br>它们都是有孩子的结点。注意灰色结点的下标编号就是1、2、3、4。<br><img src="/img/CSDataStructure/252.jpg"><br>我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆。<br>i的4→3→2→1的变量变化，其实也就是30，90，10、50的结点调整过程。</p><p>既然已经弄清楚i的变化是在调整哪些元素了，现在我们来看关键的HeapAdjust（堆调整）函数是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义  */</span></span><br><span class="line"><span class="comment">/*  本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">HeapAdjust</span><span class="params">(SqList  *L,<span class="keyword">int</span>  s,<span class="keyword">int</span>  m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  temp,  j;temp  =  L-&gt;r[s];</span><br><span class="line"><span class="comment">/*  沿关键字较大的孩子结点向下筛选  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">2</span>  *  s;  j  &lt;=  m;  j  *=  <span class="number">2</span>)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (j  &lt;  m  &amp;&amp;  L-&gt;r[j]  &lt;  L-&gt;r[j  +  <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  j为关键字中较大的记录的下标  */</span></span><br><span class="line">++j;</span><br><span class="line">&#125;                                              </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (temp  &gt;=  L-&gt;r[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  rc应插入在位置s上  */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;                                          </span><br><span class="line"></span><br><span class="line">L-&gt;r[s]  =  L-&gt;r[j];</span><br><span class="line">s  =  j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  插入  */</span></span><br><span class="line">L-&gt;r[s]  =  temp;                                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>函数被第一次调用时，s=4，m=9，传入的SqList参数的值为length=9,r[10]={0,50,10,90,30,70,40,80,60,20}。</p><p>2．<br>第4行，将L.r[s]=L.r[4]=30赋值给temp，如图所示。<br><img src="/img/CSDataStructure/253.jpg"></p><p>3．<br>第5～13行，循环遍历其结点的孩子。<br>这里j变量为什么是从2s开始呢？又为什么是j=2递增呢？<br>原因还是二叉树的性质5，因为我们这棵是完全二叉树，当前结点序号是s，其左孩子的序号一定是2s，右孩子的序号一定是2s+1，它们的孩子当然也是以2的位数序号增加，因此j变量才是这样循环。</p><p>4．<br>第7～8行，此时j=2*4=8，j&lt;m说明它不是最后一个结点，如果L.r[j]&lt;L.r[j+1]，则说明左孩子小于右孩子。<br>我们的目的是要找到较大值，当然需要让j+1以便变成指向右孩子的下标。<br>当前30的左右孩子是60和20，并不满足此条件，因此j还是8。</p><p>5．<br>第9～10行，temp=30，L.r[j]=60，并不满足条件。</p><p>6．<br>第11～12行，将60赋值给L.r[4]，并令s=j=8。<br>也就是说，当前算出，以30为根结点的子二叉树，当前最大值是60，在第8的位置。<br>注意此时L.r[4]和L.r[8]的值均为60。</p><p>7．再循环因为j=2*j=16，m=9，j&gt;m，因此跳出循环。</p><p>8．<br>第14行，将temp=30赋值给L.r[s]=L.r[8]，完成30与60的交换工作。<br>如图所示。本次函数调用完成。<br><img src="/img/CSDataStructure/254.jpg"></p><p>9．<br>再次调用HeapAdjust，此时s=3，m=9。<br>第4行，temp=L.r[3]=90，第7～8行，由于40&lt;80得到j+1=2*s+1=7。<br>9～10行，由于90&gt;80，因此退出循环，最终本次调用，整个序列未发什么改变。</p><p>10．<br>再次调用HeapAdjust，此时s=2，m=9。<br>第4行，temp=L.r[2]=10，第7～8行，60&lt;70，使得j=5。<br>最终本次调用使得10与70进行了互换，如图所示。<br><img src="/img/CSDataStructure/255.jpg"></p><p>11．<br>再次调用HeapAdjust，此时s=1，m=9。<br>第4行，temp=L.r[1]=50，第7～8行，70&lt;90，使得j=3。<br>第11～12行，L.r[1]被赋值了90，并且s=3，再循环，由于2j=6并未大于m，因此再次执行循环体，使得L.r[3]被赋值了80，完成循环后，L.[7]被赋值为50，最终本次调用使得50、90、80进行了轮换，如图所示。<br><img src="/img/CSDataStructure/256.jpg"></p><p>到此为止，我们构建大顶堆的过程算是完成了，也就是HeapSort函数的第4～5行循环执行完毕。<br>或许是有点复杂，如果不明白，多试着模拟计算机执行的方式走几遍，应该就可以理解其原理。</p><p>接下来HeapSort函数的第6～11行就是正式的排序过程，由于有了前面的充分准备，其实这个排序就比较轻松了。下面是这部分代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  (i  =  L-&gt;length;  i  &gt;  <span class="number">1</span>;  i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将堆顶记录和当前未经排序子序列的最后一个记录交换  */</span></span><br><span class="line">swap(L,<span class="number">1</span>,i);                        </span><br><span class="line"><span class="comment">/*  将L-&gt;r[1..i-1]重新调整为大顶堆  */</span></span><br><span class="line">HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>当i=9时，第8行，交换20与90，第9行，将当前的根结点20进行大顶堆的调整，调整过程和刚才流程一样，找到它左右子结点的较大值，互换，再找到其子结点的较大值互换。<br>此时序列变为{80,70,50,60,10,40,20,30,90}，如图所示。<br><img src="/img/CSDataStructure/257.jpg"></p><p>2．<br>当i=8时，交换30与80，并将30与70交换，再与60交换，此时序列变为{70,60,50,30,10,40,20,80,90}，如图所示。<br><img src="/img/CSDataStructure/258.jpg"></p><p>3．后面的变化完全类似，不解释，只看图。<br><img src="/img/CSDataStructure/259.jpg"></p><p><img src="/img/CSDataStructure/260.jpg"><br>最终就得到一个完全有序的序列了。</p><h4 id="堆排序复杂度分析"><a href="#堆排序复杂度分析" class="headerlink" title="堆排序复杂度分析"></a>堆排序复杂度分析</h4><p>堆排序的效率到底有多高呢？我们来分析一下。</p><p>它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。</p><p>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。</p><p>在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根结点的距离为），并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。</p><p>所以总体来说，堆排序的时间复杂度为O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(nlogn)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的O(n2)的时间复杂度了。</p><p>空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。</p><p>另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>前面我们讲了堆排序，因为它用到了完全二叉树，充分利用了完全二叉树的深度是|log2n|+1的特性，所以效率比较高。</p><p>不过堆结构的设计本身是比较复杂的，老实说，能想出这样的结构就挺不容易，有没有更直接简单的办法利用完全二叉树来排序呢？当然有。</p><p>如图所示，我们将本是无序的数组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后再合并，最终获得了一个有序的数组。<br>注意仔细观察它的形状，你会发现，它像极了一棵倒置的完全二叉树，通常涉及到完全二叉树结构的排序算法，效率一般都不低的——这就是我们要讲的归并排序法。<br><img src="/img/CSDataStructure/261.jpg"></p><h3 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h3><p>“归并”一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。</p><p>归并排序（Merging Sort）就是利用归并的思想实现的排序方法。<br>它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</p><p>好了，有了对归并排序的初步认识后，我们来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作归并排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MergeSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MSort(L-&gt;r,  L-&gt;r,  <span class="number">1</span>,  L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句代码，别奇怪，它只是调用了另一个函数而已。<br>为了与前面的排序算法统一，我们用了同样的参数定义SqList *L，由于我们要讲解的归并排序实现需要用到递归调用，因此我们外封装了一个函数。<br>假设现在要对数组{50,10,90,30,70,40,80,60,20}进行排序，L.length=9，我现来看看MSort的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将SR[s..t]归并排序为TR1[s..t]  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MSort</span><span class="params">(<span class="keyword">int</span>  SR[],  <span class="keyword">int</span>  TR1[],  <span class="keyword">int</span>  s,  <span class="keyword">int</span>  t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  m;</span><br><span class="line"><span class="keyword">int</span>  TR2[MAXSIZE  +  <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (s  ==  t)</span><br><span class="line">&#123;</span><br><span class="line">TR1[s]  =  SR[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将SR[s..t]平分为SR[s..m]和SR[m+1..t]  */</span></span><br><span class="line">m  =  (s  +  t)  /  <span class="number">2</span>;                          </span><br><span class="line"><span class="comment">/*  递归将SR[s..m]归并为有序的TR2[s..m]  */</span></span><br><span class="line">MSort(SR,  TR2,  s,  m);                </span><br><span class="line"><span class="comment">/*  递归将SR[m+1..t]归并为有序TR2[m+1..t]  */</span></span><br><span class="line">MSort(SR,  TR2,  m  +  <span class="number">1</span>,  t);      </span><br><span class="line"><span class="comment">/*  将TR2[s..m]和TR2[m+1..t]  */</span></span><br><span class="line"><span class="comment">/*  归并到TR1[s..t]  */</span></span><br><span class="line">Merge(TR2,TR1,  s,  m,  t);          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>MSort被调用时，SR与TR1都是{50,10,90,30,70,40,80,60,20}，s=1，t=9，最终我们的目的就是要将TR1中的数组排好顺序。</p><p>2．<br>第5行，显然s不等于t，执行第8～13行语句块。</p><p>3．<br>第9行，m=(1+9)/2=5。m就是序列的正中间下标。</p><p>4．<br>此时第10行，调用“MSort(SR,TR2,1,5);”的目标就是将数组SR中的第1～5的关键字归并到有序的TR2（调用前TR2为空数组），<br>第11行，调用“MSort(SR,TR2,6,9);”的目标就是将数组SR中的第6～9的关键字归并到有序的TR2。</p><p>也就是说，在调用这两句代码之前，代码已经准备将数组分成了两组了，如图所示。<br><img src="/img/CSDataStructure/262.jpg"></p><p>5．<br>第12行，函数Merge的代码细节一会再讲，调用“Merge(TR2,TR1,1,5,9);”的目标其实就是将第10和11行代码获得的数组TR2（注意它是下标为1～5和6～9的关键字分别有序）归并为TR1，此时相当于整个排序就已经完成了，如图所示。</p><p>6．<br>再来看第10行递归调用进去后，s=1，t=5，m=(1+5)/2=3。此时相当于将5个记录拆分为三个和两个。<br>继续递归进去，直到细分为一个记录填入TR2，此时s与t相等，递归返回，如图的左图所示。<br>每次递归返回后都会执行当前递归函数的第12行，将TR2归并到TR1中，如图的右图所示，最终使得当前序列有序。<br><img src="/img/CSDataStructure/263.jpg"></p><p>7．<br>同样的第11行也是类似方式，如图所示。<br><img src="/img/CSDataStructure/264.jpg"></p><p>8．<br>此时也就是刚才所讲的最后一次执行第12行代码，将{10,30,50,70,90}与{20,40,60,80}归并为最终有序的序列。<br>可以说，如果对递归函数的运行方式理解比较透的话，MSort函数还是很好理解的。<br>我们来看看整个数据变换示意图，如图所示。<br><img src="/img/CSDataStructure/265.jpg"></p><p>现在我们来看看Merge函数的代码是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>  SR[],  <span class="keyword">int</span>  TR[],  <span class="keyword">int</span>  i,  <span class="keyword">int</span>  m,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j,  k,  l;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将SR中记录由小到大归并入TR  */</span></span><br><span class="line"><span class="keyword">for</span>  (j  =  m  +  <span class="number">1</span>,  k  =  i;  i  &lt;=  m  &amp;&amp;  j  &lt;=  n;  k++)        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>  (SR[i]  &lt;  SR[j])</span><br><span class="line">&#123;</span><br><span class="line">TR[k]  =  SR[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TR[k]  =  SR[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;=  m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (l  =  <span class="number">0</span>;  l  &lt;=  m  -  i;  l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将剩余的SR[i..m]复制到TR  */</span></span><br><span class="line">TR[k  +  l]=SR[i  +  l];</span><br><span class="line">&#125;                                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (j&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (l  =  <span class="number">0</span>;  l  &lt;=  n  -  j;  l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将剩余的SR[j..n]复制到TR  */</span></span><br><span class="line">TR[k  +  l]  =  SR[j  +  l];</span><br><span class="line">&#125;                                      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>假设我们此时调用的Merge就是将{10,30,50,70,90}与{20,40,60,80}归并为最终有序的序列，因此数组SR为{10,30,50,70,90,20,40,60,80}，i=1，m=5，n=9。</p><p>2．<br>第4行，for循环，j由m+1=6开始到9，i由1开始到5，k由1开始每次加1，k值用于目标数组TR的下标。</p><p>3．<br>第6行，SR[i]=SR[1]=10，SR[j]=SR[6]=20，SR[i]&lt;SR[j]，执行第7行，TR[k]=TR[1]=10，并且i++。如图所示。<br><img src="/img/CSDataStructure/266.jpg"></p><p>4．<br>再次循环，k++得到k=2，SR[i]=SR[2]=30，SR[j]=SR[6]=20，SR[i]&gt;SR[j]，执行第9行，TR[k]=TR[2]=20，并且j++，如图所示。<br><img src="/img/CSDataStructure/267.jpg"></p><p>5．<br>再次循环，k++得到k=3，SR[i]=SR[2]=30，SR[j]=SR[7]=40，SR[i]&lt;SR[j]，执行第7行，TR[k]=TR[3]=30，并且i++，如图所示。<br><img src="/img/CSDataStructure/268.jpg"></p><p>6．接下来完全相同的操作，一直到j++后，j=10，大于9退出循环，如图所示。<br><img src="/img/CSDataStructure/269.jpg"></p><p>7．<br>第11～20行的代码，其实就将归并剩下的数组数据，移动到TR的后面。<br>当前k=9，i=m=5，执行第13～20行代码，for循环l=0，TR[k+l]=SR[i+l]=90，大功告成。</p><h4 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h4><p>我们来分析一下归并排序的时间复杂度，一趟归并需要将SR[1]～SR[n]中相邻的长度为h的有序序列进行两两归并。<br>并将结果放到TR1[1]～TR1[n]中，这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行次，因此，总的时间复杂度为O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。</p><p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为log2n的栈空间，因此空间复杂度为O(n+logn)。</p><p>另外，对代码进行仔细研究，发现Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p><p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p><h3 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h3><p>我们常说，“没有最好，只有更好。”<br>归并排序大量引用了递归，尽管在代码上比较清晰，容易理解，但这会造成时间和空间上的性能损耗。<br>我们排序追求的就是效率，有没有可能将递归转化成迭代呢？结论当然是可以的，而且改动之后，性能上进一步提高了，来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作归并非递归排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MergeSort2</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  申请额外空间  */</span></span><br><span class="line"><span class="keyword">int</span>  *  TR  =  (<span class="keyword">int</span>  *)<span class="built_in">malloc</span>(L-&gt;length  *  <span class="keyword">sizeof</span>(<span class="keyword">int</span>));        </span><br><span class="line"><span class="keyword">int</span>  k  =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  (k  &lt;  L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">MergePass(L-&gt;r,  TR,  k,  L-&gt;length);</span><br><span class="line"><span class="comment">/*子序列长度加倍  */</span></span><br><span class="line">k  =  <span class="number">2</span>  *  k;                                                                                </span><br><span class="line">MergePass(TR,  L-&gt;r,  k,  L-&gt;length);</span><br><span class="line"><span class="comment">/*  子序列长度加倍  */</span></span><br><span class="line">k  =  <span class="number">2</span>  *  k;                                                                                </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始执行，数组L为{50,10,90,30,70,40,80,60,20}，L.length=9。</p><p>2．<br>第3行，我们事先申请了额外的数组内存空间，用来存放归并结果。</p><p>3．<br>第5～11行，是一个while循环，目的是不断地归并有序序列。<br>注意k值的变化，第8行与第10行，在不断循环中，它将由1→2→4→8→16，跳出循环。</p><p>4．<br>第7行，此时k=1，MergePass函数将原来的无序数组两两归并入TR（此函数代码稍后再讲），如图所示。<br><img src="/img/CSDataStructure/270.jpg"></p><p>5．第8行，k=2。</p><p>6．第9行，MergePass函数将TR中已经两两归并的有序序列再次归并回数组L.r中，如图所示。<br><img src="/img/CSDataStructure/271.jpg"></p><p>7．第10行，k=4，因为k&lt;9，所以继续循环，再次归并，最终执行完第7～10行，k=16，结束循环，完成排序工作，如图所示。<br><img src="/img/CSDataStructure/272.jpg"></p><p>从代码中，我们能够感受到，非递归的迭代做法更加直截了当，从最小的序列开始归并直至完成。<br>不需要像归并的递归算法一样，需要先拆分递归，再归并退出递归。</p><p>现在我们来看MergePass代码是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将SR[]中相邻长度为s的子序列两两归并到TR[]  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>  SR[],  <span class="keyword">int</span>  TR[],  <span class="keyword">int</span>  s,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i  =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>  j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  (i  &lt;=  n  -  <span class="number">2</span>  *  s  +  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  两两归并  */</span></span><br><span class="line">Merge(SR,  TR,  i,  i  +  s  -  <span class="number">1</span>,  i  +  <span class="number">2</span>  *  s  -  <span class="number">1</span>);        </span><br><span class="line">i  =  i  +  <span class="number">2</span>  *  s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  归并最后两个序列  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  n  -  s  +  <span class="number">1</span>)                                                                  </span><br><span class="line">&#123;</span><br><span class="line">Merge(SR,  TR,  i,  i  +  s  -  <span class="number">1</span>,  n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  若最后只剩下单个子序列  */</span></span><br><span class="line"><span class="keyword">else</span>                                                                                            </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (j  =  i;  j  &lt;=  n;  j++)</span><br><span class="line">&#123;</span><br><span class="line">TR[j]  =  SR[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序执行。<br>我们第一次调用“MergePass(L.r,TR,k,L.length);”，此时L.r是初始无序状态，TR为新申请的空数组，k=1，L.length=9。</p><p>2．<br>第5～9行，循环的目的就两两归并，因s=1，n-2×s＋1=8，为什么循环i从1到8，而不是9呢？<br>就是因为两两归并，最终9条记录定会剩下来，无法归并。</p><p>3．<br>第7行，Merge函数我们前面已经详细讲过，此时i=1，i＋s-1=1，i＋2×s-1=2。<br>也就是说，我们将SR（即L.r）中的第一个和第二个记录归并到TR中，然后第8行，i=i＋2×s=3，再循环，我们就是将第三个和第四个记录归并到TR中，一直到第七和第八个记录完成归并，如图所示。<br><img src="/img/CSDataStructure/273.jpg"></p><p>4．<br>第10～14行，主要是处理最后的尾数，第11行是说将最后剩下的多个记录归并到TR中。<br>不过由于i=9，n-s＋1=9，因此执行第13～14行，将20放入到TR数组的最后，如图所示。<br><img src="/img/CSDataStructure/274.jpg"></p><p>5．再次调用MergePass时，s=2，第5～9行的循环，由第8行的i=i＋2×s可知，此时i就是以4为增量进行循环了，也就是说，是将两个有两个记录的有序序列进行归并为四个记录的有序序列。<br>最终再将最后剩下的第九条记录“20”插入TR，如图所示。<br><img src="/img/CSDataStructure/275.jpg"></p><p>6．后面的类似，略。</p><p>非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O(n)，并且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑用非递归方法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。<br>而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。<br>即它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>从字面上感觉不出它的好处来。假设现在要对数组{50,10,90,30,70,40,80,60,20}进行排序。我们通过代码的讲解来学习快速排序的精妙。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L作快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">QuickSort</span><span class="params">(SqList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QSort(L,  <span class="number">1</span>,  L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一句代码，和归并排序一样，由于需要递归调用，因此我们外封装了一个函数。现在我们来看QSort的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L中的子序列L-&gt;r[low..high]作快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">QSort</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  low,  <span class="keyword">int</span>  high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  pivot;</span><br><span class="line"><span class="keyword">if</span>  (low  &lt;  high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将L-&gt;r[low..high]一分为二，  */</span></span><br><span class="line"><span class="comment">/*  算出枢轴值pivot  */</span></span><br><span class="line">pivot  =  Partition(L,  low,  high);        </span><br><span class="line"><span class="comment">/*  对低子表递归排序  */</span>QSort(L,  low,  pivot  -  <span class="number">1</span>);                      </span><br><span class="line"><span class="comment">/*  对高子表递归排序  */</span>QSort(L,  pivot  +  <span class="number">1</span>,  high);                    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里，你应该能理解前面代码“QSort(L,1,L-&gt;length);”中1和L-&gt;length代码的意思了，它就是当前待排序的序列最小下标值low和最大下标值high。</p><p>这一段代码的核心是“pivot=Parti-tion(L,low,high);”<br>在执行它之前，L.r的数组值为{50,10,90,30,70,40,80,60,20}。Partition函数要做的，就是先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴（pivot）。</p><p>在经过Partition(L,1,9)的执行之后，数组变成{20,10,40,30,50,70,80,60,90}，并返回值5给pivot，数字5表明50放置在数组下标为5的位置。<br>此时，计算机把原来的数组变成了两个位于50左和右小数组{20,10,40,30}和{70,80,60,90}，而后的递归调用“QSort(L,1,5-1);”和“QSort(L,5+1,9);”语句，其实就是在对{20,10,40,30}和{70,80,60,90}分别进行同样的Partition操作，直到顺序全部正确为止。</p><p>到了这里，应该说理解起来还不算困难。下面我们就来看看快速排序最关键的Partition函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置  */</span></span><br><span class="line"><span class="comment">/*  此时在它之前（后）的记录均不大（小）于它。  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Partition</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  low,  <span class="keyword">int</span>  high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  pivotkey;</span><br><span class="line"><span class="comment">/*  用子表的第一个记录作枢轴记录  */</span></span><br><span class="line">pivotkey  =  L-&gt;r[low];            </span><br><span class="line"><span class="comment">/*  从表的两端交替向中间扫描  */</span></span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high)                  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high  &amp;&amp;  L-&gt;r[high]  &gt;=  pivotkey)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  将比枢轴记录小的记录交换到低端  */</span></span><br><span class="line">swap(L,  low,  high);        </span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high  &amp;&amp;  L-&gt;r[low]  &lt;=  pivotkey)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  将比枢轴记录大的记录交换到高端  */</span></span><br><span class="line">swap(L,  low,  high);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  返回枢轴所在位置  */</span></span><br><span class="line"><span class="keyword">return</span>  low;                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1．<br>程序开始执行，此时low=1，high=L.length=9。第4行，我们将L.r[low]=L.r[1]=50赋值给枢轴变量pivotkey，如图所示。<br><img src="/img/CSDataStructure/276.jpg"></p><p>2．<br>第5～13行为while循环，目前low=1&lt;high=9，执行内部语句。</p><p>3．<br>第7行，L.r[high]=L.r[9]=20≯piv-otkey=50，因此不执行第8行。</p><p>4．<br>第9行，交换L.r[low]与L.r[high]的值，使得L.r[1]=20，L.r[9]=50。<br>为什么要交换，就是因为通过第7行的比较知道，L.r[high]是一个比pivotkey=50（即L.r[low]）还要小的值，因此它应该交换到50的左侧，如图所示。<br><img src="/img/CSDataStructure/277.jpg"></p><p>5．<br>第10行，当L.r[low]=L.r[1]=20，pivotkey=50，L.r[low]&lt;pivotkey，因此第11行，low++，此时low=2。继续循环，L.r[2]=10&lt;50，low++，此时low=3。L.r[3]=90&gt;50，退出循环。</p><p>6．<br>第12行，交换L.r[low]=L.r[3]与L.r[high]=L.r[9]的值，使得L.r[3]=50，L.r[9]=90。此时相当于将一个比50大的值90交换到了50的右边。注意此时low已经指向了3，如图所示。<br><img src="/img/CSDataStructure/278.jpg"></p><p>7．<br>继续第5行，因为low=3&lt;high=9，执行循环体。</p><p>8．<br>第7行，当L.r[high]=L.r[9]=90，pivotkey=50，L.r[high]&gt;pivotkey，因此第8行，high–，此时high=8。继续循环，L.r[8]=60&gt;50，high–，此时high=7。L.r[7]=80&gt;50，high–，此时high=6。L.r[6]=40&lt;50，退出循环。</p><p>9．<br>第9行，交换L.r[low]=L.r[3]=50与L.r[high]=L.r[6]=40的值，使得L.r[3]=40，L.r[6]=50，如图所示。<br><img src="/img/CSDataStructure/279.jpg"></p><p>10．<br>第10行，当L.r[low]=L.r[3]=40，pivotkey=50，L.r[low]&lt;pivotkey，因此第11行，low++，此时low=4。继续循环L.r[4]=30&lt;50，low++，此时low=5。L.r[5]=70&gt;50，退出循环。</p><p>11．<br>第12行，交换L.r[low]=L.r[5]=70与L.r[high]=L.r[6]=50的值，使得L.r[5]=50，L.r[6]=70，如图所示。<br><img src="/img/CSDataStructure/280.jpg"></p><p>12．<br>再次循环。因low=5&lt;high=6，执行循环体后，low=high=5，退出循环，如图所示。<br><img src="/img/CSDataStructure/281.jpg"></p><p>13．<br>最后第14行，返回low的值5。函数执行完成。<br>接下来就是递归调用“QSort(L,1,5-1);”和“QSort(L,5+1,9);”语句，对{20,10,40,30}和{70,80,60,90}分别进行同样的Partition操作，直到顺序全部正确为止。我们就不再演示了。</p><p>通过这段代码的模拟，大家应该能够明白，Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的换到它的右边，它也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p><h4 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h4><p>我们来分析一下快速排序法的性能。<br>快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。<br>如图所示，它是{50,10,90,30,70,40,80,60,20}在快速排序过程中的递归过程。<br>由于我们的第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。<br><img src="/img/CSDataStructure/282.jpg"></p><p>在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为（表示不大于x的最大整数），即仅需递归log2n次，需要时间为T(n)的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。<br>然后，获得的枢轴将数组一分为二，那么各自还需要T(n/2)的时间（注意是最好情况，所以平分两半）。<br>于是不断地划分下去，我们就有了下面的不等式推断。</p><p>T(n)  ≤  2T(n  /  2)  +  n,  T(1)  =  0<br>T(n)  ≤  2(2T(n  /  4)  +  n  /  2)  +  n  =  4T(n  /  4)+2n<br>T(n)  ≤  4(2T(n  /  8)  +  n  /  4)  +  2n  =  8T(n  /  8)+3n……<br>T(n)  ≤  nT(1)  +  (log2n)  ×  n  =  O(nlogn)</p><p>也就是说，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。</p><p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。<br>如果递归树画出来，它就是一棵斜树。此时需要执行n-1次递归调用，且第i次划分需要经过n-i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2，最终其时间复杂度为O(n2)。</p><p>平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：<br><img src="/img/CSDataStructure/283.jpg"><br>由数学归纳法可证明，其数量级为O(nlogn)。</p><p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n-1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。</p><p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p><h3 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h3><p>刚才讲的快速排序还是有不少可以改进的地方，我们来看一些优化的方案。</p><p>1．优化选取枢轴<br>如果我们选取的pivotkey是处于整个序列的中间位置，那么我们可以将整个序列分成小数集合和大数集合了。<br>但注意，我刚才说的是“如果……是中间”，那么假如我们选取的pivotkey不是中间数又如何呢？<br>比如我们前面讲冒泡和简单选择排序一直用到的数组{9,1,5,8,3,7,4,6,2}，由代码第4行“pivotkey=L-&gt;r[low];”知道，我们应该选取9作为第一个枢轴pivotkey。<br>此时，经过一轮“pivot=Partition(L,1,9);”转换后，它只是更换了9与2的位置，并且返回9给pivot，整个系列并没有实质性的变化，如图所示。<br><img src="/img/CSDataStructure/284.jpg"><br>就是说，代码第4行“pivotkey=L-&gt;r[low];”变成了一个潜在的性能瓶颈。<br>排序速度的快慢取决于L.r[1]的关键字处在整个序列的位置，L.r[1]太小或者太大，都会影响性能(比如第一例子中的50就是一个中间数，而第二例子的9就是一个相对整个序列过大的数)。<br>因为在现实中，待排序的系列极有可能是基本有序的，此时，总是固定选取第一个关键字（其实无论是固定选取哪一个位置的关键字）作为首个枢轴就变成了极为不合理的作法。</p><p>改进办法，有人提出，应该随机获得一个low与high之间的数rnd，让它的关键字L.r[rnd]与L.r[low]交换，此时就不容易出现这样的情况，这被称为随机选取枢轴法。<br>应该说，这在某种程度上，解决了对于基本有序的序列快速排序时的性能瓶颈。不过，随机就有些撞大运的感觉，万一没撞成功，随机到了依然是很小或很大的关键字怎么办呢？</p><p>再改进，于是就有了三数取中（median-of-three）法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。<br>这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。<br>由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。</p><p>我们来看看取左端、右端和中间三个数的实现代码，在Partition函数代码的第3行与第4行之间增加这样一段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  pivotkey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  计算数组中间的元素的下标  */</span></span><br><span class="line"><span class="keyword">int</span>  m  =  low  +  (high  -  low)  /  <span class="number">2</span>;  </span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[low]  &gt;  L-&gt;r[high])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换左端与右端数据，保证左端较小  */</span></span><br><span class="line">swap(L,  low,  high);</span><br><span class="line">&#125;                        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[m]  &gt;  L-&gt;r[high])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换中间与右端数据，保证中间较小  */</span></span><br><span class="line">swap(L,  high,  m);</span><br><span class="line">&#125;                            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;r[m]  &gt;  L-&gt;r[low])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  交换中间与左端数据，保证左端较小  */</span></span><br><span class="line">swap(L,  m,  low);</span><br><span class="line">&#125;                              </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  此时L.r[low]已经为整个序列左中右三个关键字的中间值。  */</span></span><br><span class="line"><span class="comment">/*用子表的第一个记录作枢轴记录  */</span></span><br><span class="line">pivotkey  =  L-&gt;r[low];</span><br></pre></td></tr></table></figure><p>试想一下，我们对数组{9,1,5,8,3,7,4,6,2}，取左9、中3、右2来比较，使得L.r[low]=3，一定要比9和2来得更为合理。</p><p>三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey，但是对于非常大的待排序的序列来说还是不足以保证能够选择出一个好的pivotkey，因此还有个办法是所谓九数取中（me-dian-of-nine），它先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。<br>显然这就更加保证了取到的pivotkey是比较接近中间值的关键字。有兴趣的同学可以自己去实现一下代码，这里不再详述了。</p><p>2．优化不必要的交换<br>观察之前的图，我们发现，50这个关键字，其位置变化是1→9→3→6→5，可其实它的最终目标就是5，当中的交换其实是不需要的。<br>因此我们对Partition函数的代码再进行优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  快速排序优化算法  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Partition1</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  low,  <span class="keyword">int</span>  high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  pivotkey;</span><br><span class="line"><span class="comment">/*  这里省略三数取中代码  */</span></span><br><span class="line"><span class="comment">/*  用子表的第一个记录作枢轴记录  */</span></span><br><span class="line">pivotkey  =  L-&gt;r[low];                    </span><br><span class="line"><span class="comment">/*  将枢轴关键字备份到L-&gt;r[0]  */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>]  =  pivotkey;                        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  从表的两端交替向中间扫描  */</span></span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high)                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high  &amp;&amp;  L-&gt;r[high]  &gt;=  pivotkey)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  采用替换而不是交换的方式进行操作  */</span></span><br><span class="line">L-&gt;r[low]  =  L-&gt;r[high];        </span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high  &amp;&amp;  L-&gt;r[low]  &lt;=  pivotkey)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  采用替换而不是交换的方式进行操作  */</span></span><br><span class="line">L-&gt;r[high]  =  L-&gt;r[low];        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将枢轴数值替换回L.r[low]  */</span></span><br><span class="line">L-&gt;r[low]  =  L-&gt;r[<span class="number">0</span>];                      </span><br><span class="line"><span class="comment">/*  返回枢轴所在位置  */</span></span><br><span class="line"><span class="keyword">return</span>  low;                                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码中加粗部分的改变。<br>我们事实将pivotkey备份到L.r[0]中，然后在之前是swap时，只作替换的工作，最终当low与high会合，即找到了枢轴的位置时，再将L.r[0]的数值赋值回L.r[low]。<br>因为这当中少了多次交换数据的操作，在性能上又得到了部分的提高。如图所示。<br><img src="/img/CSDataStructure/285.jpg"></p><p>3．优化小数组时的排序方案<br>对于一个数学科学家、博士生导师，他可以攻克世界性的难题，可以培养最优秀的数学博士，但让他去教小学生“1+1=2”的算术课程，那还真未必会比常年在小学里耕耘的数学老师教得好。<br>换句话说，大材小用有时会变得反而不好用。刚才我谈到了对于非常大的数组的解决办法。<br>那么相反的情况，如果数组非常小，其实快速排序反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。<br>其原因在于快速排序用到了递归操作，在大量数据排序时，这点性能影响相对于它的整体算法优势而言是可以忽略的，但如果数组只有几个记录需要排序时，这就成了一个大炮打蚊子的大问题。</p><p>因此我们需要改进一下QSort函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_LENGTH_INSERT_SORT  7              </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  数组长度阀值  */</span></span><br><span class="line"><span class="comment">/*  对顺序表L中的子序列L.r[low..high]作快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">QSort</span><span class="params">(SqList  &amp;L,  <span class="keyword">int</span>  low,  <span class="keyword">int</span>  high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  pivot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  ((high  -  low)  &gt;  MAX_LENGTH_INSERT_SORT)</span><br><span class="line">&#123;                                                  </span><br><span class="line"><span class="comment">/*  当high-low大于常数时用快速排序  */</span></span><br><span class="line"><span class="comment">/*  将L.r[low..high]一分为二，  */</span></span><br><span class="line"><span class="comment">/*  并算出枢轴值pivot  */</span></span><br><span class="line">pivot  =  Partition(L,  low,  high);        </span><br><span class="line"><span class="comment">/*  对低子表递归排序  */</span></span><br><span class="line">QSort(L,  low,  pivot  -  <span class="number">1</span>);                      </span><br><span class="line"><span class="comment">/*  对高子表递归排序  */</span></span><br><span class="line">QSort(L,  pivot  +  <span class="number">1</span>,  high);                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                                               </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  当high-low小于等于常数时用直接插入排序  */</span></span><br><span class="line">InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们增加了一个判断，当high-low不大于某个常数时（有资料认为7比较合适，也有认为50更合理，实际应用可适当调整），就用直接插入排序，这样就能保证最大化地利用两种排序的优势来完成排序工作。</p><p>4．优化递归操作<br>大家知道，递归对性能是有一定影响的，QSort函数在其尾部有两次递归操作。<br>如果待排序的序列划分极端不平衡，递归深度将趋近于n，而不是平衡时的log2n，这就不仅仅是速度快慢的问题了。<br>栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。<br>因此如果能减少递归，将会大大提高性能。</p><p>于是我们对QSort实施尾递归优化。来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  对顺序表L中的子序列L.r[low..high]作快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">QSort1</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  low,  <span class="keyword">int</span>  high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  pivot;</span><br><span class="line"><span class="keyword">if</span>  ((high  -  low)  &gt;  MAX_LENGTH_INSERT_SORT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>  (low  &lt;  high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  L.r[low..high]一分为二,  */</span></span><br><span class="line"><span class="comment">/*  算出枢轴值pivot  */</span></span><br><span class="line">pivot  =  Partition1(L,  low,  high);        </span><br><span class="line"><span class="comment">/*  对低子表递归排序  */</span></span><br><span class="line">QSort1(L,  low,  pivot  -  <span class="number">1</span>);                     </span><br><span class="line"><span class="comment">/*  尾递归  */</span></span><br><span class="line">low  =  pivot  +  <span class="number">1</span>;                               </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们将if改成while后（见加粗代码部分），因为第一次递归以后，变量low就没有用处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high)，其效果等同于“QSort(L,pivot+1,high);”。</p><p>结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。</p><p>在现实的应用中，比如C++、java、PHP、C#、VB、JavaScript等都有对快速排序算法的实现，实现方式上略有不同，但基本上都是在我们讲解的快速排序法基础上的精神体现。</p><h6 id="了不起的排序算法"><a href="#了不起的排序算法" class="headerlink" title="了不起的排序算法"></a>了不起的排序算法</h6><p>我们现在学过的排序算法，有按照实现方法分类命名的，如简单选择排序、直接插入排序、归并排序，有按照其排序的方式类比现实世界命名的，比如冒泡排序、堆排序，还有用人名命名的，比如希尔排序。</p><p>但是刚才我们讲的排序，却用“快速”来命名，这也就意味着只要再有人找到更好的排序法，此“快速”就会名不符实，不过，至少今天，TonyHoare发明的快速排序法经过多次的优化后，在整体性能上，依然是排序算法王者，我们应该要好好研究并掌握它。</p><h1 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h1><p>本章内容只是在讲排序，我们需要对已经提到的各个排序算法进行对比来总结回顾。</p><p>首先我们讲了排序的定义，并提到了排序的稳定性，排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中，我们需要关注此算法的稳定性如何。</p><p>我们根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的算法。</p><p>根据排序过程中借助的主要操作，我们将内排序分为：插入排序、交换排序、选择排序和归并排序四类。<br>之后介绍的7种排序法，就分别是各种分类的代表算法。<br><img src="/img/CSDataStructure/286.jpg"><br>事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p><p>因此我们就来从多个角度来剖析一下提到的各种排序的长与短。<br>我们将7种算法的各种指标进行对比，如表所示。<br><img src="/img/CSDataStructure/287.jpg"><br>从算法的简单性来看，我们将7种算法分为两类：<br>简单算法：冒泡、简单选择、直接插入。<br>改进算法：希尔、堆、归并、快速。</p><p>从平均情况来看，显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。<br>从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。<br>从最坏情况看，堆排序与归并排序又强过快速排序以及其他简单排序。</p><p>从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。<br>堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。<br>但是他们如果都来比赛计算个位数的加减法，它们反而算不过成绩极普通的冒泡和直接插入。</p><p>从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是O(1)。<br>如果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排序就不是一个较好的决策了。</p><p>从稳定性来看，归并排序独占鳌头，我们前面也说过，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p><p>从待排序记录的个数上来说，待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适。<br>这也就是我们为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p><p>从上表的数据中，似乎简单选择排序在3种简单排序中性能最差，其实也不完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出3种简单排序算法的移动次数比较，如下表所示。<br><img src="/img/CSDataStructure/288.jpg"><br>你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量比较后选择明确记录进行移动，有的放矢。<br>因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。<br>另外，记录的关键字信息量大小对那四个改进算法影响不大。</p><p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用不同的算法来应对它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;假设含有n个记录的序列为{r1,r2,……,rn}，其相应的关键字分别为{k1,k2,……,kn}，需确定1,2,……,n的一种排列p1,p</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="排序" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>C语言快速入门</title>
    <link href="https://afoolzwt.github.io/2022/05/14/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://afoolzwt.github.io/2022/05/14/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2022-05-14T08:13:46.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C 基本语法"></a>C 基本语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>声明自动变量</td></tr><tr><td>break</td><td>跳出当前循环</td></tr><tr><td>case</td><td>开关语句分支</td></tr><tr><td>char</td><td>声明字符型变量或函数返回值类型</td></tr><tr><td>const</td><td>定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td></tr><tr><td>continue</td><td>结束当前循环，开始下一轮循环</td></tr><tr><td>default</td><td>开关语句中的”其它”分支</td></tr><tr><td>do</td><td>循环语句的循环体</td></tr><tr><td>double</td><td>声明双精度浮点型变量或函数返回值类型</td></tr><tr><td>else</td><td>条件语句否定分支（与 if 连用）</td></tr><tr><td>enum</td><td>声明枚举类型</td></tr><tr><td>extern</td><td>声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td>float</td><td>声明浮点型变量或函数返回值类型</td></tr><tr><td>for</td><td>一种循环语句</td></tr><tr><td>goto</td><td>无条件跳转语句</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>int</td><td>声明整型变量或函数返回值类型</td></tr><tr><td>long</td><td>声明长整型变量或函数返回值类型</td></tr><tr><td>register</td><td>声明寄存器变量</td></tr><tr><td>return</td><td>子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td>short</td><td>声明短整型变量或函数返回值类型</td></tr><tr><td>signed</td><td>声明有符号类型变量或函数返回值类型</td></tr><tr><td>sizeof</td><td>计算数据类型或变量长度（即所占字节数）</td></tr><tr><td>static</td><td>声明静态变量</td></tr><tr><td>struct</td><td>声明结构体类型</td></tr><tr><td>switch</td><td>用于开关语句</td></tr><tr><td>typedef</td><td>用以给数据类型取别名</td></tr><tr><td>unsigned</td><td>声明无符号类型变量或函数返回值类型</td></tr><tr><td>union</td><td>声明共用体类型</td></tr><tr><td>void</td><td>声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td>volatile</td><td>说明变量在程序执行中可被隐含地改变</td></tr><tr><td>while</td><td>循环语句的循环条件</td></tr></tbody></table><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h1><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。<br>C 中的类型可分为以下几种：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td>基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td>2</td><td>枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td>3</td><td>void 类型：类型说明符 void 表明没有可用的值。</td></tr><tr><td>4</td><td>派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr></tbody></table><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td>double</td><td>8 字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td>long double</td><td>16 字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19 位有效位</td></tr></tbody></table><h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td>函数返回为空:    C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</td></tr><tr><td>2</td><td>函数参数为空:    C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</td></tr><tr><td>3</td><td>指针指向 void:    类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h1><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。<br>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：</p><table><thead><tr><th>序号</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>通常是一个字节（八位）, 这是一个整数类型。</td></tr><tr><td>int</td><td>整型，4 个字节，取值范围 -2147483648 到 2147483647。</td></tr><tr><td>float</td><td>单精度浮点值。单精度是1位符号，8位指数，23位小数。</td></tr><tr><td>double</td><td>双精度浮点值。双精度是1位符号，11位指数，52位小数。</td></tr><tr><td>void</td><td>表示类型的缺失。</td></tr></tbody></table><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等。</p><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C 中的变量定义"></a>C 中的变量定义</h2><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。<br>变量的声明有两种情况：</p><ul><li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li><li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li><li>除非有extern关键字，否则都是变量的定义。<h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C 中的左值（Lvalues）和右值（Rvalues）"></a>C 中的左值（Lvalues）和右值（Rvalues）</h2>C 中有两种类型的表达式：</li><li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li><li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。<br>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h1>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。<br>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。<br>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2>在 C 中，有两种简单的定义常量的方式：</li><li>使用 #define 预处理器。</li><li>使用 const 关键字。<h1 id="C-储存类"><a href="#C-储存类" class="headerlink" title="C 储存类"></a>C 储存类</h1>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</li><li>auto</li><li>register</li><li>static</li><li>extern<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2>auto 存储类是所有局部变量默认的存储类。<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。<br>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</li><li>寄存器：寄存器的功能是存储二进制代码，它是由具有存储功能的触发器组合起来构成的。寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。</li><li>RAM：随机存取存储器（英语：Random Access Memory，缩写：RAM），也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与ROM的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。</li><li>ROM：只读存储器（Read-Only Memory，ROM）以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。ROM所存数据稳定 ，断电后所存数据也不会改变，并且结构较简单，使用方便，因而常用于存储各种固定程序和数据。<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。<br>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。<br>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。<br>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。<h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C 运算符"></a>C 运算符</h1>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</li><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>杂项运算符<h2 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回变量的大小</td><td>sizeof(a) 将返回 4，其中 a 是整数</td></tr><tr><td>&amp;</td><td>返回变量的地址</td><td>&a; 将给出变量的实际地址</td></tr><tr><td>*</td><td>指向一个变量</td><td>*a; 将指向一个变量</td></tr><tr><td>?</td><td>条件表达式</td><td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table><h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C 判断"></a>C 判断</h1>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。<br>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。<h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C 循环"></a>C 循环</h1>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。<br>编程语言提供了更为复杂执行路径的多种控制结构。循环语句允许我们多次执行一个语句或语句组。<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C 函数"></a>C 函数</h1>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。<br>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。<br>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。<br>C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。<br>函数还有很多叫法，比如方法、子例程或程序，等等。<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。<br>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。<h1 id="C-作用域规则"><a href="#C-作用域规则" class="headerlink" title="C 作用域规则"></a>C 作用域规则</h1>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</li><li>在函数或块内部的局部变量</li><li>在所有函数外部的全局变量</li><li>在形式参数的函数参数定义中<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。<br>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。<br>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。<h2 id="全局变量与局部变量在内存中的区别："><a href="#全局变量与局部变量在内存中的区别：" class="headerlink" title="全局变量与局部变量在内存中的区别："></a>全局变量与局部变量在内存中的区别：</h2>全局变量保存在内存的全局存储区中，占用静态的存储单元。<br>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C 数组"></a>C 数组</h1>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。<br>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。<h1 id="C-enum-枚举"><a href="#C-enum-枚举" class="headerlink" title="C enum(枚举)"></a>C enum(枚举)</h1>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h1><img src="/img/CLearn/1.png"><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。<br>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。<br>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。<h2 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h2>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">var 变量的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">ip 变量存储的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h2>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。<br>NULL 指针是一个定义在标准库中的值为零的常量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2>函数指针是指向函数的指针变量。<br>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。<br>函数指针可以像一般函数一样，用于调用函数、传递参数。<br>函数指针变量的声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure>实例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">请输入三个数字:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">最大的数字是: <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2>函数指针作为某个函数的参数。<br>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。<br>简单讲：回调函数是由别人的函数执行时调用你实现的函数。<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h1>在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。<br>空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。<h1 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h1>C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure><h1 id="C-共用体"><a href="#C-共用体" class="headerlink" title="C 共用体"></a>C 共用体</h1>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。<h2 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h2>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one <span class="keyword">or</span> more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。<br>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。<h2 id="访问共用体成员"><a href="#访问共用体成员" class="headerlink" title="访问共用体成员"></a>访问共用体成员</h2>为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">data.i : <span class="number">1917853763</span></span><br><span class="line">data.f : <span class="number">4122360580327794860452759994368.000000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">data.i : <span class="number">10</span></span><br><span class="line">data.f : <span class="number">220.500000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure><h1 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h1>如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。<h2 id="位域声明"><a href="#位域声明" class="headerlink" title="位域声明"></a>位域声明</h2>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。<br>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>典型的实例：</li><li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li><li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。<h3 id="位域的定义和位域变量的说明"><a href="#位域的定义和位域变量的说明" class="headerlink" title="位域的定义和位域变量的说明"></a>位域的定义和位域变量的说明</h3>位域定义与结构定义相仿，其形式为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> 位域列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>其中位域列表的形式为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type [member_name] : width ;</span><br></pre></td></tr></table></figure>下面是有关位域中变量元素的描述：</li></ul><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>type</td><td>只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td></tr><tr><td>member_name</td><td>位域的名称。</td></tr><tr><td>width</td><td>位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td></tr></tbody></table><p>带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br></pre></td></tr></table></figure><h1 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C typedef"></a>C typedef</h1><p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure><p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BYTE  b1, b2;</span><br></pre></td></tr></table></figure><p><img src="/img/CLearn/2.jpg"><br>*是申明时标记是指针变量</p><h2 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h2><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p><ul><li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li><li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。<h1 id="C-输入-amp-输出"><a href="#C-输入-amp-输出" class="headerlink" title="C 输入 &amp; 输出"></a>C 输入 &amp; 输出</h1>当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。<br>当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基本语法&quot;&gt;&lt;a href=&quot;#C-基本语法&quot; class=&quot;headerlink&quot; title=&quot;C 基本语法&quot;&gt;&lt;/a&gt;C 基本语法&lt;/h1&gt;&lt;h2 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字</summary>
      
    
    
    
    <category term="C" scheme="https://afoolzwt.github.io/categories/C/"/>
    
    <category term="C语言快速入门" scheme="https://afoolzwt.github.io/categories/C/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="C" scheme="https://afoolzwt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode日记</title>
    <link href="https://afoolzwt.github.io/2022/05/14/Leetcode%E6%97%A5%E8%AE%B0/"/>
    <id>https://afoolzwt.github.io/2022/05/14/Leetcode%E6%97%A5%E8%AE%B0/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2022-05-14T08:12:31.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-04-27-LeetCode-26-简单"><a href="#2022-04-27-LeetCode-26-简单" class="headerlink" title="2022/04/27 LeetCode.26 简单"></a>2022/04/27 LeetCode.26 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/04/27 LeetCode.26 简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：62.38% 内存消耗：59.40%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> indexP = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.Length; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (nums[i] != num)</span><br><span class="line">              &#123;</span><br><span class="line">                  num = nums[i];</span><br><span class="line">                  nums[++indexP] = num;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> indexP + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-04-28-LeetCode-27移除元素-简单"><a href="#2022-04-28-LeetCode-27移除元素-简单" class="headerlink" title="2022/04/28 LeetCode.27移除元素 简单"></a>2022/04/28 LeetCode.27移除元素 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/04/28 LeetCode.27移除元素 简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：7.48% 内存消耗：10.92%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RemoveElement</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> val</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">              &#123;</span><br><span class="line">                  index++;</span><br><span class="line">                  <span class="keyword">if</span> (i!=index)</span><br><span class="line">                  &#123;</span><br><span class="line">                      nums[index] = nums[i];</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 双指针优化 至多只需遍历一次</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：75.13% 内存消耗：81.80%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RemoveElement1</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> val</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">int</span> right = nums.Length;</span><br><span class="line">          <span class="keyword">while</span> (left&lt;right)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (nums[left] == val)</span><br><span class="line">              &#123;</span><br><span class="line">                  nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">                  right--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  left++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> left;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-04-29-LeetCode-35搜索插入位置-简单"><a href="#2022-04-29-LeetCode-35搜索插入位置-简单" class="headerlink" title="2022/04/29 LeetCode.35搜索插入位置 简单"></a>2022/04/29 LeetCode.35搜索插入位置 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/04/29 LeetCode.35搜索插入位置 简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 双指针二分法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：20.49% 内存消耗：86.41%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SearchInsert</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (nums[middle] == target)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">return</span> middle;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">              &#123;</span><br><span class="line">                  right = middle - <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">              &#123;</span><br><span class="line">                  left = middle + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> left;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-05-LeetCode-66加一-简单"><a href="#2022-05-05-LeetCode-66加一-简单" class="headerlink" title="2022/05/05 LeetCode.66加一 简单"></a>2022/05/05 LeetCode.66加一 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/05/05 LeetCode.66加一 简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：55.04% 内存消耗：63.67%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">PlusOne</span>(<span class="params"><span class="built_in">int</span>[] digits</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = digits.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (digits[i] == <span class="number">9</span>)<span class="comment">//需要进位</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//需要扩充数组</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="built_in">int</span>[] newdisgits = <span class="keyword">new</span> <span class="built_in">int</span>[digits.Length + <span class="number">1</span>];</span><br><span class="line">                      newdisgits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">return</span> newdisgits;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      digits[i] = <span class="number">0</span>;</span><br><span class="line">                  &#125;          </span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  digits[i]++;</span><br><span class="line">                  <span class="keyword">return</span> digits;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> digits;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-06-LeetCode-70爬楼梯-简单"><a href="#2022-05-06-LeetCode-70爬楼梯-简单" class="headerlink" title="2022/05/06 LeetCode.70爬楼梯 简单"></a>2022/05/06 LeetCode.70爬楼梯 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/05/06 LeetCode.70爬楼梯 简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 到第n-1个台阶的走法 + 第n-2个台阶的走法 = 到第n个台阶的走法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：82.65% 内存消耗：43.42%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">int</span> temp, a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              temp = a;<span class="comment">//temp用于记录i-2的台阶方法数</span></span><br><span class="line">              a = b;</span><br><span class="line">              b = temp + a;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-07-LeetCode-53最大子数组和-简单"><a href="#2022-05-07-LeetCode-53最大子数组和-简单" class="headerlink" title="2022/05/07 LeetCode.53最大子数组和 简单"></a>2022/05/07 LeetCode.53最大子数组和 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 2022/05/07 LeetCode.53最大子数组和 简单</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 动态规划</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 执行用时：18.61% 内存消耗：36.78%</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">int</span> preAns = <span class="number">0</span>;<span class="comment">//前置数组和</span></span><br><span class="line">         <span class="built_in">int</span> maxAns = nums[<span class="number">0</span>];<span class="comment">//最大数组和</span></span><br><span class="line">         <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> nums)</span><br><span class="line">         &#123;</span><br><span class="line">             preAns = Math.Max(preAns + num, num);<span class="comment">//如果当前数+前置数组和  小于当前数 则舍弃前置数组</span></span><br><span class="line">             maxAns = Math.Max(maxAns, preAns);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> maxAns;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-09-LeetCode-1两数之和-简单"><a href="#2022-05-09-LeetCode-1两数之和-简单" class="headerlink" title="2022/05/09 LeetCode.1两数之和 简单"></a>2022/05/09 LeetCode.1两数之和 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 2022/05/09 LeetCode.1两数之和 简单</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 双指针</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 执行用时：78.73% 内存消耗：83.46%</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; targetDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();<span class="comment">//对应值 索引位置 </span></span><br><span class="line"></span><br><span class="line">         <span class="built_in">int</span> left = <span class="number">0</span>, right = nums.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">int</span> targetNum = target - nums[left];</span><br><span class="line">             <span class="keyword">if</span> (targetDic.ContainsKey(targetNum))</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; left, targetDic[targetNum] &#125;;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 targetDic[nums[left]] = left;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             targetNum = target - nums[right];</span><br><span class="line">             <span class="keyword">if</span> (targetDic.ContainsKey(targetNum))</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; right, targetDic[targetNum] &#125;;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 targetDic[nums[right]] = right;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             left++;</span><br><span class="line">             right--;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">0</span>&#125;;<span class="comment">//题意不会走到这步</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-10-LeetCode-58最后一个单词的长度-简单"><a href="#2022-05-10-LeetCode-58最后一个单词的长度-简单" class="headerlink" title="2022/05/10 LeetCode.58最后一个单词的长度 简单"></a>2022/05/10 LeetCode.58最后一个单词的长度 简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 2022/05/10 LeetCode.58最后一个单词的长度 简单</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 执行用时：97.08% 内存消耗：65.33%</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LengthOfLastWord</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">int</span> length = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = s.Length - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   length++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(length != <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> length;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-11-LeetCode-69x的平方根-简单"><a href="#2022-05-11-LeetCode-69x的平方根-简单" class="headerlink" title="2022/05/11 LeetCode.69x的平方根  简单"></a>2022/05/11 LeetCode.69x的平方根  简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/05/11 LeetCode.69x的平方根  简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 二分查找</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：90.08% 内存消耗：37.81%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MySqrt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> min = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">int</span> max = x;</span><br><span class="line">          <span class="keyword">while</span> (max - min &gt; <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> temp = (max + min) / <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span> (x/ temp &lt; temp)</span><br><span class="line">              &#123;</span><br><span class="line">                  max = temp;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (x/ temp &gt; temp)</span><br><span class="line">              &#123;</span><br><span class="line">                  min = temp;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">return</span> temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> min;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-12-LeetCode-88-合并两个有序数组-简单"><a href="#2022-05-12-LeetCode-88-合并两个有序数组-简单" class="headerlink" title="2022/05/12 LeetCode 88. 合并两个有序数组  简单"></a>2022/05/12 LeetCode 88. 合并两个有序数组  简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/05/12 LeetCode 88. 合并两个有序数组  简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 理解题意</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：64.64% 内存消耗：16.85%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Merge</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span> m, <span class="built_in">int</span>[] nums2, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> one = m - <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> two = n - <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> newNode = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (two &gt;=<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (one &lt; <span class="number">0</span> || nums2[two] &gt; nums1[one])</span><br><span class="line">              &#123;</span><br><span class="line">                  nums1[newNode--] = nums2[two--];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  nums1[newNode--] = nums1[one--];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="2022-05-13-LeetCode-43-字符串相乘-简单"><a href="#2022-05-13-LeetCode-43-字符串相乘-简单" class="headerlink" title="2022/05/13 LeetCode 43. 字符串相乘  简单"></a>2022/05/13 LeetCode 43. 字符串相乘  简单</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 2022/05/13 LeetCode 43. 字符串相乘  简单</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 模拟竖式乘法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行用时：46.71% 内存消耗：32.24%</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">string</span> result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">int</span> lengthOne = num1.Length;</span><br><span class="line">          <span class="built_in">int</span> lengthTwo = num2.Length;</span><br><span class="line"></span><br><span class="line">          Stack&lt;<span class="built_in">int</span>&gt; addStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();<span class="comment">//计数栈</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = lengthTwo - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//以num2去乘num1</span></span><br><span class="line">          &#123;</span><br><span class="line">              StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                            </span><br><span class="line">              <span class="keyword">for</span> (<span class="built_in">int</span> j = lengthTwo - <span class="number">1</span>; j &gt;i; j--)<span class="comment">//高位相乘 需要添加对应的0</span></span><br><span class="line">              &#123;</span><br><span class="line">                  addStack.Push(<span class="number">0</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">int</span> num = num2[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//乘数</span></span><br><span class="line"></span><br><span class="line">              <span class="built_in">int</span> <span class="keyword">add</span> = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="built_in">int</span> k = lengthOne - <span class="number">1</span>; k &gt;=<span class="number">0</span>; k--)<span class="comment">//乘法计算</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="built_in">int</span> singleNum = num1[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                  <span class="built_in">int</span> ans = num * singleNum + <span class="keyword">add</span>;</span><br><span class="line">                  addStack.Push(ans % <span class="number">10</span>);</span><br><span class="line">                  <span class="keyword">add</span> = ans / <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">add</span> != <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  addStack.Push(<span class="keyword">add</span> % <span class="number">10</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">while</span> (addStack.Count &gt; <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  sb.Append(addStack.Pop());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//结果相加</span></span><br><span class="line">              result = AddStr(result, sb.ToString());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">AddStr</span>(<span class="params"><span class="built_in">string</span> result,<span class="built_in">string</span> addStr</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> lengthResult = result.Length - <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> lengthAdd = addStr.Length - <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> Add = <span class="number">0</span>;</span><br><span class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">          Stack&lt;<span class="built_in">int</span>&gt; addStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();<span class="comment">//计数栈</span></span><br><span class="line">          <span class="keyword">while</span> (lengthResult &gt;= <span class="number">0</span> || lengthAdd &gt;=<span class="number">0</span> || Add != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> x = lengthResult &gt;= <span class="number">0</span> ? result[lengthResult] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">              <span class="built_in">int</span> y = lengthAdd &gt;= <span class="number">0</span> ? addStr[lengthAdd] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">              <span class="built_in">int</span> ans = x + y + Add;</span><br><span class="line">              addStack.Push(ans % <span class="number">10</span>);</span><br><span class="line">              Add = ans / <span class="number">10</span>;</span><br><span class="line">              lengthResult--; lengthAdd--;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (addStack.Count &gt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              sb.Append(addStack.Pop());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> sb.ToString();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-04-27-LeetCode-26-简单&quot;&gt;&lt;a href=&quot;#2022-04-27-LeetCode-26-简单&quot; class=&quot;headerlink&quot; title=&quot;2022/04/27 LeetCode.26 简单&quot;&gt;&lt;/a&gt;2022/04/27 </summary>
      
    
    
    
    <category term="算法" scheme="https://afoolzwt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode日记" scheme="https://afoolzwt.github.io/categories/%E7%AE%97%E6%B3%95/LeetCode%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://afoolzwt.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>《两周自制脚本语言》</title>
    <link href="https://afoolzwt.github.io/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"/>
    <id>https://afoolzwt.github.io/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2022-05-14T08:17:44.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><h2 id="BNF中使用的元符号"><a href="#BNF中使用的元符号" class="headerlink" title="BNF中使用的元符号"></a>BNF中使用的元符号</h2><ul><li><p>{ pat } 模式pat至少重复0次</p></li><li><p>[ pat ] 与重复出现0次或1次的模式pat匹配</p></li><li><p>pat1 | pat2 与pat1或pat2匹配</p></li><li><p>( ) 将括号内视为一个完整的模式</p><h2 id="BNF表达规则"><a href="#BNF表达规则" class="headerlink" title="BNF表达规则"></a>BNF表达规则</h2><p>factor :            NUMBER | “(” expression “)”<br>term :                 factor { (“*” | “/“) factor }<br>expression :     term { (“+” | “-“) term }</p></li><li><p>:左侧所写的内容能够用于表示与在:右侧所写的模式相匹配的单词序列。</p></li></ul><p>factor :    NUMBER | “(” expression “)”<br>factor(因子)意指与右侧模式匹配的单词序列。:左侧出现的诸如factor这样的符号称为非终结符或元变量。</p><ul><li>:右侧的模式中也包含了若干个终结符或非终结符。</li></ul><p>与非终结符相对的是终结符，他们是一些事先规定好的符号，表示各种单词。<br>NUMBER这种由大写字母组成的名称，以及由双引号”括起的诸如”(“的符号就是终结符。<br>NUMBER表示任意一个整型字面量单词，”(“表示一个内容为左括号的单词。</p><p>factor :    NUMBER | “(” expression “)”        规则对应的定义=&gt;    factor能表示NUMBER（1个整型字面量单词），或由左括号、expression（表达式）及右括号依次排列而成的单词序列。expression是一个非终结符，第3行对其下了定义。因此，由左括号、与expression匹配的单词序列，及右括号这些单词组成的单词序列能与factor模式匹配。</p><p>如果：右侧的模式中仅含有终结符，BNF与正则表达式没有什么区别。此时，两者唯一的不同仅在于具体是以单词为单位检查匹配还是以字符为单位检查。<br>另一方面，如果右侧含有类似于expression这样的非终结符，与该部分匹配的单词序列必须与另外定义的expression模式匹配。非终结符可以理解为常用模式的别称，在定义其他模式时能够引用这些非终结符。模式中包含非终结符是BNF的特诊之一。</p><ul><li>term :                 factor { (“*” | “/“) factor }</li></ul><p>term（项）表示一种由factor与运算符*或/构成的序列，其中factor至少出现一次，运算符则必须夹在两个factor之间。由于{}括起来的模式将至少重复0次，因此，第2行的规则直译过来就是：与模式term匹配的内容，或是一个与factor相匹配的单词序列，或是在一个与factor相匹配的单词序列之后，由运算符 * 或 / 以及factor构成的组合再重复若干次得到的序列。</p><ul><li>expression :     term { (“+” | “-“) term }</li></ul><p>expression表示一种由term（对term对应的单词序列）与运算符+或-构成的序列，其中term至少出现一次，运算符则必须夹在两个term之间。<br>结合所有这些规则，可以发现与模式expression匹配的就是通常的四则运算表达式，只不过单词的排列顺序做了修改。也就是说，与该模式匹配的单词序列就是一个expression。反之，如果单词序列与模式expression不匹配，则会发生语法错误（syntax error）。</p><h1 id="Chapter5"><a href="#Chapter5" class="headerlink" title="Chapter5"></a>Chapter5</h1><h2 id="自定义的语法规则"><a href="#自定义的语法规则" class="headerlink" title="自定义的语法规则"></a>自定义的语法规则</h2><p>NUMBER、IDENTIFIER、STRING、OP与EOL都是终结符，分别表示整型字面量、标识符、字符串字面量、双目运算符与换行符类型。</p><p>非终结符expr（expression的缩写）用于表示表达式。</p><ul><li>primary : “(” expr “)” | NUMBER | IDENTIFIER | STRING</li></ul><p>非终结符primary（基本构成元素）用于表示括号括起的表达式、整型字面量、标识符（即变量名）或字符串字面量。这些是最基本的表达式构成元素。</p><ul><li>factor : “-“ primary | primary</li></ul><p>非终结符factor（因子）或表示一个primary，或表示primary之前再添加一个-号的组合。</p><ul><li>expr : factor { OP factor }</li></ul><p>expr（表达式）用于表示两个factor之间夹有一个双目运算符的组合。</p><ul><li>block : “{“ [ statement ] { (“;” | EOL) [ statement ] } “}”</li></ul><p>block（代码块）指的是由{}括起来的statement（语句）序列，statement之间需要用分号或换行符（EOL）分割。由于语法支持空语句，因此规则中的statement两侧写有中括号[]。<br>可以看到，它的结构大致与expr类似。它们都由其他的非终结符（statement或factor）与一些用于分隔的符号组合而成。</p><ul><li>simple : expr</li></ul><p>简单表达式语句是仅由（expr）构成的语句。</p><ul><li>statement : “if” expr block [ “else” block ]<br>| “while” expr block<br>| simple</li></ul><p>statement可以是if语句、while语句或仅仅是简单表达式语句（simple）。</p><ul><li>program : [ statement ] ( “;” | EOL )</li></ul><p>最后的program是一个非终结符，它可以包含分号或换行符，用于表示一句完整的语句。其中，statement可以省略，因此program还能用来表示空行。代码块中最后一句能够省略句尾分号与换行符，为此，分别设计了statement与program两种类型。program既可以是处于代码块之外的一条语句，也可以是一行完整的程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-4&quot;&gt;&lt;a href=&quot;#Chapter-4&quot; class=&quot;headerlink&quot; title=&quot;Chapter 4&quot;&gt;&lt;/a&gt;Chapter 4&lt;/h1&gt;&lt;h2 id=&quot;BNF中使用的元符号&quot;&gt;&lt;a href=&quot;#BNF中使用的元符号&quot; cla</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《两周自制脚本语言》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》（线性表）</title>
    <link href="https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/"/>
    <id>https://afoolzwt.github.io/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2022-05-14T08:26:10.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-数据结构绪论"><a href="#Chapter-1-数据结构绪论" class="headerlink" title="Chapter 1 数据结构绪论"></a>Chapter 1 数据结构绪论</h1><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象：是性质相同的数据元素的集合，是数据的子集。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p><h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构：是指数据对象中数据元素之间的相互关系。逻辑结构分为以下四种：</p><ul><li>1.集合结构</li></ul><p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。<br><img src="/img/CSDataStructure/1.jpg"></p><ul><li>2.线性结构</li></ul><p>线性结构：线性结构中的数据元素之间是一对一的关系。<br><img src="/img/CSDataStructure/2.jpg"></p><ul><li>3.树形结构</li></ul><p>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。<br><img src="/img/CSDataStructure/3.jpg"></p><ul><li>4.图形结构</li></ul><p>图形结构：图形结构的数据元素是多对多的关系。<br><img src="/img/CSDataStructure/4.jpg"></p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。<br>数据元素的存储结构形式有两种：顺序存储和链式存储。</p><ul><li>1.顺序存储结构</li></ul><p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。<br><img src="/img/CSDataStructure/5.jpg"></p><ul><li>2.链式存储结构</li></ul><p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。<br><img src="/img/CSDataStructure/6.jpg"></p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。<br>在C语言中，按照取值的不同，数据类型可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。<h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。<br>抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/img/CSDataStructure/7.jpg"><br><img src="/img/CSDataStructure/8.jpg"></li></ul><h1 id="Chapter-2-算法"><a href="#Chapter-2-算法" class="headerlink" title="Chapter 2 算法"></a>Chapter 2 算法</h1><p>算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>算法具有零个或多个输入，算法至少有一个或多个输出。</p><h3 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h3><p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。<br>但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出结果。 3.算法程序对于非法的输入数据能够得出满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>可读性：算法设计的另一目的是为了便于阅读、理解和交流。</p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p><h3 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h3><p>时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。</p><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><h3 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h3><p>事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p><h3 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h3><p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</p><h2 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h2><p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。<br>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p><h3 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h3><p>推导大O阶：</p><ul><li>1．用常数1取代运行时间中的所有加法常数。</li><li>2．在修改后的运行次数函数中，只保留最高阶项。</li><li>3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是大O阶。<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4>事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。<br>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4>要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  count  =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>  (count  &lt;  n)</span><br><span class="line">&#123;</span><br><span class="line">count  =  count  *  <span class="number">2</span>;</span><br><span class="line"><span class="comment">/*  时间复杂度为O(1)的程序步骤序列  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由2x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table><thead><tr><th>执行次数</th><th>函数阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n2  +2n+1</td><td>O(n2)</td><td>平方阶</td></tr><tr><td>5log2n+20</td><td>O(logn)</td><td>对数阶</td></tr><tr><td>2n+3nlog2n+19</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr><td>6n3+2n2+3n+4</td><td>O(n3  )</td><td>立方阶</td></tr><tr><td>2n</td><td>O(2n)</td><td>指数阶</td></tr></tbody></table></li></ul><p>常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn)</p><h2 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h2><p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p><h2 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h2><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。<br>如果用数学语言来进行定义。可如下：<br>若将线性表记为（a1，…，ai-1，ai，ai+1，…，an），则表中ai-1领先于ai，ai+1领先于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱。<br>所以线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。<br>在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的位序。<br>线性表的抽象数据类型定义如下：</p><ul><li>ADT<br>  线性表(List)</li><li>Data<br>线性表的数据对象集合为{a1,  a2,  ……,  an}，每个元素的类型均为DataType。<br>其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。<br>数据元素之间的关系是一对一的关系。</li><li>Operation<br>InitList(*L):                    初始化操作，建立一个空的线性表L。<br>ListEmpty(L):                    若线性表为空，返回true，否则返回false。<br>ClearList(*L):                  将线性表清空。<br>GetElem(L,  i,  *e):          将线性表L中的第i个位置元素值返回给e。<br>LocateElem(L,  e):            在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将所有的在线性表Lb中但不在La中的数据元素插入到La中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">unionL</span><span class="params">(List  *La,  List  Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  La_len,  Lb_len,  i;</span><br><span class="line"><span class="comment">/*  声明与La和Lb相同的数据元素e  */</span></span><br><span class="line">ElemType  e;</span><br><span class="line"><span class="comment">/*  求线性表的长度  */</span></span><br><span class="line">La_len  =  ListLength(*La);                 </span><br><span class="line">Lb_len  =  ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">1</span>;  i  &lt;=  Lb_len;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  取Lb中第i个数据元素赋给e  */</span></span><br><span class="line">GetElem(Lb,  i,  &amp;e);                       </span><br><span class="line"><span class="comment">/*  La中不存在和e相同数据元素  */</span></span><br><span class="line"><span class="keyword">if</span>  (!LocateElem(*La,  e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  插入  */</span></span><br><span class="line">ListInsert(La,  ++La_len,  e);</span><br><span class="line">&#125;                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3>线性表的顺序存储的结构代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  存储空间初始分配量  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  20                        </span></span><br><span class="line"><span class="comment">/*  ElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  ElemType;                    </span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  数组存储数据元素，最大值为MAXSIZE  */</span></span><br><span class="line">ElemType  data[MAXSIZE];        </span><br><span class="line"><span class="comment">/*  线性表当前长度  */</span></span><br><span class="line"><span class="keyword">int</span>  length;</span><br><span class="line">&#125;SqList;            </span><br></pre></td></tr></table></figure>描述顺序存储结构需要三个属性：</li><li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度MaxSize。</li><li>线性表的当前长度：length。<h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。<br>由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。LOC(ai+1)=LOC(ai)+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：LOC(ai)=LOC(a1)+(i-1)*c</li></ul><p>通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OK  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ERROR  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FALSE  0</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  Status;</span><br><span class="line"><span class="comment">/*  Status是函数的类型，其值是函数结果状态代码，如OK等  */</span></span><br><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：用e返回L中第i个数据元素的值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">GetElem</span><span class="params">(SqList  L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (L.length  ==  <span class="number">0</span>  ||  i  &lt;  <span class="number">1</span>  ||  i  &gt;  L.length)<span class="keyword">return</span>  ERROR;</span><br><span class="line">*e  =  L.data[i  -  <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入算法的思路：<br>如果插入位置不合理，抛出异常；<br>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>将要插入元素填入位置i处；<br>表长加1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)，  */</span></span><br><span class="line"><span class="comment">/*  操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  k;</span><br><span class="line"><span class="comment">/*  顺序线性表已经满  */</span></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;length  ==  MAXSIZE)<span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  当i不在范围内时  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;L-&gt;length  +  <span class="number">1</span>)      <span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  若插入数据位置不在表尾  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;=  L-&gt;length)                      </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*将要插入位置后数据元素向后移动一位  */</span></span><br><span class="line"><span class="keyword">for</span>  (k  =  L-&gt;length  -  <span class="number">1</span>;  k  &gt;=  i  -  <span class="number">1</span>;  k--)</span><br><span class="line">        L-&gt;data[k  +  <span class="number">1</span>]  =  L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  将新元素插入  */</span></span><br><span class="line">L-&gt;data[i  -  <span class="number">1</span>]  =  e;                     </span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：<br>如果删除位置不合理，抛出异常；<br>取出删除元素；<br>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>表长减1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(SqList  *L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  k;</span><br><span class="line"><span class="comment">/*  线性表为空  */</span></span><br><span class="line"><span class="keyword">if</span>  (L-&gt;length  ==  <span class="number">0</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  删除位置不正确  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  L-&gt;length)<span class="keyword">return</span>  ERROR;</span><br><span class="line">*e  =  L-&gt;data[i  -  <span class="number">1</span>];</span><br><span class="line"><span class="comment">/*  如果删除不是最后位置  */</span></span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  L-&gt;length)                     </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将删除位置后继元素前移  */</span></span><br><span class="line"><span class="keyword">for</span>  (k  =  i;  k  &lt;  L-&gt;length;  k++)      L-&gt;data[k  -  <span class="number">1</span>]  =  L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。<br><img src="/img/CSDataStructure/9.jpg"></p><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="顺序存储结构不足的解决办法"><a href="#顺序存储结构不足的解决办法" class="headerlink" title="顺序存储结构不足的解决办法"></a>顺序存储结构不足的解决办法</h3><p>为什么当插入和删除时，就要移动大量元素，仔细分析后，发现原因就在于相邻两元素的存储位置也具有邻居关系。它们编号是1，2，3，…，n，它们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速介入，而删除后，当中就会留出空隙，自然需要弥补。问题就出在这里。</p><h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。<br>以前在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。<br>因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。<br>我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。<br>n个结点（ai的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。<br>对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><h3 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h3><p><img src="/img/CSDataStructure/10.jpg"></p><h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>若线性表为空表，则头结点的指针域为“空”。<br>单链表中，我们在C语言中可用结构指针来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的单链表存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">/*  定义LinkList  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>  *<span class="title">LinkList</span>;</span>    </span><br></pre></td></tr></table></figure><p>从这个结构定义中，我们也就知道，结点由存放数据元素的数据域和存放后继结点地址的指针域组成。假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p-&gt;data来表示，p-&gt;data的值是一个数据元素，结点ai的指针域可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向谁呢？当然是指向第i+1个元素，即指向ai+1的指针。也就是说，如果p-&gt;data=ai，那么p-&gt;next-&gt;data=ai+1。</p><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>1.声明一个指针p指向链表第一个结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，返回结点p的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：用e返回L中第i个数据元素的值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">GetElem</span><span class="params">(LinkList  L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j;</span><br><span class="line">LinkList  p;                        </span><br><span class="line"><span class="comment">/*  声明一指针p  */</span></span><br><span class="line">p  =  L-&gt;next;                </span><br><span class="line"><span class="comment">/*  让p指向链表L的第个结点  */</span></span><br><span class="line">j  =  <span class="number">1</span>;                                  </span><br><span class="line"><span class="comment">/*  j为计数器  */</span></span><br><span class="line"><span class="comment">/*  p不为空且计数器j还没有等于i时，循环继续  */</span></span><br><span class="line"><span class="keyword">while</span>  (p  &amp;&amp;  j  &lt;  i)</span><br><span class="line">   &#123;</span><br><span class="line">p  =  p-&gt;next;        </span><br><span class="line"><span class="comment">/*  让p指向下一个结点  */</span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>  (!p  ||  j  &gt;  i)<span class="keyword">return</span>  ERROR;            </span><br><span class="line"><span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line"></span><br><span class="line">*e  =  p-&gt;data;              </span><br><span class="line"><span class="comment">/*  取第i个结点的数据  */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说白了，就是从头开始找，直到第i个结点为止。由于这个算法的时间复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据了，而当i=n时则遍历n-1次才可以。因此最坏情况的时间复杂度是O(n)。</p><h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>单链表第i个数据插入结点的算法思路：<br>1.声明一指针p指向链表头结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，在系统中生成一个空结点s；<br>5.将数据元素e赋值给s-&gt;data；<br>6.单链表的插入标准语句s-&gt;next=p-&gt;next;p-&gt;next=s；<br>7.返回成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)，  */</span></span><br><span class="line"><span class="comment">/*  操作结果：在L中第i个结点位置之前插入新的数据元素e，L的长度加1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j;</span><br><span class="line">LinkList  p,s;</span><br><span class="line">p  =  *L;</span><br><span class="line">j  =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*  寻找第i-1个结点  */</span></span><br><span class="line"><span class="keyword">while</span>  (p  &amp;&amp;  j  &lt;  i)                     </span><br><span class="line">&#123;</span><br><span class="line">p  =  p-&gt;next;++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line"><span class="keyword">if</span>  (!p  ||  j  &gt;  i)<span class="keyword">return</span>  ERROR;</span><br><span class="line">    <span class="comment">/*  生成新结点（C标准函数）  */</span></span><br><span class="line">s  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data  =  e;</span><br><span class="line"><span class="comment">/*  将p的后继结点赋值给s的后继  */</span></span><br><span class="line">s-&gt;next  =  p-&gt;next;                        </span><br><span class="line"><span class="comment">/*  将s赋值给p的后继  */</span></span><br><span class="line">p-&gt;next  =  s;                              </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>单链表第i个数据删除结点的算法思路：<br>1.声明一指针p指向链表头结点，初始化j从1开始；<br>2.当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；<br>3.若到链表末尾p为空，则说明第i个结点不存在；<br>4.否则查找成功，将欲删除的结点p-&gt;next赋值给q；<br>5.单链表的删除标准语句p-&gt;next=q-&gt;next；<br>6.将q结点中的数据赋值给e，作为返回；<br>7.释放q结点；<br>8.返回成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></span><br><span class="line"><span class="comment">/*  操作结果：删除L的第i个结点，并用e返回其值，L的长度减1  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  i,  ElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j;</span><br><span class="line">LinkList  p,q;</span><br><span class="line">p  =  *L;</span><br><span class="line">j  =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*  遍历寻找第i-1个结点  */</span></span><br><span class="line"><span class="keyword">while</span>  (p-&gt;next  &amp;&amp;  j  &lt;  i)        </span><br><span class="line">&#123;p  =  p-&gt;next;++j;&#125;</span><br><span class="line"><span class="comment">/*  第i个结点不存在  */</span></span><br><span class="line"><span class="keyword">if</span>  (!(p-&gt;next)  ||  j  &gt;  i)<span class="keyword">return</span>  ERROR;</span><br><span class="line"></span><br><span class="line">    q  =  p-&gt;next;</span><br><span class="line"><span class="comment">/*  将q的后继赋值给p的后继  */</span></span><br><span class="line">p-&gt;next  =  q-&gt;next;                    </span><br><span class="line"><span class="comment">/*  将q结点中的数据给e  */</span></span><br><span class="line">*e  =  q-&gt;data;                             </span><br><span class="line"><span class="comment">/*  让系统回收此结点，释放内存  */</span></span><br><span class="line"><span class="built_in">free</span>(q);                                    </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。<br>从整个算法来说，我们很容易推导出：它们的时间复杂度都是O(n)。如果在我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。<br>但如果，我们希望从第i个位置，插入10个结点，对于顺序存储结构意味着，每一次插入都需要移动n-i个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。<br>显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p><h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>回顾一下，顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。<br>而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。<br>所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。</p><p>单链表整表创建的算法思路：<br>1.声明一指针p和计数器变量i；<br>2.初始化一空链表L；<br>3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表；<br>4.循环：<br>生成一新结点赋值给p；<br>随机生成一数字赋值给p的数据域p-&gt;data；<br>将p插入到头结点与前一新结点之间。</p><ul><li>头插法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateListHead</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList  p;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="comment">/*  初始化随机数种子  */</span></span><br><span class="line">srand(time(<span class="number">0</span>));                             </span><br><span class="line">*L  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">/*  先建立一个带头结点的单链表  */</span></span><br><span class="line">(*L)-&gt;next  =  <span class="literal">NULL</span>;                        </span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  n;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  生成新结点  */</span></span><br><span class="line">p  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));       </span><br><span class="line"><span class="comment">/*  随机生成100以内的数字  */</span></span><br><span class="line">p-&gt;data  =  rand()  %  <span class="number">100</span>  +  <span class="number">1</span>;           </span><br><span class="line">p-&gt;next  =  (*L)-&gt;next;</span><br><span class="line"><span class="comment">/*  插入到表头  */</span></span><br><span class="line">(*L)-&gt;next  =  p;                           </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>尾插法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateListTail</span><span class="params">(LinkList  *L,  <span class="keyword">int</span>  n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList  p,r;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="comment">/*  初始化随机数种子  */</span></span><br><span class="line">srand(time(<span class="number">0</span>));                             </span><br><span class="line"><span class="comment">/*  为整个线性表  */</span></span><br><span class="line">*L  =  (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      </span><br><span class="line"><span class="comment">/*  r为指向尾部的结点  */</span></span><br><span class="line">r  =  *L;                                   </span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  n;  i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  生成新结点  */</span></span><br><span class="line">p  =  (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      </span><br><span class="line"><span class="comment">/*  随机生成100以内的数字  */</span></span><br><span class="line">p-&gt;data  =  rand()  %  <span class="number">100</span>  +  <span class="number">1</span>;           </span><br><span class="line"><span class="comment">/*  将表尾终端结点的指针指向新结点  */</span></span><br><span class="line">r-&gt;next  =  p;                              </span><br><span class="line"><span class="comment">/*  将当前的新结点定义为表尾终端结点  */</span></span><br><span class="line">r  =  p;                                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  表示当前链表结束  */</span></span><br><span class="line">r-&gt;next  =  <span class="literal">NULL</span>;                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3>单链表整表删除的算法思路如下：</li></ul><p>1.声明一指针p和q；<br>2.将第一个结点赋值给p；<br>3.循环：<br>将下一结点赋值给q；<br>释放p；<br>将q赋值给p。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：顺序线性表L已存在，操作结果：将L重置为空表  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ClearList</span><span class="params">(LinkList  *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList  p,  q;</span><br><span class="line"><span class="comment">/*  p指向第一个结点  */</span></span><br><span class="line">p  =  (*L)-&gt;next;              </span><br><span class="line"><span class="comment">/*  没到表尾  */</span></span><br><span class="line"><span class="keyword">while</span>  (p)                          </span><br><span class="line">&#123;</span><br><span class="line">q  =  p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  头结点指针域为空  */</span></span><br><span class="line">(*L)-&gt;next  =  <span class="literal">NULL</span>;       </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p><img src="/img/CSDataStructure/11.jpg"><br>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。<br>若需要频繁插入和删除时，宜采用单链表结构。<br>比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。<br>而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚。<br>当然，这只是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。<br>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。<br>而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。<br>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。</p><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>首先我们让数组的元素都是由两个数据域组成，data和cur。<br>也就是说，数组的每个下标都对应一个data和一个cur。<br>数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的静态链表存储结构  */</span></span><br><span class="line"><span class="comment">/*  假设链表的最大长度是1000  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  1000                 </span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType  data;</span><br><span class="line"><span class="comment">/*  游标（Cursor），为0时表示无指向  */</span></span><br><span class="line"><span class="keyword">int</span>  cur;                              </span><br><span class="line">&#125;  Component,  </span><br><span class="line"><span class="comment">/*  对于不提供结构struct的程序设计语言，可以使用一对并行数组data和cur来处理。  */</span></span><br><span class="line">StaticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将一维数组space中各分量链成一备用链表，  */</span></span><br><span class="line"><span class="comment">/*  space[0].cur为头指针，&quot;0&quot;表示空指针  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InitList</span><span class="params">(StaticLinkList  space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line"><span class="keyword">for</span>  (i  =  <span class="number">0</span>;  i  &lt;  MAXSIZE  -  <span class="number">1</span>;  i++)</span><br><span class="line">&#123;</span><br><span class="line">space[i].cur  =  i  +  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  目前静态链表为空，最后一个元素的cur为0  */</span></span><br><span class="line">space[MAXSIZE  -  <span class="number">1</span>].cur  =  <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。<br>我们通常把未被使用的数组元素称为备用链表。<br>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。<br><img src="/img/CSDataStructure/12.jpg"><br>此时“甲”这里就存有下一元素“乙”的游标2，“乙”则存有下一元素“丁”的下标3。而“庚”是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一有值元素而存有它的下标为1。而第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存有7。<br><img src="/img/CSDataStructure/13.jpg"></p><h2 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h2><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。<br>我们前面说过，在动态链表中，结点的申请和释放分别借用malloc()和free()两个函数来实现。<br>在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若备用空间链表非空，则返回分配的结点下标，否则返回0  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Malloc_SLL</span><span class="params">(StaticLinkList  space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  当前数组第一个元素的cur存的值，  */</span></span><br><span class="line"><span class="comment">/*  就是要返回的第一个备用空闲的下标  */</span></span><br><span class="line"><span class="keyword">int</span>  i  =  space[<span class="number">0</span>].cur;       </span><br><span class="line"><span class="comment">/*  由于要拿出一个分量来使用了，所以我们  */</span></span><br><span class="line"><span class="comment">/*  就得把它的下一个分量用来做备用  */</span></span><br><span class="line"><span class="keyword">if</span>  (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur  =  space[i].cur;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span>  i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  在L中第i个元素之前插入新的数据元素e    */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListInsert</span><span class="params">(StaticLinkList  L,  <span class="keyword">int</span>  i,  ElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j,  k,  l;</span><br><span class="line"><span class="comment">/*  注意k首先是最后一个元素的下标  */</span></span><br><span class="line">k  =  MAX_SIZE  -  <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  ListLength(L)  +  <span class="number">1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  获得空闲分量的下标  */</span></span><br><span class="line">j  =  Malloc_SSL(L);           </span><br><span class="line"><span class="keyword">if</span>  (j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  将数据赋值给此分量的data  */</span></span><br><span class="line">L[j].data  =  e;               </span><br><span class="line"><span class="comment">/*  找到第i个元素之前的位置  */</span></span><br><span class="line"><span class="keyword">for</span>  (l  =  <span class="number">1</span>;  l  &lt;=  i  -  <span class="number">1</span>;  l++)</span><br><span class="line">&#123;</span><br><span class="line"> k  =  L[k].cur;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">/*  把第i个元素之前的cur赋值给新元素的cur  */</span></span><br><span class="line">L[j].cur  =  L[k].cur;         </span><br><span class="line"><span class="comment">/*  把新元素的下标赋值给第i个元素之前元素的cur  */</span></span><br><span class="line">L[k].cur  =  j;                </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  ERROR;</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作。<br><img src="/img/CSDataStructure/14.jpg"><h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  删除在L中第i个数据元素e  */</span></span><br><span class="line"><span class="function">Status  <span class="title">ListDelete</span><span class="params">(StaticLinkList  L,  <span class="keyword">int</span>  i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j,  k;</span><br><span class="line"><span class="keyword">if</span>  (i  &lt;  <span class="number">1</span>  ||  i  &gt;  ListLength(L))<span class="keyword">return</span>  ERROR;</span><br><span class="line">k  =  MAX_SIZE  -  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>  (j  =  <span class="number">1</span>;  j  &lt;=  i  -  <span class="number">1</span>;  j++)</span><br><span class="line">&#123;</span><br><span class="line">k  =  L[k].cur;</span><br><span class="line">&#125;</span><br><span class="line">j  =  L[k].cur;<span class="comment">// 待删除元素i的索引j</span></span><br><span class="line">L[k].cur  =  L[j].cur;</span><br><span class="line">Free_SSL(L,  j);</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Free_SSL(L,  j)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将下标为k的空闲结点回收到备用链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Free_SSL</span><span class="params">(StaticLinkList  space,  <span class="keyword">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  把第一个元素cur值赋给要删除的分量cur  */</span></span><br><span class="line">space[k].cur  =  space[<span class="number">0</span>].cur;     </span><br><span class="line"><span class="comment">/*  把要删除的分量下标赋值给第一个元素的cur  */</span></span><br><span class="line">space[<span class="number">0</span>].cur  =  k;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/CSDataStructure/15.jpg"></li><li>ListLength<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始条件：静态链表L已存在。操作结果：返回L中数据元素个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">ListLength</span><span class="params">(StaticLinkList  L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j  =  <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>  i  =  L[MAXSIZE  -  <span class="number">1</span>].cur;</span><br><span class="line"><span class="keyword">while</span>  (i)</span><br><span class="line">&#123;</span><br><span class="line">i  =  L[i].cur;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><img src="/img/CSDataStructure/16.jpg"><br>顺序储存结构随机存取：顺序存储结构的地址在内存中是连续的所以可以通过计算地址实现随机存取，与此相对 链式存储结构的存储地址不一定连续，只能通过第个结点的指针顺序存取。<br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，这并不是说，循环链表一定要头结点，这需要注意。</li></ul><p>合并两个循环链表<br><img src="/img/CSDataStructure/17.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  保存A表的头结点*/</span></span><br><span class="line">p  =  rearA-&gt;next;                                        </span><br><span class="line"><span class="comment">/*将本是指向B表的第一个结点（不是头结点）  */</span></span><br><span class="line">rearA-&gt;next  =  rearB-&gt;next-&gt;next;        </span><br><span class="line"><span class="comment">/*  赋值给reaA-&gt;next*/</span></span><br><span class="line">q  =  rearB-&gt;next;</span><br><span class="line"><span class="comment">/*  将原A表的头结点赋值给rearB-&gt;next */</span></span><br><span class="line">rearB-&gt;next  =  p;                                        </span><br><span class="line"><span class="comment">/*  释放q  */</span></span><br><span class="line"><span class="built_in">free</span>(q); </span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  线性表的双向链表存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">DuLNode</span>  *<span class="title">prior</span>;</span>        </span><br><span class="line"><span class="comment">/*  直接前驱指针  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">DuLNode</span>  *<span class="title">next</span>;</span>          </span><br><span class="line"><span class="comment">/*  直接后继指针  */</span></span><br><span class="line">&#125;  DulNode,  *DuLinkList;</span><br></pre></td></tr></table></figure><p><img src="/img/CSDataStructure/18.jpg"><br>双向链表既然是比单链表多了如可以反向遍历查找等数据结构，那么也就需要付出一些小的代价：在插入和删除时，需要更改两个指针变量。</p><ul><li>插入操作</li></ul><p>插入操作时，其实并不复杂，不过顺序很重要，千万不能写反了。<br><img src="/img/CSDataStructure/19.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  把p赋值给s的前驱，如图中①  */</span></span><br><span class="line">s-&gt;prior  =  p;                    </span><br><span class="line"><span class="comment">/*  把p-&gt;next赋值给s的后继，如图中②  */</span></span><br><span class="line">s-&gt;next  =  p-&gt;next;          </span><br><span class="line"><span class="comment">/*  把s赋值给p-&gt;next的前驱，如图中③  */</span></span><br><span class="line">p-&gt;next-&gt;prior  =  s;        </span><br><span class="line"><span class="comment">/*  把s赋值给p的后继，如图中④  */</span></span><br><span class="line">p-&gt;next  =  s;      </span><br></pre></td></tr></table></figure><ul><li>删除操作<br><img src="/img/CSDataStructure/20.jpg"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  把p-&gt;next赋值给p-&gt;prior的后继，如图中①  */</span></span><br><span class="line">p-&gt;prior-&gt;next  =  p-&gt;next;          </span><br><span class="line"><span class="comment">/*  把p-&gt;prior赋值给p-&gt;next的前驱，如图中②  */</span></span><br><span class="line">p-&gt;next-&gt;prior  =  p-&gt;prior;       </span><br><span class="line"> <span class="comment">/*  释放结点  */</span></span><br><span class="line"><span class="built_in">free</span>(p);         </span><br></pre></td></tr></table></figure><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。<br>它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。<br>然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br><img src="/img/CSDataStructure/21.jpg"><h1 id="第四章-栈与队列"><a href="#第四章-栈与队列" class="headerlink" title="第四章 栈与队列"></a>第四章 栈与队列</h1>栈是限定仅在表尾进行插入和删除操作的线性表。<br>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2></li><li>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</li></ul><p>我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（LastIn First Out）的线性表，简称LIFO结构。</p><ul><li>理解栈的定义需要注意：</li></ul><p>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</p><p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p><p>栈的插入操作，叫作进栈，也称压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</p><h3 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h3><p>这个最先进栈的元素，是不是就只能是最后出栈呢？<br>答案是不一定，要看什么情况。<br>栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。</p><p>第一种：1、2、3进，再3、2、1出。这是最简单的最好理解的一种，出栈次序为321。<br>第二种：1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出栈次序为123。<br>第三种：1进，2进，2出，1出，3进，3出。出栈次序为213。<br>第四种：1进，1出，2进，3进，3出，2出。出栈次序为132。<br>第五种：1进，2进，2出，3进，3出，1出。出栈次序为231。</p><h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>ADT  栈(stack)<br>    Data<br>        同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。<br>    Operation<br>        InitStack(*S):            初始化操作，建立一个空栈S。<br>        DestroyStack(*S):      若栈存在，则销毁它。<br>        ClearStack(*S):          将栈清空。<br>        StackEmpty(S):        若栈为空，返回true，否则返回false。<br>        GetTop(S,  *e):        若栈存在且非空，用e返回S的栈顶元素。<br>        Push(*S,  e):            若栈S存在，插入新元素e到栈S中并成为栈顶元素。<br>        Pop(*S,  *e):            删除栈S中栈顶元素，并用e返回其值。<br>        StackLength(S):      返回栈S的元素个数。<br>endADT</p><p>由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。</p><h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><p>既然栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除的线性表来说，用数组哪一端来作为栈顶和栈底比较好？<br>对，没错，下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。</p><h4 id="栈的结构定义"><a href="#栈的结构定义" class="headerlink" title="栈的结构定义"></a>栈的结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  SElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  SElemType;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType  data[MAXSIZE];</span><br><span class="line"><span class="comment">/*  用于栈顶指针  */</span></span><br><span class="line"><span class="keyword">int</span>  top;                           </span><br><span class="line"> &#125;SqStack;</span><br></pre></td></tr></table></figure><h3 id="栈的顺序存储结构——进栈操作-push"><a href="#栈的顺序存储结构——进栈操作-push" class="headerlink" title="栈的顺序存储结构——进栈操作(push)"></a>栈的顺序存储结构——进栈操作(push)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(SqStack  *S,  SElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  栈满  */</span></span><br><span class="line"><span class="keyword">if</span>  (S-&gt;top  ==  MAXSIZE  -  <span class="number">1</span>)   &#123;<span class="keyword">return</span>  ERROR;&#125;</span><br><span class="line"><span class="comment">/*  栈顶指针增加一  */</span></span><br><span class="line">S-&gt;top++;                                          </span><br><span class="line"><span class="comment">/*  将新插入元素赋值给栈顶空间  */</span></span><br><span class="line">S-&gt;data[S-&gt;top]  =  e;                    </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的顺序存储结构——出栈-pop"><a href="#栈的顺序存储结构——出栈-pop" class="headerlink" title="栈的顺序存储结构——出栈(pop)"></a>栈的顺序存储结构——出栈(pop)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(SqStack  *S,  SElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (S-&gt;top  ==  <span class="number">-1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  将要删除的栈顶元素赋值给e  */</span></span><br><span class="line">*e  =  S-&gt;data[S-&gt;top];        </span><br><span class="line"><span class="comment">/*  栈顶指针减一  */</span></span><br><span class="line">S-&gt;top--;                                </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。</p><h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。<br>不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。<br>对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。<br><img src="/img/CSDataStructure/22.jpg"><br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两栈共享空间结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType  data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span>  top1;        <span class="comment">/*  栈1栈顶指针  */</span></span><br><span class="line"><span class="keyword">int</span>  top2;        <span class="comment">/*  栈2栈顶指针  */</span></span><br><span class="line">&#125;  SqDoubleStack;</span><br></pre></td></tr></table></figure><p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(SqDoubleStack  *S,  SElemType  e,  <span class="keyword">int</span>  stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  栈已满，不能再push新元素了  */</span></span><br><span class="line"><span class="keyword">if</span>  (S-&gt;top1  +  <span class="number">1</span>  ==  S-&gt;top2)        <span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="keyword">if</span>  (stackNumber  ==  <span class="number">1</span>)<span class="comment">/*  栈1有元素进栈  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若栈1则先top1+1后给数组元素赋值  */</span></span><br><span class="line">S-&gt;data[++S-&gt;top1]  =  e; </span><br><span class="line">&#125;                     </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (stackNumber  ==  <span class="number">2</span>)<span class="comment">/*  栈2有元素进栈  */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  若栈2则先top2-1后给数组元素赋值  */</span></span><br><span class="line">S-&gt;data[--S-&gt;top2]  =  e;</span><br><span class="line">&#125;                 </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(SqDoubleStack  *S,  SElemType  *e,  <span class="keyword">int</span>  stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>  (stackNumber  ==  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  说明栈1已经是空栈，溢出  */</span></span><br><span class="line"><span class="keyword">if</span>  (S-&gt;top1  ==  <span class="number">-1</span>)<span class="keyword">return</span>  ERROR;</span><br><span class="line">    <span class="comment">/*  将栈1的栈顶元素出栈  */</span></span><br><span class="line">*e  =  S-&gt;data[S-&gt;top1--];        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>  (stackNumber  ==  <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  说明栈2已经是空栈，溢出  */</span></span><br><span class="line"><span class="keyword">if</span>  (S-&gt;top2  ==  MAXSIZE)<span class="keyword">return</span>  ERROR;                      </span><br><span class="line"><span class="comment">/*  将栈2的栈顶元素出栈  */</span></span><br><span class="line">*e  =  S-&gt;data[S-&gt;top2++];       </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><p>栈的链式存储结构，简称为链栈。<br>想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。<br>链栈的结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">StackNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  StackNode,  *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkStackPtr  top;</span><br><span class="line"><span class="keyword">int</span>  count;</span><br><span class="line">&#125;  LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。</p><h4 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为新的栈顶元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Push</span><span class="params">(LinkStack  *S,  SElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr  s  =  (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">s-&gt;data  =  e;</span><br><span class="line"><span class="comment">/*  把当前的栈顶元素赋值给新结点的直接后继*/</span></span><br><span class="line">s-&gt;next  =  S-&gt;top;        </span><br><span class="line"><span class="comment">/*  将新的结点s赋值给栈顶指针*/</span></span><br><span class="line">S-&gt;top  =  s;                    </span><br><span class="line">S-&gt;count++;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">Pop</span><span class="params">(LinkStack  *S,  SElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr  p;</span><br><span class="line"><span class="keyword">if</span>  (StackEmpty(*S))<span class="keyword">return</span>  ERROR;</span><br><span class="line">*e  =  S-&gt;top-&gt;data;<span class="comment">/*  将栈顶结点赋值给p*/</span></span><br><span class="line">p  =  S-&gt;top;                              </span><br><span class="line"><span class="comment">/*  使得栈顶指针下移一位*/</span></span><br><span class="line">S-&gt;top  =  S-&gt;top-&gt;next;        </span><br><span class="line"><span class="comment">/*  释放结点p  */</span></span><br><span class="line"><span class="built_in">free</span>(p);                                    </span><br><span class="line">S-&gt;count--;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。<br>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。<br>所以它们的区别和线性表中讨论的一样，如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p><h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p><h3 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h3><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p><p>迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。<br>递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。<br>迭代则不需要反复调用函数和占用额外的内存。<br>因此我们应该视不同情况选择不同的代码实现方式。</p><p>那么我们讲了这么多递归的内容，和栈有什么关系呢？这得从计算机系统的内部说起。</p><p>前面我们已经看到递归是如何执行它的前行和退回阶段的。<br>递归过程退回的顺序是它前行顺序的逆序。<br>在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。<br>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。<br>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。<br>在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。<br>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p><h3 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h3><h4 id="后缀（逆波兰）表示法定义"><a href="#后缀（逆波兰）表示法定义" class="headerlink" title="后缀（逆波兰）表示法定义"></a>后缀（逆波兰）表示法定义</h4><p>如果让你用C语言或其他高级语言实现对数学表达式的求值，你打算如何做？</p><p>这里面的困难就在于乘除在加减的后面，却要先运算，而加入了括号后，就变得更加复杂。不知道该如何处理。</p><p>但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。<br>这用栈结构正好合适，只要碰到左括号，就将此左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈。</p><p>但对于四则运算，括号也只是当中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？我们伟大的科学家想到了好办法。</p><ul><li>后缀（逆波兰）表示法定义</li></ul><p>对于“9+(3-1)×3+10÷2”，如果要用后缀表示法应该是什么样子：“9 3 1-3*+102/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。显然，这里没有了括号。</p><h4 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h4><p>9+(3-1)×3+10÷2<br>后缀表达式：9 3 1-3*+10 2/+<br>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。<br>1．初始化一个空栈。此栈用来对要运算的数字进出使用。<br>2．后缀表达式中前三个都是数字，所以9、3、1进栈。<br><img src="/img/CSDataStructure/23.jpg"><br>3．接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈。<br>4．接着是数字3进栈。<br><img src="/img/CSDataStructure/24.jpg"><br>5．后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。<br>6．下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈。<br><img src="/img/CSDataStructure/25.jpg"><br>7．接着是10与2两数字进栈。<br>8．接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。<br><img src="/img/CSDataStructure/26.jpg"><br>9．最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈。<br>10．结果是20出栈，栈变为空。</p><h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p>我们把平时所用的标准四则运算表达式，即“9+(3-1)×3+10÷2”叫做中缀表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化。<br>中缀表达式“9+(3-1)×3+10÷2”转化为后缀表达式“9 3 1-3*+10 2/+”。</p><p>规则：<br>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；<br>若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><p>1．初始化一空栈，用来对符号进出栈使用。<br>2．第一个字符是数字9，输出9，后面是符号“+”，进栈。<br><img src="/img/CSDataStructure/27.jpg"><br>3．第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈。<br>4．第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈。<br><img src="/img/CSDataStructure/28.jpg"><br>5．接下来是数字1，输出，总表达式为 9 31，后面是符号“)”，此时，我们需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 9 3 1-。<br>6．紧接着是符号“×”，因为此时的栈顶符号为“+”号，优先级低于“×”，因此不输出，“*”进栈。接着是数字3，输出，总的表达式为 9 3 1-3。<br><img src="/img/CSDataStructure/29.jpg"><br>7．之后是符号“+”，此时当前栈顶元素“ * ”比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为9 3 1-3 *+。然后将当前这个符号“+”进栈。也就是说，前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而图4-9-9左图中的栈底（也是栈顶）的“+”是指“9+(3-1)×3+”中的最后一个“+”。<br>8．紧接着数字10，输出，总表达式变为9 31-3 *+10。后是符号“÷”，所以“/”进栈。<br><img src="/img/CSDataStructure/30.jpg"><br>9．最后一个数字2，输出，总的表达式为9 31-3+10 2。<br>10．因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为93 1-3+10 2/+。<br><img src="/img/CSDataStructure/31.jpg"><br>从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步： 1.将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。 2.将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p><p>ADT  队列(Queue)<br>    Data    同线性表。<br>        元素具有相同的类型，相邻元素具有前驱和后继关系。<br>    Operation<br>        InitQueue(*Q):        初始化操作，建立一个空队列Q。<br>        DestroyQueue(*Q):  若队列Q存在，则销毁它。<br>        ClearQueue(*Q):      将队列Q清空。<br>        QueueEmpty(Q):        若队列Q为空，返回true，否则返回false。<br>        GetHead(Q,  *e):      若队列Q存在且非空，用e返回队列Q的队头元素。<br>        EnQueue(*Q,  e):      若队列Q存在，插入新元素e到队列Q中并成为队尾元素。<br>        DeQueue(*Q,  *e):    删除队列Q中队头元素，并用e返回其值。<br>        QueueLength(Q):      返回队列Q的元素个数<br>endADT</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p><h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)。</p><h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p><p>通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。</p><p>循环队列的顺序存储结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  QElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  QElemType;        </span><br><span class="line"><span class="comment">/*  循环队列的顺序存储结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType  data[MAXSIZE];</span><br><span class="line"><span class="comment">/*  头指针  */</span></span><br><span class="line"><span class="keyword">int</span>  front;                        </span><br><span class="line"><span class="comment">/*  尾指针，若队列不空，指向队列尾元素的下一个位置  */</span></span><br><span class="line"><span class="keyword">int</span>  rear;                          </span><br><span class="line">&#125;  SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列的初始化代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  初始化一个空队列Q  */</span></span><br><span class="line"><span class="function">Status  <span class="title">InitQueue</span><span class="params">(SqQueue  *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front  =  <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear  =  <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列求队列长度代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  返回Q的元素个数，也就是队列的当前长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">QueueLength</span><span class="params">(SqQueue  Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  (Q.rear  -  Q.front  +  MAXSIZE)  %  MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的入队列操作代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列未满，则插入元素e为Q新的队尾元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">EnQueue</span><span class="params">(SqQueue  *Q,  QElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  队列满的判断  */</span></span><br><span class="line"><span class="keyword">if</span>  ((Q-&gt;rear  +  <span class="number">1</span>)  %  MAXSIZE  ==  Q-&gt;front)        <span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  将元素e赋值给队尾  */</span></span><br><span class="line">Q-&gt;data[Q-&gt;rear]  =  e;                     </span><br><span class="line"><span class="comment">/*  rear指针向后移一位置，  */</span></span><br><span class="line">Q-&gt;rear  =  (Q-&gt;rear  +  <span class="number">1</span>)  %  MAXSIZE;    <span class="comment">/*  若到最后则转到数组头部  */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的出队列操作代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列不空，则删除Q中队头元素，用e返回其值  */</span></span><br><span class="line"><span class="function">Status  <span class="title">DeQueue</span><span class="params">(SqQueue  *Q,  QElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  队列空的判断  */</span></span><br><span class="line"><span class="keyword">if</span>  (Q-&gt;front  ==  Q-&gt;rear)                 <span class="keyword">return</span>  ERROR;</span><br><span class="line"><span class="comment">/*  将队头元素赋值给e  */</span></span><br><span class="line">*e  =  Q-&gt;data[Q-&gt;front];                   </span><br><span class="line"><span class="comment">/*  front指针向后移一位置，  */</span></span><br><span class="line">Q-&gt;front  =  (Q-&gt;front  +  <span class="number">1</span>)  %  MAXSIZE;  </span><br><span class="line"><span class="comment">/*  若到最后则转到数组头部  */</span></span><br><span class="line"><span class="keyword">return</span>    OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p><p>链队列的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  QElemType类型根据实际情况而定，这里假设为int  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  QElemType;</span><br><span class="line">              </span><br><span class="line"><span class="comment">/*  结点结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">QNode</span>                  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">QNode</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;  QNode,  *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  队列的链表结构  */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>                             </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*  队头、队尾指针  */</span></span><br><span class="line">QueuePtr  front,  rear;        </span><br><span class="line">&#125;  LinkQueue;</span><br></pre></td></tr></table></figure><p>队列的链式存储结构——入队操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  插入元素e为Q的新的队尾元素  */</span></span><br><span class="line"><span class="function">Status  <span class="title">EnQueue</span><span class="params">(LinkQueue  *Q,  QElemType  e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr  s  =  (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="comment">/*  存储分配失败  */</span></span><br><span class="line"><span class="keyword">if</span>  (!s)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">s-&gt;data  =  e;</span><br><span class="line">s-&gt;next  =  <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  把拥有元素e新结点s赋值给原队尾结点的后继,*/</span></span><br><span class="line">Q-&gt;rear-&gt;next  =  s;       </span><br><span class="line"><span class="comment">/*  把当前的s设置为队尾结点，rear指向s,*/</span></span><br><span class="line">Q-&gt;rear  =  s;                    </span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的链式存储结构——出队操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR  */</span></span><br><span class="line"><span class="function">Status  <span class="title">DeQueue</span><span class="params">(LinkQueue  *Q,  QElemType  *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr  p;</span><br><span class="line"><span class="keyword">if</span>  (Q-&gt;front  ==  Q-&gt;rear)<span class="keyword">return</span>  ERROR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将欲删除的队头结点暂存给p*/</span>p  =  Q-&gt;front-&gt;next;                   </span><br><span class="line"><span class="comment">/*  将欲删除的队头结点的值赋值给e  */</span></span><br><span class="line">*e  =  p-&gt;data;                             </span><br><span class="line"><span class="comment">/*  将原队头结点后继p-&gt;next赋值给头结点后继，  */</span></span><br><span class="line">Q-&gt;front-&gt;next  =  p-&gt;next;        </span><br><span class="line"><span class="comment">/*  若队头是队尾，则删除后将rear指向头结点*/</span></span><br><span class="line"><span class="keyword">if</span>  (Q-&gt;rear  ==  p)Q-&gt;rear  =  Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。<br>对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。<br>而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p><h2 id="总结回顾-1"><a href="#总结回顾-1" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>我们这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。<br>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-数据结构绪论&quot;&gt;&lt;a href=&quot;#Chapter-1-数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1 数据结构绪论&quot;&gt;&lt;/a&gt;Chapter 1 数据结构绪论&lt;/h1&gt;&lt;p&gt;数据结构：是相互之间存在一种</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《大话数据结构》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    <category term="线性表" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《C#图解教程》</title>
    <link href="https://afoolzwt.github.io/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://afoolzwt.github.io/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-30T16:00:00.000Z</published>
    <updated>2022-05-14T08:07:54.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter6-方法"><a href="#Chapter6-方法" class="headerlink" title="Chapter6 方法"></a>Chapter6 方法</h1><h2 id="Var关键字"><a href="#Var关键字" class="headerlink" title="Var关键字"></a>Var关键字</h2><p>Var关键字并不是表示特殊变量。它只是句法上的速记，表示任何可以从初始化语句的右边推断出的类型。<br>使用Var关键字有一些重要的条件：</p><ul><li>只能用于局部变量，不能用于字段；</li><li>只能在变量声明中包含初始化时使用；</li><li>一旦编辑器推断出变量的类型，它就是固定且不能更改的。<h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2>从C#7.0开始，可以在一个方法中声明另一个单独的方法。这样可以将嵌入的方法跟其他的代码隔离开来，所以它只能在包含它的方法内调用。<br>与局部变量必须在使用之前进行声明不同，你可以在包含方法的任意位置声明局部函数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">TestLocalFunc</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="built_in">int</span> <span class="title">LocalFunc</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> index * index;</span><br><span class="line">                &#125;</span><br><span class="line">i</span><br><span class="line">                <span class="built_in">int</span> results = LocalFunc(index);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>or<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">TestLocalFunc</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> results = LocalFunc(index);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">LocalFunc</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index * index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref局部变量"><a href="#ref局部变量" class="headerlink" title="ref局部变量"></a>ref局部变量</h2></li><li>你可以使用这个功能创建一个变量的别名，即使引用的对象是值类型。</li><li>对任意一个变量的赋值都会反映到另一个变量上，因为他们引用的是相同的对象，即使是值类型。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">ref</span> <span class="built_in">int</span> y = <span class="keyword">ref</span> x;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x=<span class="subst">&#123;x&#125;</span>,y=<span class="subst">&#123;y&#125;</span>&quot;</span>);</span><br><span class="line">            x = <span class="number">666</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x=<span class="subst">&#123;x&#125;</span>,y=<span class="subst">&#123;y&#125;</span>&quot;</span>);</span><br><span class="line">            y = <span class="number">888</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x=<span class="subst">&#123;x&#125;</span>,y=<span class="subst">&#123;y&#125;</span>&quot;</span>);</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">1</span></span><br><span class="line">x=<span class="number">666</span>,y=<span class="number">666</span></span><br><span class="line">x=<span class="number">888</span>,y=<span class="number">888</span></span><br></pre></td></tr></table></figure><h2 id="ref返回"><a href="#ref返回" class="headerlink" title="ref返回"></a>ref返回</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">int</span> Score = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">RefToValue</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">ref</span> Score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Value inside class object:<span class="subst">&#123;Score&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            test.Display();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ref</span> <span class="built_in">int</span> VOutSide = <span class="keyword">ref</span> test.RefToValue();</span><br><span class="line">            VOutSide = <span class="number">10</span>;</span><br><span class="line">            test.Display();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Value inside <span class="keyword">class</span> <span class="title">object</span>:5</span><br><span class="line"><span class="title">Value</span> <span class="title">inside</span> <span class="keyword">class</span> <span class="title">object</span>:10</span><br></pre></td></tr></table></figure><h2 id="递归图解"><a href="#递归图解" class="headerlink" title="递归图解"></a>递归图解</h2><img src="/img/CSharpLearn/1.png"><h1 id="Chapter7-深入理解类"><a href="#Chapter7-深入理解类" class="headerlink" title="Chapter7 深入理解类"></a>Chapter7 深入理解类</h1><h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2>实例构造函数初始化类的每个新实例，而static构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。<br>不能从程序中显式调用静态构造函数，系统会自动调用他们。</li><li>在类的任何实例被创建之前。</li><li>在类的任何静态成员被引用之前。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Normal Construct&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Static Construct&quot;</span>);</span><br><span class="line">                index = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Test.index);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Static Construct</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="对象初始化语句"><a href="#对象初始化语句" class="headerlink" title="对象初始化语句"></a>对象初始化语句</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> y = <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="number">3</span>;</span><br><span class="line">                y = <span class="number">4</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Construct Finish&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test(<span class="number">7</span>,<span class="number">8</span>)&#123;x =<span class="number">5</span>,y=<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Test x=<span class="subst">&#123;test.x&#125;</span> y=<span class="subst">&#123;test.y&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Construct Finish</span><br><span class="line">Test x=<span class="number">5</span> y=<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">string</span> oneStr;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">string</span> twoStr;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">string</span> threeStr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]<span class="comment">//索引器声明</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">set</span><span class="comment">//set访问器声明</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (index)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            oneStr = <span class="keyword">value</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            twoStr = <span class="keyword">value</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                            threeStr = <span class="keyword">value</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (index)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            <span class="keyword">return</span> oneStr;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            <span class="keyword">return</span> twoStr;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                            <span class="keyword">return</span> threeStr;</span><br><span class="line"></span><br><span class="line">                        <span class="literal">default</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            test[<span class="number">1</span>] = <span class="string">&quot;oneStroneStr&quot;</span>;</span><br><span class="line">            test[<span class="number">2</span>] = <span class="string">&quot;twoStrtwoStr&quot;</span>;</span><br><span class="line">            test[<span class="number">3</span>] = <span class="string">&quot;threeStrthreeStr&quot;</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;1=<span class="subst">&#123;test[<span class="number">1</span>]&#125;</span> 2=<span class="subst">&#123;test[<span class="number">2</span>]&#125;</span> 3=<span class="subst">&#123;test[<span class="number">3</span>]&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">1</span>=oneStroneStr <span class="number">2</span>=twoStrtwoStr <span class="number">3</span>=threeStrthreeStr</span><br></pre></td></tr></table></figure></li></ul><h1 id="Chapter8-使用基类的引用"><a href="#Chapter8-使用基类的引用" class="headerlink" title="Chapter8 使用基类的引用"></a>Chapter8 使用基类的引用</h1><h2 id="虚方法和覆写方法"><a href="#虚方法和覆写方法" class="headerlink" title="虚方法和覆写方法"></a>虚方法和覆写方法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseTest</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;IM BaseTest&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title">MyTest</span> : <span class="title">BaseTest</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;IM MyTest&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyTest myTest = <span class="keyword">new</span> MyTest();</span><br><span class="line">            myTest.Print();</span><br><span class="line"></span><br><span class="line">            BaseTest baseTest = <span class="keyword">new</span> BaseTest();</span><br><span class="line">            baseTest.Print();</span><br><span class="line"></span><br><span class="line">            BaseTest Back2Base = (BaseTest)myTest;</span><br><span class="line">            Back2Base.Print();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">IM MyTest</span><br><span class="line">IM BaseTest</span><br><span class="line">IM MyTest</span><br></pre></td></tr></table></figure><h1 id="Chapter10-语句"><a href="#Chapter10-语句" class="headerlink" title="Chapter10 语句"></a>Chapter10 语句</h1><h2 id="C-托管对象和非托管对象"><a href="#C-托管对象和非托管对象" class="headerlink" title="C#托管对象和非托管对象"></a>C#托管对象和非托管对象</h2><p>托管对象指的是.net可以自动进行回收的资源，主要是指托管对象在堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，有.net运行库在合适的时间进行回收。（手动回收GC.Collect）</p><p>非托管对象指.net不知道如何回收的资源，最常见的一类非托管资源是包装操作系统资源的对象，例如文件、窗口、网络连接、数据库连接、画刷、图标等。这类资源，垃圾回收器在清理的时候会调用Object.Finalize()方法。默认情况下，方法是空的，对于非托管对象在此方法中需要编写回收非托管对象的代码，以便垃圾回收器正确回收。(例如我们通常打开文件、图片等后需要进行Close()或者Dispose()去释放)。</p><p>本来如果按照上面做法，非托管资源也能够由垃圾回收器进行回收，但是非托管资源一般是有限的，比较宝贵的，而垃圾回收器是由CRL自动调用的，这样就无法保证及时的释放掉非托管资源，因此定义了一个Dispose()方法，让使用者能够手动的释放非托管资源。Dispose()方法释放类的托管资源和非托管资源，使用者手动调用此方法后，垃圾回收器不会对此类实例再次进行回收。Dispose()方法是由使用者调用的，在调用时，类的托管资源和非托管资源肯定都未被回收，所以可以同时回收两种资源。</p><p>Microsoft为非托管资源的回收专门定义了一个接口：IDisposable，接口中只包含一个Dispose()方法。任何包含非托管资源的类，都应该继承此接口。</p><p>在一个包含非托管资源的类中，关于资源释放的标准做法是：<br>(1)继承IDisposable()接口；<br>(2)实现Dispose()方法，在其中释放托管资源和非托管资源，并将对象本身从垃圾回收器中移除（垃圾回收器不在回收此资源）；<br>(3)实现类析构函数，在其中释放非托管资源。<br>这样做的目的是为了更好的提高程序性能，避免内存泄漏，小数据量往往体现不出来，当数据量庞大时就会出现内存不足以及System.OutOfMemoryException:“Exception_WasThrown”的错误。</p><h1 id="Chapter13-数组"><a href="#Chapter13-数组" class="headerlink" title="Chapter13 数组"></a>Chapter13 数组</h1><p>int[]      一维数组<br>int[,]      二维数组<br>int[][]  交错数组 </p><h1 id="Chapter15-事件"><a href="#Chapter15-事件" class="headerlink" title="Chapter15 事件"></a>Chapter15 事件</h1><h2 id="事件访问器"><a href="#事件访问器" class="headerlink" title="事件访问器"></a>事件访问器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CustomEvent myEventHandler;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> CustomEvent MyEventHandler</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    myEventHandler += <span class="keyword">value</span>;</span><br><span class="line">                    myEventHandler += <span class="keyword">value</span>;</span><br><span class="line">                    myEventHandler += <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//执行+=运算符代码</span></span><br><span class="line">            <span class="keyword">remove</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    myEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">                    myEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//执行-=运算符代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireAEvent</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myEventHandler != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                myEventHandler();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            TestEvent testEvent = <span class="keyword">new</span> TestEvent();</span><br><span class="line">            testEvent.FireAEvent();</span><br><span class="line"></span><br><span class="line">            testEvent.MyEventHandler += Print;</span><br><span class="line">            testEvent.MyEventHandler -= Print;</span><br><span class="line">            testEvent.FireAEvent();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Invoke Print&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Invoke Print</span><br></pre></td></tr></table></figure><h1 id="Chapter19-枚举器和迭代器"><a href="#Chapter19-枚举器和迭代器" class="headerlink" title="Chapter19 枚举器和迭代器"></a>Chapter19 枚举器和迭代器</h1><h2 id="IEnumerator-枚举器"><a href="#IEnumerator-枚举器" class="headerlink" title="IEnumerator 枚举器"></a>IEnumerator 枚举器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">string</span>[] colors;</span><br><span class="line">     <span class="built_in">int</span> position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ColorEnumerator</span>(<span class="params"><span class="built_in">string</span>[] theColors</span>)<span class="comment">//构造函数</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         colors = <span class="keyword">new</span> <span class="built_in">string</span>[theColors.Length];</span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; theColors.Length; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             colors[i] = theColors[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">object</span> Current<span class="comment">//实现Current</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">get</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (position == <span class="number">-1</span> || position &gt;= colors.Length)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> colors[position];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)<span class="comment">//实现MoveNext</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (position &lt; colors.Length - <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             position++;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)<span class="comment">//实现Reset</span></span></span><br><span class="line">     &#123;</span><br><span class="line">         position = <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerable-可枚举类型"><a href="#IEnumerable-可枚举类型" class="headerlink" title="IEnumerable 可枚举类型"></a>IEnumerable 可枚举类型</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors = &#123;<span class="string">&quot;violet&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;cyan&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;red&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(Colors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter20-LINQ"><a href="#Chapter20-LINQ" class="headerlink" title="Chapter20 LINQ"></a>Chapter20 LINQ</h1><h2 id="查询语法-方法语法"><a href="#查询语法-方法语法" class="headerlink" title="查询语法 方法语法"></a>查询语法 方法语法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numsQuery = <span class="keyword">from</span> n <span class="keyword">in</span> numbers<span class="comment">//查询语法</span></span><br><span class="line">                <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                <span class="keyword">select</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numsMethod = numbers.Where(N =&gt; N &lt; <span class="number">20</span>);<span class="comment">//方法语法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> numsCount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">                 <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                 <span class="keyword">select</span> n).Count();<span class="comment">//两种形式的组合</span></span><br></pre></td></tr></table></figure><h1 id="Chapter21-异步编程"><a href="#Chapter21-异步编程" class="headerlink" title="Chapter21 异步编程"></a>Chapter21 异步编程</h1><h2 id="同步编程与异步编程示例"><a href="#同步编程与异步编程示例" class="headerlink" title="同步编程与异步编程示例"></a>同步编程与异步编程示例</h2><p>同步编程</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">            sw.Start();</span><br><span class="line">            <span class="built_in">int</span> t1 = CountCharacters(<span class="number">1</span>, <span class="string">&quot;http://www.microsoft.com&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> t2 = CountCharacters(<span class="number">2</span>, <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span>);</span><br><span class="line">            CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">            CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CountCharacters</span>(<span class="params"><span class="built_in">int</span> id,<span class="built_in">string</span> urlString</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting Call &#123;0&#125;  :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">            <span class="built_in">string</span> result = wc1.DownloadString(<span class="keyword">new</span> Uri(urlString));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Call &#123;0&#125; completed :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;result length ==&gt; &#123;0&#125;&quot;</span>, result.Length);</span><br><span class="line">            <span class="keyword">return</span> result.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="built_in">int</span> id,<span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++) ;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;End counting &#123;0&#125; :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">            ds.DoRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Starting Call <span class="number">1</span>  :  <span class="number">20.9274</span>ms</span><br><span class="line">Call <span class="number">1</span> completed :  <span class="number">3625.7335</span>ms</span><br><span class="line">result length ==&gt; <span class="number">180832</span></span><br><span class="line">Starting Call <span class="number">2</span>  :  <span class="number">3626.6481</span>ms</span><br><span class="line">Call <span class="number">2</span> completed :  <span class="number">4128.4041</span>ms</span><br><span class="line">result length ==&gt; <span class="number">5164</span></span><br><span class="line">End counting <span class="number">1</span> :  <span class="number">4153.6904</span>ms</span><br><span class="line">End counting <span class="number">2</span> :  <span class="number">4177.9644</span>ms</span><br></pre></td></tr></table></figure><p>异步编程</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">            ds.DoRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">   <span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">            sw.Start();</span><br><span class="line">            Task&lt;<span class="built_in">int</span>&gt; t1 = CountCharactersAsync(<span class="number">1</span>, <span class="string">&quot;http://www.microsoft.com&quot;</span>);</span><br><span class="line">            Task&lt;<span class="built_in">int</span>&gt; t2 = CountCharactersAsync(<span class="number">2</span>, <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span>);</span><br><span class="line">            CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">            CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Chars in http://www.microsoft.com:  &#123;0&#125;&quot;</span>,t1.Result);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Chars in http://www.illustratedcsharp.com:  &#123;0&#125;&quot;</span>, t2.Result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"><span class="built_in">int</span> id,<span class="built_in">string</span> urlString</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting Call &#123;0&#125;  :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">            <span class="built_in">string</span> result = <span class="keyword">await</span> wc1.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(urlString));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Call &#123;0&#125; completed :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">            <span class="keyword">return</span> result.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="built_in">int</span> id,<span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++) ;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;End counting &#123;0&#125; :  &#123;1&#125;ms&quot;</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Starting Call <span class="number">1</span>  :  <span class="number">74.7954</span>ms</span><br><span class="line">Starting Call <span class="number">2</span>  :  <span class="number">771.2391</span>ms</span><br><span class="line">End counting <span class="number">1</span> :  <span class="number">791.301</span>ms</span><br><span class="line">End counting <span class="number">2</span> :  <span class="number">804.6226</span>ms</span><br><span class="line">Call <span class="number">1</span> completed :  <span class="number">1250.2072</span>ms</span><br><span class="line">Chars <span class="keyword">in</span> http:<span class="comment">//www.microsoft.com:  180852</span></span><br><span class="line">Call <span class="number">2</span> completed :  <span class="number">1615.1967</span>ms</span><br><span class="line">Chars <span class="keyword">in</span> http:<span class="comment">//www.illustratedcsharp.com:  5164</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter6-方法&quot;&gt;&lt;a href=&quot;#Chapter6-方法&quot; class=&quot;headerlink&quot; title=&quot;Chapter6 方法&quot;&gt;&lt;/a&gt;Chapter6 方法&lt;/h1&gt;&lt;h2 id=&quot;Var关键字&quot;&gt;&lt;a href=&quot;#Var关键字&quot; cla</summary>
      
    
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
    <category term="《C#图解教程》" scheme="https://afoolzwt.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8AC-%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E3%80%8B/"/>
    
    
    <category term="学习读物" scheme="https://afoolzwt.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《沉默的病人》</title>
    <link href="https://afoolzwt.github.io/2022/04/11/%E6%B2%89%E9%BB%98%E7%9A%84%E7%97%85%E4%BA%BA/"/>
    <id>https://afoolzwt.github.io/2022/04/11/%E6%B2%89%E9%BB%98%E7%9A%84%E7%97%85%E4%BA%BA/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-11T12:30:49.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>  最近读到的书感觉都很奇怪，不知道是作者的意思还是发行商的意愿，每本书都被营销的特别厉害。我个人觉得封面上的“多少看似完美的夫妻，都在等待杀死对方的契机”，和本书真的一点关系都没有，甚至用在《鳄鱼的黄眼睛》上都会契合一些。我是以一本心理小说向的预期来读这本书的，没想到最后硬生生的变成了悬疑小说。但悬疑的部分埋的太浅，故事内容人物极度不饱和，以至于使这本书的反转变得稍显逊色。不过也有不少有意思的点子，现实与神话故事结合的地方，以及打在天花板上的那一枪，都是不错的构思。但我不苟同于作者的观点——“儿童时期所留下的创伤，会在成年之后带来无休止的影响”。对一些人来说（比如说我），童年时的创伤更能让你理解他人的苦楚，原谅他人也是放过自己。因为你经历过那样的境遇，所以你会想办法避免同样的情况发生在他人身上。因为这个，我变成了一个同理心特别夸张的人（也就是圣母婊），我常常会与小动物或者植物共情，认为人类的存在是错误的（也许本来就是）。这点谈不上好，也说不上坏，虽然我常常因为“拥有了怜悯众生的能力，却没有解救众生的能力”而感到痛苦，但我也会努力践行“达，则兼济天下”的属于我的道。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li>未得到表达的情感是永远不会消亡的。它们虽然被活埋，今后必将以更加丑陋的方式出现。 ——西格蒙德.弗洛伊德</li><li>不是受虐者的人是不可能成为施虐者的。谁也不是天生的坏人。 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读后感&quot;&gt;&lt;a href=&quot;#读后感&quot; class=&quot;headerlink&quot; title=&quot;读后感&quot;&gt;&lt;/a&gt;读后感&lt;/h1&gt;&lt;p&gt;  最近读到的书感觉都很奇怪，不知道是作者的意思还是发行商的意愿，每本书都被营销的特别厉害。我个人觉得封面上的“多少看似完美的夫妻，</summary>
      
    
    
    
    <category term="阅读" scheme="https://afoolzwt.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    <category term="《沉默的病人》" scheme="https://afoolzwt.github.io/categories/%E9%98%85%E8%AF%BB/%E3%80%8A%E6%B2%89%E9%BB%98%E7%9A%84%E7%97%85%E4%BA%BA%E3%80%8B/"/>
    
    
    <category term="阅读" scheme="https://afoolzwt.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《鳄鱼的黄眼睛》</title>
    <link href="https://afoolzwt.github.io/2022/04/06/%E9%B3%84%E9%B1%BC%E7%9A%84%E9%BB%84%E7%9C%BC%E7%9D%9B/"/>
    <id>https://afoolzwt.github.io/2022/04/06/%E9%B3%84%E9%B1%BC%E7%9A%84%E9%BB%84%E7%9C%BC%E7%9D%9B/</id>
    <published>2022-04-05T16:00:00.000Z</published>
    <updated>2022-04-06T16:06:35.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>  作为一本备受好评的书而言，我觉得《鳄鱼的黄眼睛》所讲述的故事未免有一点枯燥或无趣了，在故事的中部你就能很容易的猜到故事的走向和结局，这无疑是它不太好的点。但作者巧妙的话语和看似随手的描述，却把故事中的主角们或者说是女人们描述的立体形象。有别于人们印象中浪漫的法国，本书更能让你体验到一个真实且普通的法国生活。虽说本书讲的是女性的独立，可能因为我是男性，我更能理解的是个人的独立，而非被性别所界线。这话在热衷于鼓吹男女对立的今天可能挺危险的，但不只是女性有枷锁，男生身上也拥有着与生俱来的枷锁。但孰重孰轻，我不能给出答案，因为我不能换位的去思考，但我觉得人生来就是苦难的。本书的作者就很像过去的我所主观的，我是一个彻头彻尾的理想主义者，我希望所有的人都能忠于自己的理想，去成为自己，而不是别人。当时年少未经事，虽说在送外卖赚钱养活自己，但充其量也是一种体验生活。因为自身的家境还算不错，所以我身上的枷锁是比别人要少一些的。当我看到一起送外卖的好朋友，被生活束缚的寸步难行时，我迫切甚至过于热烈的希望他能去做自己想做的事情。我没有房贷，没有远在老家的年迈的父母，也没有需要依赖我的女友，可他有，他身上的锁链太重了，不知道我说过的话能否让他能认识到自我，但现在我们关系也还不错。又想到今天，和前同事特别好的QA同学交流的时候，感觉自己最近越来越焦虑和不快来了，也不知道为什么。虽然我有感觉到自己在成熟，但也感觉到自己身上的枷锁越来越重了，好多的压力都是自己给自己的。我不知道成长究竟是心甘情愿的戴上枷锁，还是不顾一切的取下枷锁，但我决定正视自己，像书中说的一样，在经历否定和伤害之后，真正的直面自己，直面你的缺陷和美丽，才能成为真正的自己，为自己而活。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li>“男人的普遍特点是什么？不就是无休止地和一些无聊的女人待在一起的能力。不是说待在一起而不厌烦，而是漠视自己的厌烦，只要他们还没厌烦到想逃走的地步。”</li><li>“不是因为事情太难让我们不敢尝试，而是因为我们不敢尝试而让事情变得困难。”</li><li>“当你们长大了，就会明白人生并不是想怎样就能怎样的。有时候，不是你决定生活，而是你忍受生活。” </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读后感&quot;&gt;&lt;a href=&quot;#读后感&quot; class=&quot;headerlink&quot; title=&quot;读后感&quot;&gt;&lt;/a&gt;读后感&lt;/h1&gt;&lt;p&gt;  作为一本备受好评的书而言，我觉得《鳄鱼的黄眼睛》所讲述的故事未免有一点枯燥或无趣了，在故事的中部你就能很容易的猜到故事的走向和结</summary>
      
    
    
    
    <category term="阅读" scheme="https://afoolzwt.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    <category term="《鳄鱼的黄眼睛》" scheme="https://afoolzwt.github.io/categories/%E9%98%85%E8%AF%BB/%E3%80%8A%E9%B3%84%E9%B1%BC%E7%9A%84%E9%BB%84%E7%9C%BC%E7%9D%9B%E3%80%8B/"/>
    
    
    <category term="阅读" scheme="https://afoolzwt.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSharp算法</title>
    <link href="https://afoolzwt.github.io/2022/03/11/CSharp%E7%AE%97%E6%B3%95/"/>
    <id>https://afoolzwt.github.io/2022/03/11/CSharp%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-05-14T08:24:04.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 7.整数反转</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 如果反转后整数超过 32 位的有符号整数的范围[?231, 231 ? 1] ，就返回 0。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> t = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="built_in">int</span>.MaxValue / <span class="number">10</span> || (res == <span class="built_in">int</span>.MaxValue / <span class="number">10</span> &amp;&amp; t &gt; <span class="number">7</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="built_in">int</span>.MinValue / <span class="number">10</span> || (res == <span class="built_in">int</span>.MinValue / <span class="number">10</span> &amp;&amp; t &lt; <span class="number">-8</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">int</span>&gt; Pukes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitPukes</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pukes = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">54</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">54</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pukes.Add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***装牌完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Pukes.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Pukes[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fisher-Yates算法"><a href="#Fisher-Yates算法" class="headerlink" title="Fisher_Yates算法"></a>Fisher_Yates算法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> Fisher_Yates算法</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 取两个列表，一个是洗牌前的序列A&#123;1,2….54&#125;，一个用来放洗牌后的序列B，B初始为空</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> while A不为空,随机从A取一张牌加入B末尾</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 空间O（n），时间O（n^2)</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fisher_Yates</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Random r = <span class="keyword">new</span> Random();</span><br><span class="line">          List&lt;<span class="built_in">int</span>&gt; newPuckes = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(Pukes.Count);</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">54</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//Random.Range(minValue,maxValue) [minValue,maxValue)</span></span><br><span class="line">              <span class="built_in">int</span> randomIndex = r.Next(<span class="number">0</span>, Pukes.Count);</span><br><span class="line">              <span class="built_in">int</span> puke = Pukes[randomIndex];</span><br><span class="line">              newPuckes.Add(puke);</span><br><span class="line">              Pukes.RemoveAt(randomIndex);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;***洗牌完毕***&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; newPuckes.Count; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              Console.WriteLine(newPuckes[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="Knuth-Durstenfeld算法"><a href="#Knuth-Durstenfeld算法" class="headerlink" title="Knuth_Durstenfeld算法"></a>Knuth_Durstenfeld算法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Knuth_Durstenfeld算法 是最佳的洗牌算法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部， 即数组尾部存放的是已经处理过的数字。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这是一个原地打乱顺序的算法，算法时间复杂度也从Fisher算法的 O ( n 2 )提升到了 O ( n )</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Knuth_Durstenfeld</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = Pukes.Count - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> randomIndex = r.Next(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> bottom = Pukes[i];</span><br><span class="line">        Pukes[i] = Pukes[randomIndex];</span><br><span class="line">        Pukes[randomIndex] = bottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***洗牌完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Pukes.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Pukes[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">int</span>&gt; AfterLst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params">List&lt;<span class="built_in">int</span>&gt; data,<span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    data[x] = data[x] + data[y];</span><br><span class="line">    data[y] = data[x] - data[y];</span><br><span class="line">    data[x] = data[x] - data[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitAfterLst</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="built_in">int</span> range = r.Next(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">    AfterLst = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(range);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; range; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> randomIndex = r.Next(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">        AfterLst.Add(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***数组生成完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AfterLst.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(AfterLst[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 选择排序</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 原理：找出参与排序的数组最大值，放到末尾（或找到最小值放到开头）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 过程解析：将剩余数组的最小数交换到开头。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AfterLst.Count - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> min = i;</span><br><span class="line">        <span class="built_in">int</span> temp = AfterLst[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; AfterLst.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (AfterLst[j] &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">                temp = AfterLst[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            AfterLst[min] = AfterLst[i];</span><br><span class="line">            AfterLst[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***选择排序完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AfterLst.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(AfterLst[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 冒泡排序</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 原理：从头开始，每一个元素和它的下一个元素比较，如果它大，就将它与比较的元素交换，否则不动。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这意味着，大的元素总是在向后慢慢移动直到遇到比它更大的元素。所以每一轮交换完成都能将最大值冒到最后。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解析:需要注意的是j<span class="doctag">&lt;i，每轮冒完泡必然会将最大值排到数组末尾，所以需要排序的数应该是在减少的。</span></span></span><br><span class="line"><span class="doctag"><span class="comment">/// https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#.E5.8A.A9.E8.AE.B0.E7.A0.81</span></span></span><br><span class="line"><span class="doctag"><span class="comment">/// &lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = AfterLst.Count - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (AfterLst[j] &gt; AfterLst[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] + AfterLst[j];</span><br><span class="line">                AfterLst[j] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">                AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***冒泡排序完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AfterLst.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(AfterLst[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序（标识版）"><a href="#冒泡排序（标识版）" class="headerlink" title="冒泡排序（标识版）"></a>冒泡排序（标识版）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 冒泡排序（标识版）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解析：发现某轮冒泡没有任何数进行交换（即已经有序），就跳出排序。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSortWithFlag</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = AfterLst.Count - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (AfterLst[j] &gt; AfterLst[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] + AfterLst[j];</span><br><span class="line">                AfterLst[j] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">                AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;***冒泡排序(标识)完毕***&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AfterLst.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(AfterLst[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序（来回排序）"><a href="#鸡尾酒排序（来回排序）" class="headerlink" title="鸡尾酒排序（来回排序）"></a>鸡尾酒排序（来回排序）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 鸡尾酒排序（来回排序）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 冒泡排序只是单向冒泡，而鸡尾酒来回反复双向冒泡。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 原理：自左向右将大数冒到末尾，然后将剩余数列再自右向左将小数冒到开头，如此循环往复。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解析：分析第i轮冒泡，i是偶数则将剩余数列最大值向右冒泡至末尾，是奇数则将剩余数列最小值.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 向左冒泡至开头。对于剩余数列，n为始，AfterLst.Count-1-m为末。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleCocktailSort</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> flag;</span><br><span class="line">    <span class="built_in">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = AfterLst.Count - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = n; j &lt; AfterLst.Count - <span class="number">1</span> - m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (AfterLst[j] &gt; AfterLst[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] + AfterLst[j];</span><br><span class="line">                    AfterLst[j] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">                    AfterLst[j + <span class="number">1</span>] = AfterLst[j + <span class="number">1</span>] - AfterLst[j];</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = AfterLst.Count - <span class="number">1</span> - m; k &gt; n; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (AfterLst[k] &lt; AfterLst[k - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    AfterLst[k - <span class="number">1</span>] = AfterLst[k - <span class="number">1</span>] + AfterLst[k];</span><br><span class="line">                    AfterLst[k] = AfterLst[k - <span class="number">1</span>] - AfterLst[k];</span><br><span class="line">                    AfterLst[k - <span class="number">1</span>] = AfterLst[k - <span class="number">1</span>] - AfterLst[k];</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;LeetCode&lt;/h1&gt;&lt;h2 id=&quot;7-整数反转&quot;&gt;&lt;a href=&quot;#7-整数反转&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="C#" scheme="https://afoolzwt.github.io/categories/C/"/>
    
    <category term="C#算法" scheme="https://afoolzwt.github.io/categories/C/C-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C#" scheme="https://afoolzwt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity面试题汇总</title>
    <link href="https://afoolzwt.github.io/2022/03/11/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://afoolzwt.github.io/2022/03/11/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-11T06:35:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（BCWL）U3D程序员笔试题"><a href="#（BCWL）U3D程序员笔试题" class="headerlink" title="（BCWL）U3D程序员笔试题"></a>（BCWL）U3D程序员笔试题</h1><ul><li>1.请回答下述基础相关问题<br>a)    什么是泛型，泛型和传统类型的Boxing/Unboxing有什么区别，写一个泛型类C使其继承于Cbase;<br>什么是泛型：<br>泛型允许延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。<br>泛型和传统类型的Boxing/Unboxing有什么区别：<br>装箱：值类型转引用类型。开辟一块内存空间进行存放数据。<br>拆箱：引用类型转值类型。<br>泛型对装箱拆箱的影响在集合的应用上有巨大的体现，诸如用 ArrayList 来储存 int 数据和用 List<int> 来储存 int 数据。未使用泛型的 ArrayList 在每次存新数据时都会有从 int 到 object 的装箱操作，每次读取时都会有拆箱操作，而使用泛型的 List<int> 不需要这些操作，也就避免了这方面的性能消耗。<br>写一个泛型类C使其继承于Cbase：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CBase</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt; : <span class="title">CBase</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">CBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CTest</span> : <span class="title">CBase</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">    C&lt;CTest&gt; ctest = <span class="keyword">new</span> C&lt;CTest&gt;();</span><br><span class="line">    C1&lt;CTest&gt; ctest1 = <span class="keyword">new</span> C1&lt;CTest&gt;();</span><br></pre></td></tr></table></figure>b)    OnEnable、Awake、Start执行的先后顺序；<br>Awake &gt; OnEnable &gt; Start<br>c)    请简述反射的用途，写一段代码动态加载一个程序集，从该程序集获取类型T，从类型T获得名为Create的静态方法，调用该静态方法；<br>请简述反射的用途：<br>（1）使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。<br>（2）使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。<br>（3）使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。<br>（4）使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。<br>（5）使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。<br>（6）使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。<br>（7）使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。<br>（8）使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。<br>（9）当您在一个应用程序域的仅反射上下文中工作时，请使用 CustomAttributeData 来发现有关自定义特性的信息。 通过使用 CustomAttributeData，您不必创建特性的实例就可以检查它们。<br>写一段代码动态加载一个程序集，从该程序集获取类型T，从类型T获得名为Create的静态方法，调用该静态方法：<br>  在.Net 中，程序集（Assembly）中保存了元数据（MetaData）信息，因此就可以通过分析元数据来获取程序集中的内容，比如类，方法，属性等，这大大方便了在运行时去动态创建实例。反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。如果代码中使用了属性，可以利用反射对它们进行访问。<br>  主要用途：<br>  1.动态加载DLL，实现插件机制。<br>  2.实例化DLL中的类型。<br>  3.执行后期绑定，访问在运行时创建的类型的方法。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TEST</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Reflection</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsTest &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;reflection Create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogName</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestReflection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//DLL地址</span></span><br><span class="line">            <span class="built_in">string</span> dllStr = <span class="string">@&quot;C:\Users\mshz\source\repos\TEST\bin\Debug\netcoreapp3.1\TEST.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">            Assembly asm = Assembly.LoadFile(dllStr);</span><br><span class="line">            <span class="comment">//获取Reflection类的类型 需要完整的类名，包括命名空间</span></span><br><span class="line">            <span class="keyword">var</span> type = asm.GetType(<span class="string">&quot;TEST.Reflection&quot;</span>);</span><br><span class="line">            <span class="comment">//创建该类型的实例</span></span><br><span class="line">            <span class="keyword">var</span> instance = asm.CreateInstance(<span class="string">&quot;TEST.Reflection&quot;</span>);</span><br><span class="line">            <span class="comment">//设置属性</span></span><br><span class="line">            type.GetProperty(<span class="string">&quot;Name&quot;</span>).SetValue(instance, <span class="string">&quot;https://afoolzwt.github.io/&quot;</span>);</span><br><span class="line">            type.GetProperty(<span class="string">&quot;IsTest&quot;</span>).SetValue(instance, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//获取方法</span></span><br><span class="line">            <span class="keyword">var</span> method1 = type.GetMethod(<span class="string">&quot;LogName&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> method2 = type.GetMethod(<span class="string">&quot;Create&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用方法</span></span><br><span class="line">            method1.Invoke(instance, <span class="literal">null</span>);</span><br><span class="line">            method2.Invoke(instance, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">https:<span class="comment">//afoolzwt.github.io/</span></span><br><span class="line">reflection Create</span><br></pre></td></tr></table></figure></li><li>2.请回答下述资源相关的问题<br>a)    Prefab的作用，如何获取Prefab实例化出来的GameObject的预置类型，PrefabInstance,ModelPrefabInstance等预置类型有什么不同；<br>Prefab的作用：<br>预制体（Prefab）可以允许我们创建基于某个游戏对象的模板，通过这个模板我们可以非常方便快捷的反复创建具有相同结构的游戏对象。<br>如何获取Prefab实例化出来的GameObject的预置类型：<br>PrefabInstance,ModelPrefabInstance等预置类型有什么不同：<br>（已过期）<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/3.png"><br>b)    资源如何通过AssetBundle打包和加载；<br>略<br>c)    AssetDatabase.LoadAssetAtPath和Resource.Load分别适用于什么场合<br>略</li><li>3.请回答下述几何相关问题（10分）：<br>a)    正交摄像机和透视摄像机的区别，第一人称摄像机Fov变化会产生怎样的摄像机效果；<br>正交摄像机和透视摄像机的区别：<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/4.bmp"><br>透视摄像机Perspective：<br>有消失点投影，透视视图和我们从眼睛看到的视图是一样的。<br>正交摄像机Orthographic：<br>无消失点投影，正交视图无法看到一个物体是远离自己还是正在我们面前。<br>第一人称摄像机Fov变化会产生怎样的摄像机效果：<br>Fov可调节摄像机的视口效果，改变Fov的值会影响摄像机渲染的物体的大小。<br>b)    给定屏幕一个点(x,y)如何进行对场景中的GameObject进行射线拾取；<br>Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>c)    拖尾效果中的带子采用Bezier曲线/Catmull-rom曲线的差异；<br>略</li><li>4.请回答下述渲染相关的问题<br>a)    HDR中动态范围压缩和Tone Mapping原理；<br>b)    MeshRender和SkinnedMeshRender的关系与不同；<br>c)    写一段代码从上述Render获取材质并切换Shade，并获取该Shader中某uniform constant值，每帧修改该constant值产生uv动画实现装备上流动的流光效果<br>d)    法线贴图如何进行烘培(Bake);<br>（后续研究）</li></ul><hr><h1 id="Unity面试题汇总"><a href="#Unity面试题汇总" class="headerlink" title="Unity面试题汇总"></a>Unity面试题汇总</h1><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C#语言"></a>C#语言</h2><ul><li><ol><li>   重载和重写的区别</li></ol></li></ul><ol><li>   所处位置不同 重载在同类中 重写在父子类中</li><li>   定义方式不同 重载方法名相同 参数列表不同 重写方法名和参数列表都相同</li><li>   调用方式不同 重载使用相同对象以不同参数调用 重写用不同对象以相同参数调用</li><li>   多态时机不同 重载时编译时多态 重写是运行时多态</li></ol><ul><li><ol start="2"><li>   面向对象的三大特点<br>封装、继承、多态<br>1、封装： 封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。<br>2、继承： 提高代码重用度，增强软件可维护性的重要手段，符合开闭原则。<br>3、多态性： 多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段。    </li></ol></li><li><ol start="3"><li>   简述值类型和引用类型有什么区别</li></ol></li></ul><p>1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。<br>2.值类型存取快，引用类型存取慢。<br>3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。<br>4.栈的内存是自动释放的，堆内存是.NET 中会由 GC 来自动释放。<br>5.值类型继承自 System.ValueType,引用类型继承自 System.Object。</p><ul><li><ol start="4"><li>   请简述private，public，protected，internal的区别<br>private：仅对该类公开。<br>public：对任何类和成员都公开，无限制访问。<br>protected：对该类和其派生类公开。<br>internal：只能在包含该类的程序集中访问该类。</li></ol></li><li><ol start="5"><li>   C#中所有引用类型的基类是什么<br>引用类型的基类是 System.Object 值类型的基类是 System.ValueType<br>同时，值类型也隐式继承自 System.Object</li></ol></li><li><ol start="6"><li>   请简述 ArrayList 和 List<Int>的主要区别<br>ArrayList 不带泛型 数据类型丢失<br>List<T> 带泛型 数据类型不丢失<br>ArrayList需要装箱拆箱 List<T>不需要</li></ol></li><li><ol start="7"><li>   请简述 GC（垃圾回收）产生的原因，并描述如何避免？<br>GC 为了避免内存溢出而产生的回收机制<br>避免：<br>1）减少 new 产生对象的次数<br>2）使用公用的对象（静态成员）<br>3）将 String 换为 StringBuilder</li></ol></li><li><ol start="8"><li>   请描述 Interface 与抽象类之间的不同</li></ol></li></ul><p>1.接口不是类 不能实例化 抽象类可以间接实例化<br>2.接口是完全抽象 抽象类为部分抽象<br>3.接口可以多继承 抽象类是单继承</p><ul><li><ol start="9"><li>   下列代码在运行中会产生几个临时对象？<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">a = (a.ToUpper() + <span class="string">&quot;123&quot;</span>).Substring(<span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>1.a.ToUpper()<br>2.”123”<br>3.a.ToUpper()+”123”</p><ul><li><ol start="10"><li>   下列代码在运行中会发生什么问题？如何避免？<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; lst = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> lst)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item * item);</span><br><span class="line">    lst.RemoveAt(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>会产生运行时错误，因为 foreach 是只读的。不能一边遍历一边修改。</li></ol></li><li><ol start="11"><li>   请简述关键字 Sealed 用在类声明和函数声明时的作用<br>类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。</li></ol></li><li><ol start="12"><li>   反射的实现原理？<br>可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息<br>反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段<br>主要使用的类库：System.Reflection<br>核心类：</li></ol></li></ul><p>1.Assembly描述了程序集<br>2.Type描述了类这种类型<br>3.ConstructorInfo描述了构造函数<br>4.MethodInfo描述了所有的方法<br>5.FieldInfo描述了类的字段<br>6.PropertyInfo描述类的属性<br>通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。</p><ul><li><ol start="13"><li><pre><code>.Net 与 Mono 的关系？</code></pre>.Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR 和基础类库，使得.Net既可以运行在windows也可以运行于 linux，Unix，Mac OS 等。</li></ol></li><li><ol start="14"><li>   在类的构造函数前加上 static 会报什么错?为什么?<br>构造函数格式为 public+类名如果加上 static 会报错（静态构造函数不能有访问修饰符）。<br>原因：静态构造函数不允许访问修饰符，也不接受任何参数；无论创建多少类型的对象，静态构造函数只执行一次；运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数；静态构造函数执行先于任何实例级别的构造函数；显然也就无法使用 this 和 base 来调用构造函数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">constructor</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;static constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">constructor</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;public constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            constructor cs = <span class="keyword">new</span> constructor();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">static</span> constructor</span><br><span class="line"><span class="keyword">public</span> constructor</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="15"><li>   C# String 类型比 stringBuilder 类型的优势是什么?<br>1、    在处理字符串时：String是创建一个string对象，在创建对象时需要分配内存空间。StringBuilder是在原来的内存中修改，不需要分配内存空间。<br>2、    从内存优化方面来说，频繁对字符串的操作使用StringBuilder更好。<br>3、    从功能上来说String仍然比StringBuilder更强。<br>4、    String主要用于公共API,通用性好，读取性能高，占用内存小。<br>5、    StringBuilder主要用于拼接String,修改性能好。<br>6、    String是不可变的，所以天然线程同步。<br>7、    StringBuilder可变，非线程同步。<br>如果是处理字符串的话，用 string 中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而 stringBuilder 是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用 stringBuilder 这样比较节约内存。但是 string 类的方法和功能仍然还是比 stringBuilder 类要强。string 类由于具有不可变性（即对一个 string 对象进行任何更改时，其实都是创建另外一个 string 类的对象），所以当需要频繁的对一个 string 类对象进行更改的时候，建议使用StringBuilder 类，StringBuilder 类的原理是首先在内存中开辟一定大小的内存空间，当对此 StringBuilder 类对象进行更改时， 如果内存空间大小不够， 会对此内存空间进行扩充，而不是重新创建一个对象，这样如果对一个字符串对象进行频繁操作的时候，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。String 主要用于公共 API，通用性好、用途广泛、读取性能高、占用内存小。StringBuilder 主要用于拼接 String，修改性能好。不过现在的编译器已经把 String 的 + 操作优化成 StringBuilder 了， 所以一般用String 就可以了。<br>String 是不可变的，所以天然线程同步。StringBuilder 可变，非线程同步。</li></ol></li><li><ol start="16"><li>   C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?<br>(a,b) =&gt; {};</li></ol></li><li><ol start="17"><li>   数列 1,1,2,3,5,8,13…第 n 位数是多少?用 C#递归算法实现<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Fibonacci</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span> || index == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Fibonacci(index - <span class="number">1</span>) + Fibonacci(index - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="18"><li>   冒泡排序<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">int</span>&gt; <span class="title">Bubbling</span>(<span class="params">List&lt;<span class="built_in">int</span>&gt; lst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = lst.Count <span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst[j] &gt; lst[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                lst[j] = lst[j] + lst[j + <span class="number">1</span>];</span><br><span class="line">                lst[j + <span class="number">1</span>] = lst[j] - lst[j + <span class="number">1</span>];</span><br><span class="line">                lst[j] = lst[j] - lst[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="19"><li>   C#中有哪些常用的容器类，各有什么特点。<br>List：索引泛型容器 访问速度快 修改速度慢<br>HashSet/Dictionary：散列表格式 查询效率高 空间占用较大<br>Stack：后进先出<br>Queue: 先进先出</li></ol></li><li><ol start="20"><li>   C#中常规容器和泛型容器有什么区别，哪种效率高？<br>不带泛型的容器需要装箱和拆箱操作 速度慢 所以泛型容器效率更高 数据类型更安全</li></ol></li><li><ol start="21"><li>   有哪些常见的数值类？<br>简单值类型–包括 整数类型、实数类型、字符类型、布尔类型<br>复合值类型–包括 结构类型、枚举类型</li></ol></li><li><ol start="22"><li>   C#中委托和接口有什么区别？各用在什么场合？<br>接口（interface）是约束类应该具备的功能集合，约束了类应该具备的功能，使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展，同时又合理解决了类的单继承问题。<br>C#中的委托是约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作。<br>在以下情况中使用接口：</li></ol></li></ul><p>1.无法使用继承的场合<br>2.完全抽象的场合<br>3.多人协作的场合<br>以上等等<br>在以下情况中使用委托：<br>多用于事件处理中</p><ul><li><ol start="23"><li>   C#中unsafe关键字是用来做什么的？什么场合下使用？<br>非托管代码才需要这个关键字 一般用在带指针操作的场合</li></ol></li><li><ol start="24"><li>   C#中ref和out关键字有什么区别？<br>ref修饰参数，表示进行引用传递，out修饰参数也表示进行引用传递，但传递的引用只为带回返回值 ref又进又出 out不进只出</li></ol></li><li><ol start="25"><li>   For，foreach，Enumerator.MoveNext的使用，与内存消耗情况<br>for 循环可以通过索引依次进行遍历，foreach和Enumerator.MoveNext通过迭代的方式进行遍历。内存消耗上本质上并没有太大的区别。</li></ol></li><li><ol start="26"><li>   函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。<br>通过StringBuilder那进行append，这样可以减少内存垃圾。</li></ol></li><li><ol start="27"><li>   当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？<br>设计单例模式进行创建对象或者使用对象池。</li></ol></li><li><ol start="28"><li>   JIT 和AOT区别<br>Just-In-Time - 实时编译<br>执行慢 安装快 占空间小一点<br>Ahead-Of-Time - 预先编译<br>执行快 安装慢 占内存占外存大</li></ol></li><li><ol start="29"><li>   给定一个存放参数的数组，重新排列数组<br>void SortArray(Array arr){Array.Sort(arr);}</li></ol></li><li><ol start="30"><li>   Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…..Catch捕捉异常，发送信息不可行)<br>foreach 不能进行元素的删除，因为迭代器会锁定迭代的集合，解决方法：记录找到索引或者key值，迭代结束后再进行删除。    </li></ol></li><li><ol start="31"><li>   GameObject a=new GameObject()  GameObject b=a  实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？<br>存在，b删除只是将它在栈中的内存删除，而A对象本身是在堆中，所以A还存在</li></ol></li><li><ol start="32"><li>   你拥有A块钱，一瓶水B块钱，每瓶水可以得到一个瓶盖，每C个瓶盖可以换一瓶水请写出函数求解上面题目，上面题目ABC为参数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ABC</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;A&quot;&gt;</span>拥有A块钱<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;B&quot;&gt;</span>一瓶水B块钱<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;C&quot;&gt;</span>C个瓶盖可以换一瓶水<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ABC</span>(<span class="params"><span class="built_in">int</span> A,<span class="built_in">int</span> B,<span class="built_in">int</span> C</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> bottle = A / B;</span><br><span class="line">    <span class="keyword">return</span> bottle + Exchange(bottle,C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Exchange</span>(<span class="params"><span class="built_in">int</span> bottle,<span class="built_in">int</span> C</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bottle &lt; C)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bottle/C + Exchange(bottle%C + bottle/C,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="33"><li>   有一排开关，第一个人把所有的开关打开，第二个人按2的倍数的开关，第三个人按3的倍数的开关，以此类推，现在又n个开关，k个人，写函数求最后灯亮着的开关，输入参数n和k<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 灯亮着的开关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;n&quot;&gt;</span>n个开关<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;k&quot;&gt;</span>k个人<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">bool</span>&gt; <span class="title">Switchs</span>(<span class="params"><span class="built_in">int</span> n,<span class="built_in">int</span> k</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">bool</span>&gt; lights = <span class="keyword">new</span> List&lt;<span class="built_in">bool</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lights.Add(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> lights;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; lights.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) % i == <span class="number">0</span> &amp;&amp; j+<span class="number">1</span> &gt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                lights[j] = !lights[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lights;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="34"><li>   数制转换，将任意整数转换成8进制形式<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int2Eight</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int2Eight(num / <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(num%<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="35"><li>   找出200以内的素数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">200</span>; i++) &#123;  <span class="comment">//外层循环：要判断的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">2</span>; j &lt;=i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>&amp;&amp; i!=j) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (j == i ) &#123;  <span class="comment">//结束的条件:最后一个数还没有被整除 </span></span><br><span class="line">                  count++;</span><br><span class="line">                  Console.WriteLine(i);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;（BCWL）U3D程序员笔试题&quot;&gt;&lt;a href=&quot;#（BCWL）U3D程序员笔试题&quot; class=&quot;headerlink&quot; title=&quot;（BCWL）U3D程序员笔试题&quot;&gt;&lt;/a&gt;（BCWL）U3D程序员笔试题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.请回答下述基础相关问</summary>
      
    
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity性能优化</title>
    <link href="https://afoolzwt.github.io/2022/03/11/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://afoolzwt.github.io/2022/03/11/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-11T06:37:17.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LOD层级细节技术"><a href="#LOD层级细节技术" class="headerlink" title="LOD层级细节技术"></a>LOD层级细节技术</h1><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><p><img src="/img/UnityImgs/4.jpg"><br>通过不同的距离 显示不同精细程度的模型</p><h2 id="OcclusionCulling-遮挡剔除"><a href="#OcclusionCulling-遮挡剔除" class="headerlink" title="OcclusionCulling 遮挡剔除"></a>OcclusionCulling 遮挡剔除</h2><p><img src="/img/UnityImgs/5.jpg"><br><img src="/img/UnityImgs/6.jpg"><br><img src="/img/UnityImgs/7.jpg"><br>只显示视野内的物体</p><h2 id="光照贴图LightMapping"><a href="#光照贴图LightMapping" class="headerlink" title="光照贴图LightMapping"></a>光照贴图LightMapping</h2><p><img src="/img/UnityImgs/8.jpg"><br><img src="/img/UnityImgs/9.png"><br>手动烘焙 将光照的Mode设置为Baked</p><h2 id="合并Mesh"><a href="#合并Mesh" class="headerlink" title="合并Mesh"></a>合并Mesh</h2><p><img src="/img/UnityImgs/10.jpg"></p><hr><h1 id="资源优化标准"><a href="#资源优化标准" class="headerlink" title="资源优化标准"></a>资源优化标准</h1><p>资源优化标准<br>    Mesh<br>        动态模型：面片数&lt;3000<br>        材质数&lt;3<br>        骨骼数&lt;50<br>    静态模型<br>        顶点数&lt;500<br>    Audio<br>        长时间音乐（背景音乐）压缩格式 mp3<br>        短时间音乐（音效）非压缩格式 wav<br>        <a href="http://blog.csdn.net/u012565990/article/details/51794486">http://blog.csdn.net/u012565990/article/details/51794486</a><br>    Texture<br>        贴图长宽&lt;1024<br>    Shader<br>        尽量减少复杂数学运算<br>        减少discard操作<br>    模型优化<br>    贴图优化<br>    如何减少冗余资源和重复资源<br>        A、Resources目录下的资源不管是否被引用，都会打包进安装包，不使用的资源不要放在Resources目录下<br>        B、不同目录下的相同资源文件，如果都被引用，那么都会打包进资源包，造成冗余，保证同一个资源文件在项目中只存放在一个目录位置</p><hr><h1 id="Unity-Statistics统计面板"><a href="#Unity-Statistics统计面板" class="headerlink" title="Unity Statistics统计面板"></a>Unity Statistics统计面板</h1><p><img src="/img/UnityImgs/11.jpg"></p><ul><li>FPS帧数    当前一秒钟能渲染81.6帧  渲染一帧需要12.2ms（大于30帧人肉眼不会觉得卡顿）</li><li>CPU:main 计算每一帧需要耗费的时间</li><li>render thread 渲染线程</li><li>Batches：批处理次数</li><li>Verts : 顶点个数（相机视野内）</li><li>Tris : 三角面个数（相机视野内）<br><img src="/img/UnityImgs/12.jpg"></li><li>Batched DrawCall 合并前的DrawCall数量 Batches 合并后的DrawCall数量</li><li>SetPass Calls：shader里面的Pass块</li></ul><hr><h1 id="什么是DrawCall"><a href="#什么是DrawCall" class="headerlink" title="什么是DrawCall"></a>什么是DrawCall</h1><h2 id="Unity安装包大-运行卡的原因"><a href="#Unity安装包大-运行卡的原因" class="headerlink" title="Unity安装包大/运行卡的原因"></a>Unity安装包大/运行卡的原因</h2><p>Unity内置Mono虚拟机让代码可以跨平台运行。</p><h2 id="什么是DrawCall-1"><a href="#什么是DrawCall-1" class="headerlink" title="什么是DrawCall"></a>什么是DrawCall</h2><p>DrawCall很简单，就是cpu对图形绘制接口的调用，CPU通过调用图形库（directx/opengl）接口，命令GPU进行渲染操作。</p><h3 id="CPU和GPU是如何进行并行工作和交互的？"><a href="#CPU和GPU是如何进行并行工作和交互的？" class="headerlink" title="CPU和GPU是如何进行并行工作和交互的？"></a>CPU和GPU是如何进行并行工作和交互的？</h3><p>试想，渲染流程没用采用流水线的工作方式：CPU发送一个渲染命令之后，GPU立即执行渲染命令绘制图形，等到渲染任务结束之后，CPU才可以继续发送下一个渲染命令，这样显然影响工作效率。<br>采用渲染流水线后，CPU与GPU并行工作，独立而不相互依赖。这是通过命令缓冲区来实现的：命令缓冲区维护一个命令队列，CPU向其中发送命令，GPU从中取出命令并执行。命令有很多种，DrawCall是一种，其他命令还有改变渲染状态、设置渲染数据流等。<br>这种方式就类似于游戏开发的网络通信：维持一个消息队列，网络线程接收解析消息并将之添加到消息队列，游戏主线程更新时从中取出消息并做派发处理。</p><h3 id="DrawCall是如何影响性能的？"><a href="#DrawCall是如何影响性能的？" class="headerlink" title="DrawCall是如何影响性能的？"></a>DrawCall是如何影响性能的？</h3><p>每一次绘制CPU都要调用DrawCall，而在调动DrawCall前，CPU还要进行很多准备工作：检测渲染状态、提交渲染所需要的数据、提交渲染所需要的状态。<br>而GPU本身具有很强大的计算能力，可以很快就处理完渲染任务。<br>当DrawCall过多，CPU就会很多额外开销用于准备工作，CPU本身负载，而这时GPU可能闲置了。</p><h3 id="DrawCall优化：减少DrawCall"><a href="#DrawCall优化：减少DrawCall" class="headerlink" title="DrawCall优化：减少DrawCall"></a>DrawCall优化：减少DrawCall</h3><p>既然，我们已经知道DrawCall导致的性能问题在于DrawCall数量过多，那么我们优化的思路就是减少DrawCall。这里我们只讨论批处理（Batching）。<br>过多的DrawCall会造成CPU的性能瓶颈：大量时间消耗在DrawCall准备工作上。很显然的一个优化方向就是：尽量把小的DrawCall合并到一个大的DrawCall中，这就是批处理的思想。<br>使用批处理我们需要在CPU和RAM中合并网格，而合并网格本身是需要计算消耗，而且创建新网格也会占用内存。因此批处理的频次不宜太高，不然造成的消耗可能得不偿失。<br>使用批处理的注意事项：</p><ul><li>合并的网格会在一次渲染任务中进行绘制，他们的渲染数据，渲染状态和shader都是一样的，因此合并的条件至少是：同材质、同贴图、同shader。最好网格顶点格式也一致。</li><li>尽量避免使用大量小的网格，当确实需要时，考虑是否要合并。</li><li>避免使用过多的材质，尽量共享材质。</li><li>网格合并的顶点数量有上限（Unity中好像是65535）</li><li>合并本身有消耗，因此尽量在编辑器下进行合并</li><li>确实需要在运行时合并的，将静态的物体和动态的物体分开合并：静态的合并一次就可以，动态的只要有物体发生变换就要重新合并。<br><img src="/img/UnityImgs/13.jpg"></li></ul><hr><h1 id="解决UI卡顿问题"><a href="#解决UI卡顿问题" class="headerlink" title="解决UI卡顿问题"></a>解决UI卡顿问题</h1><h2 id="Canvas优化要点"><a href="#Canvas优化要点" class="headerlink" title="Canvas优化要点"></a>Canvas优化要点</h2><p>1.Unity为了性能优化会合并Canvas下所有元素。<br>2.如果把所有面板都放入一个Canvas下，会造成重绘。</p><ul><li>   一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大。</li><li>   一般建议每个较复杂的UI界面，都自成一个Canvas（可以是子Canvas），在UI界面很复杂时，甚至要划分更多的子Canvas。</li><li>   动静分离</li><li>   Canvas又不能细分的太多，因为会导致DrawCall的上升</li><li>   把一个面板的UI资源放到一个图集里（背景大图不要和小图放在一个图集里）</li></ul><p>Overdraw(GPU)<br>造成GPU性能瓶颈的主要原因：</p><ul><li>   复杂的vertext或pixel shader计算</li><li>   Overdraw:<br>光栅化阶段的填充像素过多<br>在UGUI中使用Alpha=0的不可见image参与Raycast,比如在屏幕空白处点击的响应，然而这些元素虽然在屏幕上不可见、但依然参与了绘制！<br>解决方案举例：</li><li>   禁用不可见的UI<br>比如当打开一个系统时如果完全挡住了另外一个系统，则可以将被遮挡住的系统禁用。</li><li>   不要使用空的image<br>在unity中，RayCast使用Graphic作为基本元素来检测touch，使用空的image并将alpha设置为0来接收touch事件会产生不必要的overdraw</li></ul><h1 id="【内存优化】图集整理策略"><a href="#【内存优化】图集整理策略" class="headerlink" title="【内存优化】图集整理策略"></a>【内存优化】图集整理策略</h1><p>游戏开发，肯定会有一堆的图片，游戏运行时，unity会把小图整合到1张大图上，方便渲染合批，降低渲染消耗。<br>但是，随着游戏开发的进行，图片越来越多，我们总不能所有的图片都塞进这张大图里，那加载的时候，更新的时候，这张大图的加载速度就会超级慢，严重影响游戏体验。这就涉及到图集的整理问题。<br>优化的本质就是不渲染或少渲染或用更省的方法渲染。</p><h2 id="1-Sprite-Packer介绍"><a href="#1-Sprite-Packer介绍" class="headerlink" title="1.Sprite Packer介绍"></a>1.Sprite Packer介绍</h2><p><img src="/img/UnityImgs/41.png"><br>Sprite Packer会把相同Packing Tag以及相同压缩格式的资源打到相同的图集里面。<br>所以影响图集大小主要集中在2个方面:</p><ul><li>Packing Tag：图集名称</li><li>资源的压缩格式(format)：安卓使用ETC1压缩，IOS默认使用PVRTC,选用不用压缩模式的2张图，即使是同一个Packing Tag，也会被打到2张不同的图集里面。<h2 id="2-图集整理策略"><a href="#2-图集整理策略" class="headerlink" title="2. 图集整理策略"></a>2. 图集整理策略</h2>知道了Sprite Packer怎么打包图集的，我们就要根据项目实际情况，去合理安排和整理图片资源，图集太大不行，太空也不行，然后又要关心业务，很多注意事项。</li></ul><p>所以整理以下几个我们平时整理图集时候会关注的几个点：</p><ol><li>尽量紧凑，没有太多空白。比如一个图集512x512刚好塞满，现在额外加一张小图进去，就被迫变成512x1024，浪费的空间就很多了，而且在有的平台，该图集会被强制变成1024*1024，内存消耗从1M变成4M。</li><li>Draw Call尽量少，同一个界面的小图尽量在一个图集里。</li><li>内存管理方便，加载性能好，打开一个界面时只加载必要的图集，关闭时可以方便地释放图集。</li><li>AssetBundle打包\热更粒度合理，不能出现“热更一个新界面，大量图集都需要热更”的情况。</li><li>维护方便，当界面变化时，调整方便，包括生成图集、调整引用、新图集尺寸变化的影响、新图集AssetBundle变化的影响等等。</li><li>图集间隙尽量少，主要靠图集工具，常见的比如更紧凑的多边形Mesh替代Rect Mesh、旋转、切割等等。【TP比Unity的 Spirte Packer算法更好，这里我们不讨论】    <h2 id="3-我们现在项目的图集整理策略："><a href="#3-我们现在项目的图集整理策略：" class="headerlink" title="3. 我们现在项目的图集整理策略："></a>3. 我们现在项目的图集整理策略：</h2></li><li>【脚本】按业务功能的预制，寻找依赖，收集所有预制引用的图片，</li><li>【脚本】将依赖的图片分别移动到对应业务命名的文件夹下【没有就创建】，如果有多个预制使用了同一张图片，我们就把它扔到common文件夹；</li><li>【人工】打开Spirte Packer，查看图集情况是否合理，合并零碎文件夹，让图集尽量紧凑，没有太多空白，尽量让图集处于2的n次方大小。</li><li> 细碎图片扔进common。</li><li> 程序来管理图集，就导致出包前，老是要要求美术缩小图片啊，调整目录啊，美术也不高兴，我觉得应该将这件事交给美术去做，拉美术一个人负责这件事，这样，他们上传的时候就会注意图片的通道RGBA啊，然后图集分配是否合理这些事，这样我们检查后的反馈就会少很多，大家合作也更舒服。<h2 id="4-Unity上手动查看这些打包的大图方式："><a href="#4-Unity上手动查看这些打包的大图方式：" class="headerlink" title="4.Unity上手动查看这些打包的大图方式："></a>4.Unity上手动查看这些打包的大图方式：</h2></li><li>打开 Sprite Packer界面【Window-Sprite Packer(2018版本:Window-2D-Sprite Packer)】</li><li>点击pack按钮【前提是已经设置了图片的Tag】</li><li>但是由于unity内置的查看图集很不友好，提供一个工具Altas Looker，可以按上下键看图集，挺方便的。（<a href="https://github.com/Aver58/Tools/tree/master/UnityProject/Assets/Editor/AtlasLooker%EF%BC%89">https://github.com/Aver58/Tools/tree/master/UnityProject/Assets/Editor/AtlasLooker）</a></li></ol><h2 id="5-资源优化"><a href="#5-资源优化" class="headerlink" title="5. 资源优化"></a>5. 资源优化</h2><h3 id="纹理优化"><a href="#纹理优化" class="headerlink" title="纹理优化"></a>纹理优化</h3><p>纹理优化的目的是让它们占用的内存尽量的小，那么纹理加载进内存后，大小计算公式如下：</p><blockquote><p>纹理内存大小（字节） = 纹理宽度 x 纹理高度 x 像素字节<br>像素字节 = 像素通道数（R/G/B/A） x 通道大小（1字节/半字节）</p></blockquote><h3 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h3><p>根据项目实际情况将贴图都缩小至合适的大小。这里的合适大小是指渲染对象在画面中大多数情况下不可能达到的最大尺寸，这个尺寸最好保持2的N次方。</p><h3 id="纹理通道"><a href="#纹理通道" class="headerlink" title="纹理通道"></a>纹理通道</h3><p>通道优化的目的是降低像素所占的大小，可以通过以下方法达到目的:</p><ul><li>去除Alpha通道。可以减少通道数量，适用于不需要Alpha混合或Alpha Test的角色和物件</li><li>应用单通道图。也可以减少通道数量，比如灰度图、地形高度图，掩码图，Shader掩码图等</li><li>使用16位代替32位图。例如RGB444/RGBA4444就可以减少像素通道大小。<h3 id="提高纹理复用率"><a href="#提高纹理复用率" class="headerlink" title="提高纹理复用率"></a>提高纹理复用率</h3></li><li>建立共享图库。将通用的元素放至共享库，例如按钮/进度条/背景/UI通用元素等。</li><li>用九宫格图代替大块背景图。九宫格在游戏开发中是比较常见的UI组件。</li><li>纹理元素通过变换可组合成复合纹理。例下图，上下左右对称的背景图可以用4张相同贴图实例通过旋转/翻转后获得。【mirror】<h3 id="UI图集"><a href="#UI图集" class="headerlink" title="UI图集"></a>UI图集</h3>界面A引用界面A图集和共享图集是允许的，但尽量不要引用界面B等其它图集。<br>但实际在游戏开发过程中，很难保证美术做到这一点，通常存在以下问题：</li></ul><ol><li><p>如果界面A确实要用到界面B图集的某个元素，怎么办？</p><blockquote><p>参考解决方法：要看被引用元素的通用度，如果只是界面A和B在用，可以将被引用元素拷贝到界面A图集下；如果其它界面也会引用到，就可以将它移到共享图库。</p></blockquote></li><li><p>有些UI纹理很大且很多界面都有用到，如果放在共享图库会导致共享图库急剧膨胀，怎么办?</p><blockquote><p>参考解决方法：大尺寸纹理建议用九宫格+细节图，或通过组合的方式来代替。</p></blockquote></li><li><p>如何保证美术制作的UI只引用到自身图集和共享图集？</p><blockquote><p>参考解决方法：实现批处理检查工具，找出每个UI界面引用到的图集列表，引用的图集超过2个便是不合格。</p></blockquote></li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>几种主流贴图压缩算法的实现原理详解</p><ul><li>ETC<blockquote><p>ETC压缩算法采用将图像中的chromatic和luminance分开存储的方式，而在解码时使用luminance对chromatic进行调制进而重现原始图像信息。<br>ETC也主要有两种方法：ETC1和改进后的ETC2。</p></blockquote></li></ul><p>ETC1：<br>采用4x2的block进行分割（原始为4*2*24=192，压缩后为32，压缩率为6）。<br>ETC2：<br>根据ETC1的实现方式，如果其块内的颜色分布不均匀的话，则其存储的两个basecolor会较远的分布于插值趋线的较远的两侧，进行解压后会得到较低的压缩质量，因而ETC2就是解决如何针对这些较为特殊的颜色分布来选择更加优化的压缩策略。</p><ul><li>PVRTC</li></ul><p>PVRTC的不是基于block的方式生成的，但是却也可以理解为以block方式组织的。</p><ul><li>ASTC</li></ul><p>ASTC中ARM研发的一种较新的贴图压缩格式，相对于上述几种方法具有较多的优势，其应该会慢慢成为之后移动设备上贴图压缩的主要标准和主流。其主要具有如下的特性：</p><ol><li>较高的灵活性；</li><li>可变的压缩率；</li><li>支持2d/3d贴图；</li><li>适用于移动平台；</li><li>支持LDR/HDR贴图内容；<br>ASTC同样是基于block的压缩方式，但块的大小却较支持多种尺寸，比如从基本的4x4到12x12，而且块的宽高也不限于pot，比如6x5；每个块内的内容用128bits来进行存储，因而不同的块就对应着不同的压缩率。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LOD层级细节技术&quot;&gt;&lt;a href=&quot;#LOD层级细节技术&quot; class=&quot;headerlink&quot; title=&quot;LOD层级细节技术&quot;&gt;&lt;/a&gt;LOD层级细节技术&lt;/h1&gt;&lt;h2 id=&quot;LOD&quot;&gt;&lt;a href=&quot;#LOD&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/categories/Unity/"/>
    
    <category term="性能优化" scheme="https://afoolzwt.github.io/categories/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/tags/Unity/"/>
    
    <category term="性能优化" scheme="https://afoolzwt.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity零碎知识点</title>
    <link href="https://afoolzwt.github.io/2022/03/11/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://afoolzwt.github.io/2022/03/11/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-11T06:33:50.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Unity协程的原理"><a href="#1-Unity协程的原理" class="headerlink" title="1.Unity协程的原理"></a>1.Unity协程的原理</h1><p>协程不是多线程，协程还是在主线程里面（注：在Unity中非主线程是不可以访问Unity资源的）</p><h2 id="线程、进程和协程的区别"><a href="#线程、进程和协程的区别" class="headerlink" title="线程、进程和协程的区别"></a>线程、进程和协程的区别</h2><p>进程有自己独立的堆和栈，即不共享堆也不共享栈，进程由操作系统调度</p><p>线程拥有自己独立的栈和共享的堆，共享堆不共享栈，线程亦由操作系统调度（标准线程是这样的）</p><p>协程和线程一样共享堆不共享栈，协程由程序员在协程的代码里面显示调度</p><p>一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行的，在线程里面可以开启协程，让程序在特定的时间内运行。</p><p>协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失了标准线程使用多CPU的能力。</p><h2 id="Unity中协程执行的原理"><a href="#Unity中协程执行的原理" class="headerlink" title="Unity中协程执行的原理"></a>Unity中协程执行的原理</h2><p>Unity生命周期函数：<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/1.png" alt="1.png"></p><p>在Unity运行时，调用协程就是开启了一个IEnumerator（迭代器），协程开始执行，在执行到yield return之前和其他的正常的程序没有差别，但是当遇到yield return之后会立刻返回，并将该函数暂时挂起。在下一帧遇到FixedUpdate或者Update之后判断yield return 后边的条件是否满足，如果满足向下执行。</p><p>根据unity主线的框架运行图我们知道，协同程序主要是在update()方法之后，lateUpdate()方法之前调用。</p><h3 id="Unity生命周期对协程的影响"><a href="#Unity生命周期对协程的影响" class="headerlink" title="Unity生命周期对协程的影响"></a>Unity生命周期对协程的影响</h3><p>通过设置MonoBehaviour脚本的enabled对协程是没有影响的，但如果gameObject.SetActive(false) 则已经启动的协程则完全停止了，即使在Inspector把gameObject 激活还是没有继续执行。也就说协程虽然是在MonoBehvaviour启动的（StartCoroutine）但是协程函数的地位完全是跟MonoBehaviour是一个层次的，不受MonoBehaviour的状态影响，但跟MonoBehaviour脚本一样受gameObject 控制，也应该是和MonoBehaviour脚本一样每帧“轮询” yield 的条件是否满足。</p><p>注：WaitForSends()受Time.timeScale影响，当Time.timeScale = 0f时，yieldreturn new WaitForSecond(X)将不会满足。</p><h2 id="协程的主要应用"><a href="#协程的主要应用" class="headerlink" title="协程的主要应用"></a>协程的主要应用</h2><p>协程不是只能做一些简单的延迟，如果只是单纯的暂停几秒然后在执行就完全没有必要开启一个线程。</p><p>协程的真正作用是分步做一些比较耗时的事情，比如加载游戏里的资源。</p><h1 id="2-C-中的虚方法、抽象方法、抽象类以及接口"><a href="#2-C-中的虚方法、抽象方法、抽象类以及接口" class="headerlink" title="2.C#中的虚方法、抽象方法、抽象类以及接口"></a>2.C#中的虚方法、抽象方法、抽象类以及接口</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C# OOP（面向对象）的三大原则：封装、继承、多态。</p><p>在面向对象语言中，接口的多种不同的实现方式即为多态。引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作（摘自“Delphi4编程技术内幕”）。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。多态性在Object Pascal和C++中都是通过虚函数实现的。</p><p>用我自己的理解来说：多态就是在继承的前提下，不同对象调用相同方法却表现出不同的行为，此为多态。<br>关键性的一句话：多态性在C++中是通过虚函数实现的，这在C#中同样适用。但是在C#中有三种方法来体现：虚方法，抽象类，接口。</p><h2 id="虚方法-Virtual"><a href="#虚方法-Virtual" class="headerlink" title="虚方法 Virtual"></a>虚方法 Virtual</h2><p>虚方法存在于相对于需要实现多态的子类的父类中，同时也是最基本的实现多态的方法。</p><p>具体的语法是在父类中用virtual修饰，然后在子类中使用override进行重写。</p><h2 id="抽象方法以及抽象类-Abstract"><a href="#抽象方法以及抽象类-Abstract" class="headerlink" title="抽象方法以及抽象类 Abstract"></a>抽象方法以及抽象类 Abstract</h2><p>存在于父类中的虚方法是有自己的方法体的，而且这些方法体是必要的，少了他们就无法完成逻辑，这种情况需要使用虚方法。</p><p>抽象方法必须存在于抽象类中，抽象类的具体语法是类名前加上abstract。</p><p>抽象方法没有方法体，且所有继承了抽象类的子类必须重写所有的抽象方法。</p><p>抽象类中可以包括普通方法，并且抽象类不能被实例化。</p><p>抽象类的使用场景：</p><p>1.父类方法不知道如何去实现；</p><p>2.父类没有默认实现且不需要实例化</p><h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h2><p>接口是指定一组函数成员而不实现他们的引用类型。所以只能类和结构来实现接口，在继承该接口的类里面要实现接口的所有方法。</p><p>接口的作用就是实现某些类的特殊功能。</p><p>1.接口声明不能包含以下成员：<br>数据成员、静态成员。<br>2.接口声明只能包含如下类型的非静态成员函数的声明：<br>方法、属性、事件、索引器。<br>3.这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后必须使用分号。</p><p><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/2.png" alt="2.png"></p><h1 id="3-C-中值类型与引用类型的区别"><a href="#3-C-中值类型与引用类型的区别" class="headerlink" title="3.C#中值类型与引用类型的区别"></a>3.C#中值类型与引用类型的区别</h1><p>在C#中值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中。</p><p>值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。<br>引用类型（reference type）：string 和 class 统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</p><p>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。</p><ul><li>数据在哪里声明，就存储在哪里。<br>方法中声明：值类型数据存储在栈中，引用类型的引用存储在栈中，数据存储在堆中；方法在栈中执行，在方法内声明的变量都是在栈中存储，方法执行完毕后将这些数据清除，方法内部的值类型将直接被清除，引用类型将被清除引用，而存储在堆中的数据则等待GC自动回收。<br>类中：值类型数据存储在堆中，引用类型的引用和数据都存储在堆中。</li><li>内存区域上的区别<br>值类型：数据存储在栈上，超出作用域就自动清理<br>引用类型：数据存储在托管堆上，引用地址在线程栈上，地址指向数据存放的堆上<br>托管堆会由GC来自动释放 ，线程栈数据在作用域结束后会被清理。</li><li>拷贝策略：值类型是拷贝数据，引用类型是拷贝引用地址<br>如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变<br>如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符）<br>【扩展Ref引用参数，Out输出参数可以利用这一副作用机制】<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Parameters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Dowork();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dowork</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i = <span class="number">0</span>;  <span class="comment">// int 是值类型</span></span><br><span class="line">            Console.WriteLine(i);   <span class="comment">// i = 0</span></span><br><span class="line">            Pass.<span class="keyword">value</span>(i);          <span class="comment">// 值类型使用的是 i 的副本，i不变</span></span><br><span class="line">            Console.WriteLine(i);   <span class="comment">// i = 0</span></span><br><span class="line"> </span><br><span class="line">            WrappendInt wi = <span class="keyword">new</span> WrappendInt(); <span class="comment">// 创建类 WrappendInt 的另外一个实例</span></span><br><span class="line">            Console.WriteLine(wi.Number);   <span class="comment">// 0 // 被默认构造器初始化为 0</span></span><br><span class="line">            Pass.Reference(wi);     <span class="comment">// 调用方法，wi 和 param 将引用同一个对象</span></span><br><span class="line">            Console.WriteLine(wi.Number);   <span class="comment">// 42</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Pass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">value</span>(<span class="params"><span class="built_in">int</span> param</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            param = <span class="number">42</span>; <span class="comment">// 赋值操作使用的是值类型参数的一个副本，原始参数不受影响</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reference</span>(<span class="params">WrappendInt param</span>) <span class="comment">// 创建类 WrappendInt 的一个实例</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            param.Number = <span class="number">42</span>;  <span class="comment">// 此参数是引用类型的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">WrappendInt</span>   <span class="comment">// 类是引用类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">*0</span></span><br><span class="line"><span class="comment">*0</span></span><br><span class="line"><span class="comment">*0</span></span><br><span class="line"><span class="comment">*42</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>值类型：包含了所有简单类型（整数、浮点、bool、char）、struct、enum。<br>继承自System.ValueTyoe<br>引用类型包含了string，object，class，interface，delegate，array<br>继承自System.Object</li></ul><h1 id="4-值类型和引用类型互相转换：拆箱和装箱"><a href="#4-值类型和引用类型互相转换：拆箱和装箱" class="headerlink" title="4.值类型和引用类型互相转换：拆箱和装箱"></a>4.值类型和引用类型互相转换：拆箱和装箱</h1><p>装箱：值类型====》引用类型object<br>1.分配内存堆<br>2.值类型数据拷贝到新的内存堆中<br>3.栈中分配一个新的引用地址指向内存堆</p><p>拆箱：引用类型object====》值类型<br>1.检查确保对象是给定值类型的一个装箱值<br>2.将该值数据复制到栈中的值类型</p><p>string是特殊的引用类型，如果传入参数是string，在方法里修改，原string数值不变。<br>原因是string的不变性，系统内部做了特殊处理。</p><h1 id="5-Foreach遍历原理"><a href="#5-Foreach遍历原理" class="headerlink" title="5.Foreach遍历原理"></a>5.Foreach遍历原理</h1><p>任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了 IEnumerator接口的对象。<br>这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象。<br>通过这个实现了 IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象<br>对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span> &#125;;</span><br><span class="line">IEnumerator listEnumerator = list.GetEnumerator();</span><br><span class="line">     <span class="keyword">while</span> (listEnumerator.MoveNext())</span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(listEnumerator.Current);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="6-反射的实现原理"><a href="#6-反射的实现原理" class="headerlink" title="6.反射的实现原理"></a>6.反射的实现原理</h1><p>定义：运行时，动态获取类型信息,动态创建对象,动态访问成员的过程。<br>另一种定义：审查元数据并收集元数据的信息。<br>元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。<br>反射是在运行期间获取到类、对象、方法、数据的一种手段<br>主要使用类库System.Reflection<br>反射要点：如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托<br>一、动态获取类型信息<br>1.System.Reflection.Assembly.Load(“XXXX.dll”) 动态加载程序集<br>2.System.Type.GetType(“XXXX类名”); //动态获取某程序集中某类信息<br>3.obj.GetType(); //已知对象获取类信息 ——或者——typeof(类型) //已知类类型<br>二、动态创建对象实例（上一步操作后获得类对象）<br>System.Activator.CreateInstance(Type type);<br>三、动态访问成员调用方法（上一步操作后已获取实例对象）<br>System.Reflection.MethodInfo method = type.GetMethod(“方法名”);//获得方法<br>System.Reflection.MethodInfo.Invoke(object , new object[]{参数}) //调用的类实例和实例参数</p><p>核心类<br>System.Reflection.Assembly 描述程序集<br>System.Type 描述类<br>System.Reflection.FieldInfo 描述了类的字段<br>System.Reflection.ConstructorInfo 描述构造函数<br>System.Reflection.MethodInfo 描述类的方法<br>System.Reflection.PropertyInfo 描述类的属性</p><p>反射耗性能，lua是动态语言，一种小巧的脚本语言，会使用反射机制。</p><h1 id="Unity-GC垃圾回收"><a href="#Unity-GC垃圾回收" class="headerlink" title="Unity GC垃圾回收"></a>Unity GC垃圾回收</h1><p>英文原文：<a href="https://unity3d.com/de/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069">https://unity3d.com/de/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069</a></p><h2 id="GC-garbage-collection-简介"><a href="#GC-garbage-collection-简介" class="headerlink" title="GC (garbage collection)简介"></a>GC (garbage collection)简介</h2><p>在游戏运行的时候，数据主要存储在内存中，当游戏的数据在不需要的时候，存储当前数据的内存就可以被回收以再次使用。内存垃圾是指当前废弃数据所占用的内存，垃圾回收（GC）是指将废弃的内存重新回收再次使用的过程。<br>Unity中将垃圾回收当作内存管理的一部分，如果游戏中废弃数据占用内存较大，则游戏的性能会受到极大影响，此时垃圾回收会成为游戏性能的一大障碍点。</p><h2 id="Unity内存管理机制简介"><a href="#Unity内存管理机制简介" class="headerlink" title="Unity内存管理机制简介"></a>Unity内存管理机制简介</h2><p>Unity主要采用自动内存管理的机制，开发时在代码中不需要详细地告诉unity如何进行内存管理，unity内部自身会进行内存管理。这和使用C++开发需要随时管理内存相比，有一定的优势，当然带来的劣势就是需要随时关注内存的增长。<br>unity的自动内存管理可以理解为以下几个部分：<br>1.unity内部有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。<br>2.unity中的变量只会在堆栈或者堆内存上进行内存分配，值类型变量都在堆栈上进行内存分配，其他类型的变量都在堆内存上分配。<br>3.只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。<br>4.一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。<br>5.垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。</p><h2 id="栈内存分配和回收机制"><a href="#栈内存分配和回收机制" class="headerlink" title="栈内存分配和回收机制"></a>栈内存分配和回收机制</h2><p>堆栈上的内存分配和回收十分快捷简单，因为堆栈上只会存储短暂的或者较小的变量。内存分配和回收都会以一种顺序和大小可控制的形式进行。</p><p>堆栈的运行方式就像stack: 其本质只是一个数据的集合，数据的进出都以一种固定的方式运行。正是这种简洁性和固定性使得堆栈的操作十分快捷。当数据被存储在堆栈上的时候，只需要简单地在其后进行扩展。当数据失效的时候，只需要将其从堆栈上移除。</p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，</p><p>1.首先unity会先检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应大小的内存单元；</p><p>2.如果没有，就触发垃圾回收（GC）来释放不再被使用的堆内存（缓慢的操作），如果垃圾回收后有足够大小的内存单元，则进行内存分配。</p><p>3.如果还不够，则会扩展堆内存的大小（缓慢的操作），最后分配对应大小的内存单元给变量。</p><p>堆内存的分配有可能会变得十分缓慢，特别是在需要垃圾回收和堆内存需要扩展的情况下，通常需要减少这样的操作次数。</p><h2 id="GC相关的一些信息"><a href="#GC相关的一些信息" class="headerlink" title="GC相关的一些信息"></a>GC相关的一些信息</h2><h3 id="GC的操作过程："><a href="#GC的操作过程：" class="headerlink" title="GC的操作过程："></a>GC的操作过程：</h3><p>当堆内存上一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。其操作如下<br>1.GC会检查堆内存上的每个存储变量；<br>2.对每个变量会检测其引用是否处于激活状态；<br>3.如果变量的引用不再处于激活状态，则会被标记为可回收；<br>4.被标记的变量会被移除，其所占有的内存会被回收到堆内存上。<br>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h3 id="何时触发GC："><a href="#何时触发GC：" class="headerlink" title="何时触发GC："></a>何时触发GC：</h3><p>主要有三个操作会触发垃圾回收：<br>1.在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；<br>2.GC会自动的触发，不同平台运行频率不一样；<br>3.GC可以被强制执行。<br>特别是在堆内存上进行内存分配时内存单元不足够的时候，GC会被频繁触发，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。</p><h3 id="GC操作带来的问题："><a href="#GC操作带来的问题：" class="headerlink" title="GC操作带来的问题："></a>GC操作带来的问题：</h3><p>1.需要大量的时间来运行，可能会使得游戏运行缓慢。其次GC可能会在关键时候运行，例如在CPU处于游戏的性能运行关键时刻，此时任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降。<br>2.堆内存的碎片划。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存被分割成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是单独的内存单元较小，在下次内存分配的时候不能找到合适大小的存储单元，这也会触发GC操作或者堆内存扩展操作。</p><p>堆内存碎片会造成两个结果，一个是游戏占用的内存会越来越大，一个是GC会更加频繁地被触发。</p><h3 id="利用profiler-window-来检测堆内存分配（unity工具栏Window-gt-Profiler打开）："><a href="#利用profiler-window-来检测堆内存分配（unity工具栏Window-gt-Profiler打开）：" class="headerlink" title="利用profiler window 来检测堆内存分配（unity工具栏Window-&gt;Profiler打开）："></a>利用profiler window 来检测堆内存分配（unity工具栏Window-&gt;Profiler打开）：</h3><p>在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个列是GC Alloc，通过分析其来定位是什么函数造成大量的堆内存分配操作。一旦定位该函数，我们就可以分析解决其造成问题的原因从而减少内存垃圾的产生。现在Unity5.5的版本，还提供了deep profiler的方式深度分析GC垃圾的产生。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="降低GC影响的方法"><a href="#降低GC影响的方法" class="headerlink" title="降低GC影响的方法"></a>降低GC影响的方法</h3><p>1.减少GC的运行次数；</p><p>2.减少单次GC的运行时间；</p><p>3.将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC。</p><h3 id="主要策略为："><a href="#主要策略为：" class="headerlink" title="主要策略为："></a>主要策略为：</h3><p>1.对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</p><p>2.降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。</p><p>3.我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。</p><p>具体如下：</p><h4 id="减少内存垃圾的数量"><a href="#减少内存垃圾的数量" class="headerlink" title="减少内存垃圾的数量"></a>减少内存垃圾的数量</h4><ul><li>1.缓存<br>如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存。<br>例如下面的代码每次调用的时候就会造成堆内存分配，主要是每次都会分配一个新的数组：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span> &#123;</span><br><span class="line">     Renderer[] allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">     ExampleFunction(allRenderers);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对比下面的代码，只会生产一个数组用来缓存数据，实现反复利用而不需要造成更多的内存垃圾：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Renderer[] allRenderers;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span> &#123;</span><br><span class="line">    ExampleFunction(allRenderers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2.不要在频繁调用的函数中反复进行堆内存分配<br>在MonoBehaviour中，如果我们需要进行堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如Update()和LateUpdate()函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们可以考虑在Start()或者Awake()函数中进行内存分配，这样可以减少内存垃圾。<br>下面的例子中，update函数会多次触发内存垃圾的产生：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ExampleGarbageGenerationFunction(transform.position.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过一个简单的改变，我们可以确保每次在x改变的时候才触发函数调用，这样避免每帧都进行堆内存分配：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> previousTransformPositionX;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">float</span> transformPositionX = transform.position.x;</span><br><span class="line">    <span class="keyword">if</span>(transfromPositionX != previousTransformPositionX) &#123;</span><br><span class="line">        ExampleGarbageGenerationFunction(transformPositionX);    </span><br><span class="line">        previousTransformPositionX = trasnformPositionX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外的一种方法是在update中采用计时器，特别是在运行有规律但是不需要每帧都运行的代码中，例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> timeSinceLastCalled;</span><br><span class="line"><span class="built_in">float</span> delay = <span class="number">1f</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    timSinceLastCalled += Time.deltaTime;</span><br><span class="line">    <span class="keyword">if</span>(timeSinceLastCalled &gt; delay) &#123;</span><br><span class="line">         ExampleGarbageGenerationFunction();</span><br><span class="line">         timeSinceLastCalled = <span class="number">0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.清除链表<br>在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的clear函数来清空链表从而替代反复多次的创建分配链表。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    List myList = <span class="keyword">new</span> List();</span><br><span class="line">    PopulateList(myList);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过改进，我们可以将该链表只在第一次创建或者该链表必须重新设置的时候才进行堆内存分配，从而大大减少内存垃圾的产生：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List myList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    myList.Clear();</span><br><span class="line">    PopulateList(myList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>4.对象池<br>即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹这种会频繁生成和销毁的对象。<h4 id="造成不必要的堆内存分配的因素"><a href="#造成不必要的堆内存分配的因素" class="headerlink" title="造成不必要的堆内存分配的因素"></a>造成不必要的堆内存分配的因素</h4></li><li>1.字符串</li></ul><p>在c#中，字符串是引用类型变量而不是值类型变量，即使看起来它是存储字符串的值的。这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。</p><p>c#中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的”+”操作），unity会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。</p><p>我们可以采用以下的一些方法来最小化字符串的影响：</p><p>1.减少不必要的字符串的创建，如果一个字符串的值被多次利用，我们可以创建并缓存该字符串。（实际上因为驻留机制，相同值的字符串，指针是一样的，可见最后的补充1）</p><p>2.减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个Text组件，对于不变的部分就设置为类似常量字符串即可。</p><p>3.如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>4.移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数</p><ul><li>2.Unity函数调用</li></ul><p>在代码编程中，当我们调用不是我们自己编写的代码，无论是Unity自带的还是插件中的，我们都可能会产生内存垃圾。Unity的某些函数调用会产生内存垃圾，我们在使用的时候需要注意它的使用。</p><p>这儿没有明确的列表指出哪些函数需要注意，每个函数在不同的情况下有不同的使用，所以最好仔细地分析游戏，定位内存垃圾的产生原因以及如何解决问题。有时候缓存是一种有效的办法，有时候尽量降低函数的调用频率是一种办法，有时候用其他函数来重构代码是一种办法。现在来分析unity中常见的造成堆内存分配的函数调用。</p><p>在Unity中如果函数需要返回一个数组，则一个新的数组会被分配出来用作结果返回，这不容易被注意到，特别是如果该函数含有迭代器，下面的代码中对于每个迭代器都会产生一个新的数组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; myMesh.normals.Length; i++) &#123;</span><br><span class="line">        Vector3 normal = myMesh.normals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这样的问题，我们可以缓存一个数组的引用，这样只需要分配一个数组就可以实现相同的功能，从而减少内存垃圾的产生：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Vector3[] meshNormals = myMesh.normals;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; meshNormals.Length; i++) &#123;</span><br><span class="line">        Vector3 normal = meshNormals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外另外的一个函数调用GameObject.name 或者 GameObject.tag也会造成预想不到的堆内存分配，这两个函数都会将结果存为新的字符串返回，这就会造成不必要的内存垃圾，对结果进行缓存是一种有效的办法，但是在Unity中都对应的有相关的函数来替代。对于比较gameObject的tag，可以采用GameObject.CompareTag()来替代。除此之外我们还可以用Input.GetTouch()和Input.touchCount()来代替Input.touches，或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll()。</p><ul><li>3.装箱拆箱操作</li></ul><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。</p><ul><li>4.协程</li></ul><p>调用 StartCoroutine()会产生少量的内存垃圾，因为unity会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用。基于此，任何在游戏关键时刻调用的协程都需要特别的注意，特别是包含延迟回调的协程。<br>yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由于需要返回0，引发了装箱操作，所以会产生内存垃圾。这种情况下，为了避免内存垃圾，我们可以这样返回：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>另外一种对协程的错误使用是每次返回的时候都new同一个变量，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isComplete) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以采用缓存来避免这样的内存垃圾产生：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WaitForSeconds delay = <span class="keyword">new</span> WaiForSeconds(<span class="number">1f</span>);</span><br><span class="line"><span class="keyword">while</span>(!isComplete) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果游戏中的协程产生了内存垃圾，我们可以考虑用其他的方式来替代协程。重构代码对于游戏而言十分复杂，但是对于协程而言我们也可以注意一些常见的操作，比如如果用协程来管理时间，最好在update函数中保持对时间的记录。如果用协程来控制游戏中事件的发生顺序，最好对于不同事件之间有一定的信息通信的方式。对于协程而言没有适合各种情况的方法，只有根据具体的代码来选择最好的解决办法。</p><ul><li>5.函数引用</li></ul><p>函数的引用，无论是指向匿名函数还是显式函数，在unity中都是引用类型变量，这都会在堆内存上进行分配。匿名函数的调用完成后都会增加内存的使用和堆内存的分配。具体函数的引用和终止都取决于操作平台和编译器设置，但是如果想减少GC最好减少函数的引用。</p><ul><li>6.LINQ和常量表达式</li></ul><p>由于LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试。</p><h3 id="重构代码来减小GC的影响"><a href="#重构代码来减小GC的影响" class="headerlink" title="重构代码来减小GC的影响"></a>重构代码来减小GC的影响</h3><p>即使我们减小了代码在堆内存上的分配操作，代码也会增加GC的工作量。最常见的增加GC工作量的方式是让其检查它不必检查的对象。struct是值类型的变量，但是如果struct中包含有引用类型的变量，那么GC就必须检测整个struct。如果这样的操作很多，那么GC的工作量就大大增加。在下面的例子中struct包含一个string，那么整个struct都必须在GC中被检查：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ItemData &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> cost;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">&#125;</span><br><span class="line">ItemData[] itemData;</span><br></pre></td></tr></table></figure><p>我们可以将该struct拆分为多个数组的形式，从而减小GC的工作量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] itemNames;</span><br><span class="line"><span class="built_in">int</span>[] itemCosts;</span><br><span class="line">Vector3[] itemPositions;</span><br></pre></td></tr></table></figure><p>另外一种在代码中增加GC工作量的方式是保存不必要的Object引用，在进行GC操作的时候会对堆内存上的object引用进行检查，越少的引用就意味着越少的检查工作量。在下面的例子中，当前的对话框中包含一个对下一个对话框引用，这就使得GC的时候会去检查下一个对象框：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogData</span> &#123;</span><br><span class="line">     DialogData nextDialog;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> DialogData <span class="title">GetNextDialog</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> nextDialog;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重构代码，我们可以返回下一个对话框实体的标记，而不是对话框实体本身，这样就没有多余的object引用，从而减少GC的工作量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogData</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> nextDialogID;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetNextDialogID</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> nextDialogID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时执行GC操作"><a href="#定时执行GC操作" class="headerlink" title="定时执行GC操作"></a>定时执行GC操作</h3><p>如果我们知道堆内存在被分配后并没有被使用，我们希望可以主动地调用GC操作，或者在GC操作并不影响游戏体验的时候（例如场景切换的时候），我们可以主动的调用GC操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.GC.Collect()</span><br></pre></td></tr></table></figure><h2 id="托管堆"><a href="#托管堆" class="headerlink" title="托管堆"></a>托管堆</h2><p>在开发过程中，我们总会遇到托管堆内存意外的增长的情况。在Unity中，托管堆的增长速度总是大于它收缩的速度。因此，Unity的GC（Garbage Collection）回收策略更趋向于内存片段的回收。</p><h3 id="托管堆的工作原理"><a href="#托管堆的工作原理" class="headerlink" title="托管堆的工作原理"></a>托管堆的工作原理</h3><p>“托管堆”是由项目的脚本运行时（Scripting Runtime）——Mono或者IL2CPP内存管理器管理的 一个内存片段。所有托管代码中被创建的对象必须被分配到托管堆上（提示：严格意义上说，所有不为空的引用类型对象和所有被封装的值类型对象必须被分配到托管堆上）。<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/5.png"><br>上图中，白色部分是一部分的已经分配的托管堆，有颜色的部分代表内存空间上存储的数据。当创建新的对象时，堆上就会被分配更多的空间。</p><p>Unity的GC会周期性的执行（执行的周期与平台有关）。它会遍历堆上的所有对象，并且标记那些没有被引用的对象，然后删除它们，释放内存。</p><p>Unity的GC机制，使用了Boehm GC算法（可以参考：<a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector">维基百科</a>），是非分代（non-generational）和非压缩（non-compacting）的。”非分代”是指GC执行清理操作时，必须遍历整个内存，并且随着内存的增长，它的性能就会降低。“非压缩”意味着内存中的对象不会被重新定位，去缩小对象之间的内存空隙。<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/6.png"><br>上图中展示了一个内存分配的例子。当内存被释放时，内存是空的。然而，这部分未被分配的内存并没有与其他未分配的内存合并，它的两边的内存可能仍然在使用。因此，这部分未被分配的内存空间就成了内存片段中的“间隙（Gap）”（图中红色的圆圈表示了这个间隙）。因此，只有当被存储对象的大小小于或者等于被释放内存大小时，才能被存储。</p><p>当给对象分配内存时，记住对象总是占据了一块连续的内存。</p><p>这就导致了内存片段的核心问题：尽管堆中可用的空间总量可能是巨大的，但有可能很多或者所有的空间都位于已经分配对象之间的小“间隙”中。在这种情况下，尽管总共有足够大的空间来分配，但托管堆找不到足够大的连续空间来分配内存。<br><img src="/img/Unity%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/7.png"><br>上图中，一个大的对象正在被分配，但是没有足够大的连续内存空间，这时，Unity内存管理器就会执行两个步骤：</p><p>第一步，启动垃圾收集器，释放足够大的空间来满足分配需要。</p><p>第二部，如果GC启动了，但任然没有足够的空间，托管堆就会扩张。堆扩张的大小是由平台决定的，但是Unity上的大多数平台都会让托管堆增长一倍。</p><h4 id="托管堆的核心问题："><a href="#托管堆的核心问题：" class="headerlink" title="托管堆的核心问题："></a>托管堆的核心问题：</h4><p>托管堆增长带来的主要问题：</p><ul><li>当托管堆扩张的时候，为了尽量避免不被再次扩张，Unity没有经常释放堆上的内存页。</li><li>大多数平台上，Unity最终会将托管堆的空部分返回给操作系统。发生这个的时间间隔是不确定的，所以我们不能依赖这种情况。</li><li>被托管堆使用的地址空间永远不会返回给操作系统。</li><li>对于32位程序来说，托管堆增长和缩小多次，会导致地址空间不够用。如果一个程序的可用地址空间用完了，那么操作系统将会结束这个程序。但对于64位程序来说，有足够大的地址空间，不会出现地址空间用完的情况。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Unity协程的原理&quot;&gt;&lt;a href=&quot;#1-Unity协程的原理&quot; class=&quot;headerlink&quot; title=&quot;1.Unity协程的原理&quot;&gt;&lt;/a&gt;1.Unity协程的原理&lt;/h1&gt;&lt;p&gt;协程不是多线程，协程还是在主线程里面（注：在Unity中非主</summary>
      
    
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://afoolzwt.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
