<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《U3D高级编程》- UGUI核心源码剖析 | 愚人のblog</title><meta name="keywords" content="学习读物"><meta name="author" content="愚人"><meta name="copyright" content="愚人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UGUI核心源码剖析UGUI核心源码结构从图4-3可以看出，以文件夹为单位拆分模块，有Culling (裁剪) 、Layout(布局) 、MaterialModifiers (材质球修改器) 、SpecializedCollections(收集)、Utility (实用工具) 、VertexModifiers (页点修改器)。下面对每个模块进行分析。 Culling模块Culling是对模型进行裁">
<meta property="og:type" content="article">
<meta property="og:title" content="《U3D高级编程》- UGUI核心源码剖析">
<meta property="og:url" content="https://afoolzwt.github.io/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/index.html">
<meta property="og:site_name" content="愚人のblog">
<meta property="og:description" content="UGUI核心源码剖析UGUI核心源码结构从图4-3可以看出，以文件夹为单位拆分模块，有Culling (裁剪) 、Layout(布局) 、MaterialModifiers (材质球修改器) 、SpecializedCollections(收集)、Utility (实用工具) 、VertexModifiers (页点修改器)。下面对每个模块进行分析。 Culling模块Culling是对模型进行裁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://afoolzwt.github.io/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg">
<meta property="article:published_time" content="2023-04-16T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-17T03:29:30.657Z">
<meta property="article:author" content="愚人">
<meta property="article:tag" content="学习读物">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://afoolzwt.github.io/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="https://afoolzwt.github.io/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-HqA81hlzlz&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《U3D高级编程》- UGUI核心源码剖析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-17 11:29:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="愚人のblog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/headicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: lightblue"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">愚人のblog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《U3D高级编程》- UGUI核心源码剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-17T03:29:30.657Z" title="更新于 2023-04-17 11:29:30">2023-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8AU3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/">《U3D高级编程》</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《U3D高级编程》- UGUI核心源码剖析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="UGUI核心源码剖析"><a href="#UGUI核心源码剖析" class="headerlink" title="UGUI核心源码剖析"></a>UGUI核心源码剖析</h1><h2 id="UGUI核心源码结构"><a href="#UGUI核心源码结构" class="headerlink" title="UGUI核心源码结构"></a>UGUI核心源码结构</h2><p><img src="/img/Unity%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/10.png"><br>从图4-3可以看出，以文件夹为单位拆分模块，有Culling (裁剪) 、Layout(布局) 、MaterialModifiers (材质球修改器) 、SpecializedCollections(收集)、Utility (实用工具) 、VertexModifiers (页点修改器)。下面对每个模块进行分析。</p>
<h2 id="Culling模块"><a href="#Culling模块" class="headerlink" title="Culling模块"></a>Culling模块</h2><p>Culling是对模型进行裁剪的工具类，大都用在Mask (遮罩) 上，只有Mask才有裁剪的需求。</p>
<p>如图4-4所示，文件夹中包含四个文件，其中一个是静态类，一个是接口类。<br><img src="/img/Unity%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/11.png"></p>
<p>Clipping类中有两个函数比较重要，常被用在Mask的裁剪上，其源代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Find the Rect to use for clipping.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Given the input RectMask2ds find a rectangle that is the overlap of all the inputs.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rectMaskParents&quot;&gt;</span>RectMasks to build the overlap rect from.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;validRect&quot;&gt;</span>Was there a valid Rect found.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>The final compounded overlapping rect<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Rect <span class="title">FindCullAndClipWorldRect</span>(<span class="params">List&lt;RectMask2D&gt; rectMaskParents, <span class="keyword">out</span> <span class="built_in">bool</span> validRect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectMaskParents.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        validRect = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect current = rectMaskParents[<span class="number">0</span>].canvasRect;</span><br><span class="line">    <span class="built_in">float</span> xMin = current.xMin;</span><br><span class="line">    <span class="built_in">float</span> xMax = current.xMax;</span><br><span class="line">    <span class="built_in">float</span> yMin = current.yMin;</span><br><span class="line">    <span class="built_in">float</span> yMax = current.yMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; rectMaskParents.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        current = rectMaskParents[i].canvasRect;</span><br><span class="line">        <span class="keyword">if</span> (xMin &lt; current.xMin)</span><br><span class="line">            xMin = current.xMin;</span><br><span class="line">        <span class="keyword">if</span> (yMin &lt; current.yMin)</span><br><span class="line">            yMin = current.yMin;</span><br><span class="line">        <span class="keyword">if</span> (xMax &gt; current.xMax)</span><br><span class="line">            xMax = current.xMax;</span><br><span class="line">        <span class="keyword">if</span> (yMax &gt; current.yMax)</span><br><span class="line">            yMax = current.yMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validRect = xMax &gt; xMin &amp;&amp; yMax &gt; yMin;</span><br><span class="line">    <span class="keyword">if</span> (validRect)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rect(xMin, yMin, xMax - xMin, yMax - yMin);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的函数为Clipping类里的函数，第一个函数FindCullAndClipWorldRect()的含义是计算RectMask2D重叠部分的区域。第二个函数Rectlntersect()为第一个函数提供计算服务，其合义是计算两个矩阵的重叠部分。</p>
<p>这两个函数都是静态函数，也可视为工具函数，直接调用即可，不需要实例化。</p>
<h2 id="Layout模块"><a href="#Layout模块" class="headerlink" title="Layout模块"></a>Layout模块</h2><p>从图4-5的Layout模块的文件夹结构可以看出，Layout的主要功能都是布局方面的，包括横向布局、纵向布局和方格布局等。总共12个文件，有9个带有Layout字样，它们都是用于处理布局的。<br><img src="/img/Unity%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/12.png"><br>除处理布局内容外，其余3个文件CanvasScaler、AspectRatioFitter、ContentSizeFitter则是用于调整屏幕自适应功能的。</p>
<p>从ContentSizeFitter类、AspectRatioFitter类都带有Fitter字样可以了解到，它们的功能都是处理屏幕自适应。其中ContentSizeFitter类处理的是内容的自适应问题，而AspectRatioFitter类处理的是朝向的自适应问题，包括以长度为基准、以宽度为基准、以父节点为基准、以外层父节点为基准这四种类型的自适应方式。</p>
<p>另外，CanvasScaler类提供的功能非常重要，它操作的是Canvas整个画布针对不同屏幕进行的自适应调整。</p>
<p>由于代码量比较多，这里着重看看CanvasScaler类里的代码，其CanvasScaler类的核心函数源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Handles canvas scaling that scales with the screen size.</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleScaleWithScreenSize</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Vector2 screenSize = <span class="keyword">new</span> Vector2(Screen.width, Screen.height);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Multiple display support only when not the main display. For display 0 the reported</span></span><br><span class="line">       <span class="comment">// resolution is always the desktops resolution since its part of the display API,</span></span><br><span class="line">       <span class="comment">// so we use the standard none multiple display method. (case 741751)</span></span><br><span class="line">       <span class="built_in">int</span> displayIndex = m_Canvas.targetDisplay;</span><br><span class="line">       <span class="keyword">if</span> (displayIndex &gt; <span class="number">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length)</span><br><span class="line">       &#123;</span><br><span class="line">           Display disp = Display.displays[displayIndex];</span><br><span class="line">           screenSize = <span class="keyword">new</span> Vector2(disp.renderingWidth, disp.renderingHeight);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">float</span> scaleFactor = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">switch</span> (m_ScreenMatchMode)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">case</span> ScreenMatchMode.MatchWidthOrHeight:</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// We take the log of the relative width and height before taking the average.</span></span><br><span class="line">               <span class="comment">// Then we transform it back in the original space.</span></span><br><span class="line">               <span class="comment">// the reason to transform in and out of logarithmic space is to have better behavior.</span></span><br><span class="line">               <span class="comment">// If one axis has twice resolution and the other has half, it should even out if widthOrHeight value is at 0.5.</span></span><br><span class="line">               <span class="comment">// In normal space the average would be (0.5 + 2) / 2 = 1.25</span></span><br><span class="line">               <span class="comment">// In logarithmic space the average is (-1 + 1) / 2 = 0</span></span><br><span class="line"><span class="comment">// 在取平均值之前，我们先取相对宽度和高度的对数</span></span><br><span class="line"><span class="comment">// 然后将其转换到原始空间</span></span><br><span class="line"><span class="comment">// 进出对数空间的原因是具有更好的表现</span></span><br><span class="line"><span class="comment">// 如果一个轴的分辨率为两倍，而另一个轴的分辨率为一半</span></span><br><span class="line"><span class="comment">// 则widthOrHeight值为0.5时，它应该平整</span></span><br><span class="line"><span class="comment">// 在正常空间中，平均值为 (0.5 + 2) / 2 = 1.25</span></span><br><span class="line"><span class="comment">// 在对数空间中，平均值为 (-1 + 1) / 2 = 0</span></span><br><span class="line">               <span class="built_in">float</span> logWidth = Mathf.Log(screenSize.x / m_ReferenceResolution.x, kLogBase);</span><br><span class="line">               <span class="built_in">float</span> logHeight = Mathf.Log(screenSize.y / m_ReferenceResolution.y, kLogBase);</span><br><span class="line">               <span class="built_in">float</span> logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);</span><br><span class="line">               scaleFactor = Mathf.Pow(kLogBase, logWeightedAverage);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">case</span> ScreenMatchMode.Expand:</span><br><span class="line">           &#123;</span><br><span class="line">               scaleFactor = Mathf.Min(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">case</span> ScreenMatchMode.Shrink:</span><br><span class="line">           &#123;</span><br><span class="line">               scaleFactor = Mathf.Max(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       SetScaleFactor(scaleFactor);</span><br><span class="line">       SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在不同的ScreenMathMode模式下，CanvasScaler类对屏幕的适应算法包括优先匹配长或宽的、最小化固定拉伸及最大化固定拉伸这三种数学计算方式。<br>其中在优先匹配长或宽算法中个绍了如何使用Log和Pow来计算缩放比例。</p>
<h2 id="MaterialModifiers、SpecializedCollections和Utility"><a href="#MaterialModifiers、SpecializedCollections和Utility" class="headerlink" title="MaterialModifiers、SpecializedCollections和Utility"></a>MaterialModifiers、SpecializedCollections和Utility</h2><p>材质球修改器、特殊收集器、实用工具这三部分的逻辑量相对少却相当重要，它们是其他模块所依赖的工具。</p>
<p>MaterialModifiers、SpecializedCollections、 Utility的文件夹结构如图4-6所示。<br><img src="/img/Unity%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/13.png"></p>
<p>IMaterialModifier是一个接口类，是为Mask修改材质球所准备的，所用方法需要各自实现。</p>
<p>IndexedSet是一个容器，在很多核心代码上都可使用，它加快了移除元素的速度，并且加快了元素是否包含某个元素的判断操作。</p>
<p>ListPool是List容器对象池，ObiectPool是普通对象池，很多代码上都用到了它们，它们让内存的利用率更高。</p>
<p>VertexHelper特别重要，它用来存储生成网格 (Mesh) 需要的所有数据。在网格生成的过程中，由于顶点的生成频率非常高，因此VertexHelper在存储了网格的所有相关数据的同时，用上面提到的ListPool和ObjectPool作为对象池来生成和回收，使得数据被高效地重复利用，不过它并不负责计算和生成网格，网格的计算和生成由各自的图形组件来完成，它只提供计算后的数据存储服务。</p>
<h2 id="VertexModifiers"><a href="#VertexModifiers" class="headerlink" title="VertexModifiers"></a>VertexModifiers</h2><p>VertexModifiers模块的作用是作为顶点修改器。顶点修改器为效果制作提供了更多基础方法和规则。</p>
<p>VertexModifiers模块的文件夹结构如图4-7所示。<br><img src="/img/Unity%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/14.png"></p>
<p>VertexModifiers模块主要用于修改图形网格，在UI元素网格生成完毕后可对其进行二次修改。</p>
<p>其中BaseMeshEffect类是抽象基类，提供所有在修改UI元素网格时所需的变量和接口。</p>
<p>IMeshModifier是关键接口，在渲染核心类Graphic中会获取所有拥有这个接的组件，然后依次遍历并调用ModifyMesh接口来触发改变图像网格的效果。</p>
<p>当前在源码中拥有的二次效果包括Outline (包边框)、Shadow (阴影)PositionAsUV1 (位置UV) ，都继承自BaseMeshEffect基类，并实现了关键接ModifyMesh。其中Outline继承自Shadow，它们的共同关键代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ApplyShadowZeroAlloc</span>(<span class="params">List&lt;UIVertex&gt; verts, Color32 color, <span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UIVertex vt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> neededCapacity = verts.Count + end - start;</span><br><span class="line">    <span class="keyword">if</span> (verts.Capacity &lt; neededCapacity)</span><br><span class="line">        verts.Capacity = neededCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vt = verts[i];</span><br><span class="line">        verts.Add(vt);</span><br><span class="line"></span><br><span class="line">        Vector3 v = vt.position;</span><br><span class="line">        v.x += x;</span><br><span class="line">        v.y += y;</span><br><span class="line">        vt.position = v;</span><br><span class="line">        <span class="keyword">var</span> newColor = color;</span><br><span class="line">        <span class="keyword">if</span> (m_UseGraphicAlpha)</span><br><span class="line">            newColor.a = (<span class="built_in">byte</span>)((newColor.a * verts[i].color.a) / <span class="number">255</span>);</span><br><span class="line">        vt.color = newColor;</span><br><span class="line">        verts[i] = vt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplyshadowZeroAlloc()函数的作用是在原有的网格顶点基础上加入新的顶点，这些新的顶点复制了原来的顶点数据，修改颜色并向外扩充，使得在原图形外渲染出外描边或者阴影。</p>
<h2 id="核心渲染类"><a href="#核心渲染类" class="headerlink" title="核心渲染类"></a>核心渲染类</h2><p>前面剖析的模块在实际业务中是非常有用的工具或算法，它们为核心渲染组件提供了好的基础和方便调用的接口，现在来看看核心渲染类的奥秘所在。</p>
<p>在常用组件Image、Rawlmage、Mask、RectMask2D、Text、InputField中，Image.Rawlmage、Text都继承自MaskableGraphic，而MaskableGraphic又继承自Graphic类，因此Graphic相对比较重要，它是基础类，也存放了核心算法。</p>
<p>除以上这几个类外，CanvasUpdateRegistry是存储和管理所有可绘制元素的管理类，它也是比较重要的类，我们会在下面进行介绍。</p>
<p>首先来看Graphic核心，它有两个部分比较重要，这两个部分揭示了Graphic的运作机制。</p>
<p>Graphic类的第一部分源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Set all properties of the Graphic dirty and needing rebuilt.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Dirties Layout, Vertices, and Materials.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAllDirty</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Optimization: Graphic layout doesn&#x27;t need recalculation if</span></span><br><span class="line">            <span class="comment">// the underlying Sprite is the same size with the same texture.</span></span><br><span class="line">            <span class="comment">// (e.g. Sprite sheet texture animation)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_SkipLayoutUpdate)</span><br><span class="line">            &#123;</span><br><span class="line">                m_SkipLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                SetLayoutDirty();<span class="comment">//设置布局需要重构</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_SkipMaterialUpdate)</span><br><span class="line">            &#123;</span><br><span class="line">                m_SkipMaterialUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                SetMaterialDirty();<span class="comment">//设置材质球需要重构</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SetVerticesDirty();<span class="comment">//设置顶点需要重构</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Mark the layout as dirty and needing rebuilt.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Send a OnDirtyLayoutCallback notification if any elements are registered. See RegisterDirtyLayoutCallback</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutDirty</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 是否激活</span></span><br><span class="line">            <span class="keyword">if</span> (!IsActive())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">// 标记重构节点</span></span><br><span class="line">            LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">			<span class="comment">// 重构标记回调通知</span></span><br><span class="line">            <span class="keyword">if</span> (m_OnDirtyLayoutCallback != <span class="literal">null</span>)</span><br><span class="line">                m_OnDirtyLayoutCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Mark the vertices as dirty and needing rebuilt.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Send a OnDirtyVertsCallback notification if any elements are registered. See RegisterDirtyVerticesCallback</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetVerticesDirty</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 是否激活</span></span><br><span class="line">            <span class="keyword">if</span> (!IsActive())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">// 设置重构标记</span></span><br><span class="line">            m_VertsDirty = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将自己注册到重构队列中</span></span><br><span class="line">CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">// 回调通知</span></span><br><span class="line">            <span class="keyword">if</span> (m_OnDirtyVertsCallback != <span class="literal">null</span>)</span><br><span class="line">                m_OnDirtyVertsCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Mark the material as dirty and needing rebuilt.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Send a OnDirtyMaterialCallback notification if any elements are registered. See RegisterDirtyMaterialCallback</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 是否激活</span></span><br><span class="line">            <span class="keyword">if</span> (!IsActive())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">// 设置重构标记</span></span><br><span class="line">            m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">             <span class="comment">// 将自己注册到重构队列中</span></span><br><span class="line">CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">// 回调通知</span></span><br><span class="line">            <span class="keyword">if</span> (m_OnDirtyMaterialCallback != <span class="literal">null</span>)</span><br><span class="line">                m_OnDirtyMaterialCallback();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，SetAllDirty()方法将设置并通知元素重新布局、重新构建网格及材质球。该方法通知LayoutRebuilder布局管理类进行重新布局，在LayoutRebuilder.MarkLayout-ForRebuild()中，它调用<br>CanvasUpdateRegistry.TryRegisterCanvasElementForLayoutRebuild0加入重构队伍，最终重构布局。</p>
<p>SetLayoutDirty()、SetVerticesDirty()、SetMaterialDirty()都调用了CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild()，被调用时可以认为是通知它去重构网格，但它并没有立即重新构建，而是将需要重构的元件数据加入IndexedSet容器中，等待下次重构。注意，CanvasUpdateRegistry只负责重构网格，并不负责渲染和合并。</p>
<p>我们来看看CanvasUpdateRegistry的RegisterCanvasElementForGraphicRebuild()函数部分，其源码如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Try and add the given element to the rebuild list.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Will not return if successfully added.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;element&quot;&gt;</span>The element that is needing rebuilt.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Try and add the given element to the rebuild list.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;element&quot;&gt;</span>The element that is needing rebuilt.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> True if the element was successfully added to the rebuilt list.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> False if either already inside a Graphic Update loop OR has already been added to the list.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">InternalRegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_PerformingGraphicUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;Trying to add &#123;0&#125; for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.&quot;</span>, element));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_GraphicRebuildQueue.AddUnique(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，InternalRegisterCanvasElementForGraphicRebuild()将元素放入重构队列中等<br>待下一次重构。</p>
<p>重构时的逻辑源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Comparison&lt;ICanvasElement&gt; s_SortLayoutFunction = SortLayoutList;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">         CleanInvalidItems();</span><br><span class="line"></span><br><span class="line">         m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 布局重构			</span></span><br><span class="line">         m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= (<span class="built_in">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">var</span> rebuild = instance.m_LayoutRebuildQueue[j];</span><br><span class="line">                 <span class="keyword">try</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                         rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">                 &#125;</span><br><span class="line">                 catch (Exception e)</span><br><span class="line">                 &#123;</span><br><span class="line">                     Debug.LogException(e, rebuild.transform);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">             m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">         instance.m_LayoutRebuildQueue.Clear();</span><br><span class="line">         m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">         <span class="comment">// now layout is complete do culling...</span></span><br><span class="line">         ClipperRegistry.instance.Cull();</span><br><span class="line"><span class="comment">// 元素重构</span></span><br><span class="line">         m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="built_in">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="built_in">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; instance.m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">try</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">var</span> element = instance.m_GraphicRebuildQueue[k];</span><br><span class="line">                     <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                         element.Rebuild((CanvasUpdate)i);</span><br><span class="line">                 &#125;</span><br><span class="line">                 catch (Exception e)</span><br><span class="line">                 &#123;</span><br><span class="line">                     Debug.LogException(e, instance.m_GraphicRebuildQueue[k].transform);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">             m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"></span><br><span class="line">         instance.m_GraphicRebuildQueue.Clear();</span><br><span class="line">         m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">         UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，PerformUpdate为CanvasUpdateRegistry在重构调用时的逻辑。先将要重新布局的元素取出来，一个一个调用Rebuild函数重构，再对布局后的元素进行裁剪，裁剪后将布局中每个需要重构的元素取出来并调用Rebuild函数进行重构，最后做一些清理的事务。</p>
<p>我们再来看看Graphic的另一个重要的函数，即执行网格构建函数，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_VertexHelper.Clear(); <span class="comment">// clear the vertex helper so invalid graphics dont draw.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此段代码是Graphic构建网格的部分，先调用OnPopulateMesh创建自己的网格，然后调用所有需要修改网格的修改者(lMeshModifier) ，也就是效果组件 (描边等效果组件)进行修改，最后放入CanvasRenderer。</p>
<p>其中CanvasRenderer是每个绘制元素都必须有的组件，它是画布与渲染的连接组件，通过CanvasRenderer才能把网格绘制到Canvas画布上去。</p>
<p>这里使用VertexHelper是为了节省内存和CPU，它内部采用List容器对象池，将所有使用过的废弃的数据都存储在对象池的容器中，当需要时再拿旧的继续使用，源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VertexHelper</span> : <span class="title">IDisposable</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector3&gt; m_Positions;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Color32&gt; m_Colors;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector2&gt; m_Uv0S;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector2&gt; m_Uv1S;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector2&gt; m_Uv2S;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector2&gt; m_Uv3S;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector3&gt; m_Normals;</span><br><span class="line">       <span class="keyword">private</span> List&lt;Vector4&gt; m_Tangents;</span><br><span class="line">       <span class="keyword">private</span> List&lt;<span class="built_in">int</span>&gt; m_Indices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码为VertexHelper的定义部分。</p>
<p>组件中，Image、Rawlmage、Text都override (重写) 了OnPopulateMesh()函数，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper toFill</span>)</span></span><br></pre></td></tr></table></figure>
<p>这些都需要有自己自定义的网格样式来构建不同类型的画面。</p>
<p>其实CanvasRenderer和Canvas才是合并网格的关键，但CanvasRenderer和Canvas并没有开源出来。</p>
<p>我试图通过查找反编译的代码来查看相关内容，但也没有找到，我们无法获得这部分的源码但仔细一想，也差不多能想出个大概。合并部分无非就是每次重构时获取Canvas下面所有的CanvasRenderer实例，将它们的网格合并起来，仅此而已。因此关键还是要看如何减少重构次数、提高内存和提高CPU的使用效率。</p>
<p>除Graphic类，Mask部分也是我们关心的问题，继续看Mask部分的核心，源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>);</span><br><span class="line">StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">m_MaskMaterial = maskMaterial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unmaskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Zero, CompareFunction.Always, <span class="number">0</span>);</span><br><span class="line">StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">m_UnmaskMaterial = unmaskMaterial;</span><br><span class="line">graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m_MaskMaterial;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，Mask组件调用模板材质球来构建一个自己的材质球，因此它使用了实时渲染中的模板方法来裁剪不需要显示的部分，所有在Mask组件后面的物体都会进行裁剪。可以说Mask是在GPU中做的裁剪，使用的方法是着色器中的模板方法。</p>
<p>但RectMask2D与Mask并不一样。我们来看RectMask2D核心的部分源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PerformClipping</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (ReferenceEquals(Canvas, <span class="literal">null</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//TODO See if an IsActive() test would work well here or whether it might cause unexpected side effects (re case 776771)</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// if the parents are changed</span></span><br><span class="line">         <span class="comment">// or something similar we</span></span><br><span class="line">         <span class="comment">// do a recalculate here</span></span><br><span class="line"><span class="comment">// 如果父节点改变或发生类似的事情，我们在这里重新计算</span></span><br><span class="line">         <span class="keyword">if</span> (m_ShouldRecalculateClipRects)</span><br><span class="line">         &#123;</span><br><span class="line">             MaskUtilities.GetRectMasksForClip(<span class="keyword">this</span>, m_Clippers);</span><br><span class="line">             m_ShouldRecalculateClipRects = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// get the compound rects from</span></span><br><span class="line">         <span class="comment">// the clippers that are valid</span></span><br><span class="line"><span class="comment">// 从切割片中获得合法的Rect</span></span><br><span class="line">         <span class="built_in">bool</span> validRect = <span class="literal">true</span>;</span><br><span class="line">         Rect clipRect = Clipping.FindCullAndClipWorldRect(m_Clippers, <span class="keyword">out</span> validRect);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If the mask is in ScreenSpaceOverlay/Camera render mode, its content is only rendered when its rect</span></span><br><span class="line">         <span class="comment">// overlaps that of the root canvas.</span></span><br><span class="line">         RenderMode renderMode = Canvas.rootCanvas.renderMode;</span><br><span class="line">         <span class="built_in">bool</span> maskIsCulled =</span><br><span class="line">             (renderMode == RenderMode.ScreenSpaceCamera || renderMode == RenderMode.ScreenSpaceOverlay) &amp;&amp;</span><br><span class="line">             !clipRect.Overlaps(rootCanvasRect, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (maskIsCulled)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">// Children are only displayed when inside the mask. If the mask is culled, then the children</span></span><br><span class="line">             <span class="comment">// inside the mask are also culled. In that situation, we pass an invalid rect to allow callees</span></span><br><span class="line">             <span class="comment">// to avoid some processing.</span></span><br><span class="line">             clipRect = Rect.zero;</span><br><span class="line">             validRect = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (clipRect != m_LastClipRectCanvasSpace)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">foreach</span> (IClippable clipTarget <span class="keyword">in</span> m_ClipTargets)</span><br><span class="line">             &#123;</span><br><span class="line">                 clipTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">             &#123;</span><br><span class="line">                 maskableTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">                 maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (m_ForceClip)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">foreach</span> (IClippable clipTarget <span class="keyword">in</span> m_ClipTargets)</span><br><span class="line">             &#123;</span><br><span class="line">                 clipTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">             &#123;</span><br><span class="line">                 maskableTarget.SetClipRect(clipRect, validRect);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (maskableTarget.canvasRenderer.hasMoved)</span><br><span class="line">                     maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (maskableTarget.canvasRenderer.hasMoved)</span><br><span class="line">                     maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         m_LastClipRectCanvasSpace = clipRect;</span><br><span class="line">         m_ForceClip = <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码中可以看到，RectMask2D会先计算并设置裁剪的范围，再对所有子节点调用裁剪操作。其中，由</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaskUtilities.GetRectMasksForClip(<span class="keyword">this</span>, m_Clippers);</span><br></pre></td></tr></table></figure>
<p>获取所有有关联的RectMask2D Mask范围，然后由</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rect clipRect = Clipping.FindCullAndClipWorldRect(m_Clippers, <span class="keyword">out</span> validRect);</span><br></pre></td></tr></table></figure>
<p>计算需要裁剪的部分，实际上是计算不需要裁剪的部分，其他部分都进行裁剪。最后由</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (IClippable clipTarget <span class="keyword">in</span> m_ClipTargets)</span><br><span class="line">&#123;</span><br><span class="line">    clipTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对所有需要裁剪的UI元素进行裁剪操作。其中SetClipRect裁剪操作的源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetClipRect</span>(<span class="params">Rect clipRect, <span class="built_in">bool</span> validRect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (validRect)</span><br><span class="line">        canvasRenderer.EnableRectClipping(clipRect);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        canvasRenderer.DisableRectClipping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的操作是在CanvasRenderer中进行的，前面我们说CanvasRenderer的内容无法得知。但可以很容易想到这里面的操作是什么，即计算两个四边形的相交点，再组合成裁剪后的内容。</p>
<p>至此UGUI的源码剖析已经完毕。其实并没有高深的算法或者技术，所有核心部分都围绕着如何构建网格、谁将重构，以及如何裁剪来进行的。很多性能的关键在于，如何减少重构次数以及提高内存和CPU的使用效率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愚人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://afoolzwt.github.io/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/">https://afoolzwt.github.io/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://afoolzwt.github.io" target="_blank">愚人のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a></div><div class="post_share"><div class="social-share" data-image="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/"><img class="prev-cover" src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《U3D高级编程》- UGUI事件模块剖析</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/"><img class="next-cover" src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《U3D高级编程》- Unity3D中C#的底层原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/" title="《C#图解教程》"><img class="cover" src="/img/books/csharpTJJC.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">《C#图解教程》</div></div></a></div><div><a href="/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" title="《两周自制脚本语言》"><img class="cover" src="/img/books/ZZJBYY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">《两周自制脚本语言》</div></div></a></div><div><a href="/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="《大话设计模式》"><img class="cover" src="/img/books/dhsjms.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="title">《大话设计模式》</div></div></a></div><div><a href="/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/" title="《大话数据结构》（串）"><img class="cover" src="/img/books/DHSJJG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">《大话数据结构》（串）</div></div></a></div><div><a href="/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/" title="Lua程序设计（语言特性18-23）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">Lua程序设计（语言特性18-23）</div></div></a></div><div><a href="/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/" title="Lua程序设计（Lua语言入门1-8）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">Lua程序设计（Lua语言入门1-8）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/headicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">愚人</div><div class="author-info__description">为做出理想游戏而不懈努力。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AFoolZWT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">UGUI核心源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">UGUI核心源码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Culling%E6%A8%A1%E5%9D%97"><span class="toc-text">Culling模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layout%E6%A8%A1%E5%9D%97"><span class="toc-text">Layout模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MaterialModifiers%E3%80%81SpecializedCollections%E5%92%8CUtility"><span class="toc-text">MaterialModifiers、SpecializedCollections和Utility</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VertexModifiers"><span class="toc-text">VertexModifiers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B8%B2%E6%9F%93%E7%B1%BB"><span class="toc-text">核心渲染类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI事件模块剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析">《U3D高级编程》- UGUI事件模块剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI核心源码剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析">《U3D高级编程》- UGUI核心源码剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- Unity3D中C#的底层原理"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理">《U3D高级编程》- Unity3D中C#的底层原理</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 数据表的种类"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类">《U3D高级编程》- 数据表的种类</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 用户界面系统的比较"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较">《U3D高级编程》- 用户界面系统的比较</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 愚人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2L5WFGGosqmMsQkoWAORAVz8-gzGzoHsz',
      appKey: 'Aw2OnjzWeYL9LYdqwpwuVuXI',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>