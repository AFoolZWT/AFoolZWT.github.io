<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《大话设计模式》 | 愚人のblog</title><meta name="keywords" content="学习读物"><meta name="author" content="愚人"><meta name="copyright" content="愚人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter3 单一职责原则 单一职责原则(SRP):就一个类而言，应该仅有一个引起它变化的原因。Chapter4 开放-封闭原则 开放-封闭原则:软件实体(类、模块、函数等)应该可以扩展，但是不可修改。Chapter5 依赖倒转原则 依赖倒转原则:  1.高层模块不应该依赖底层模块。两个都应该依赖抽象。2.抽象不应该依赖细节，细节应该依赖于抽象。 里氏替换原则 里氏替换原则(LSP):子类型必">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话设计模式》">
<meta property="og:url" content="https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="愚人のblog">
<meta property="og:description" content="Chapter3 单一职责原则 单一职责原则(SRP):就一个类而言，应该仅有一个引起它变化的原因。Chapter4 开放-封闭原则 开放-封闭原则:软件实体(类、模块、函数等)应该可以扩展，但是不可修改。Chapter5 依赖倒转原则 依赖倒转原则:  1.高层模块不应该依赖底层模块。两个都应该依赖抽象。2.抽象不应该依赖细节，细节应该依赖于抽象。 里氏替换原则 里氏替换原则(LSP):子类型必">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://afoolzwt.github.io/img/books/dhsjms.jpg">
<meta property="article:published_time" content="2023-03-21T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-22T15:47:23.037Z">
<meta property="article:author" content="愚人">
<meta property="article:tag" content="学习读物">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://afoolzwt.github.io/img/books/dhsjms.jpg"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-HqA81hlzlz&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《大话设计模式》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-22 23:47:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="愚人のblog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/headicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: lightblue"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">愚人のblog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《大话设计模式》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-21T16:00:00.000Z" title="发表于 2023-03-22 00:00:00">2023-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-22T15:47:23.037Z" title="更新于 2023-03-22 23:47:23">2023-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/">《大话设计模式》</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《大话设计模式》"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter3-单一职责原则"><a href="#Chapter3-单一职责原则" class="headerlink" title="Chapter3 单一职责原则"></a>Chapter3 单一职责原则</h1><ul>
<li>单一职责原则(SRP):就一个类而言，应该仅有一个引起它变化的原因。<h1 id="Chapter4-开放-封闭原则"><a href="#Chapter4-开放-封闭原则" class="headerlink" title="Chapter4 开放-封闭原则"></a>Chapter4 开放-封闭原则</h1></li>
<li>开放-封闭原则:软件实体(类、模块、函数等)应该可以扩展，但是不可修改。<h1 id="Chapter5-依赖倒转原则"><a href="#Chapter5-依赖倒转原则" class="headerlink" title="Chapter5 依赖倒转原则"></a>Chapter5 依赖倒转原则</h1></li>
<li>依赖倒转原则:</li>
</ul>
<p>1.高层模块不应该依赖底层模块。两个都应该依赖抽象。<br>2.抽象不应该依赖细节，细节应该依赖于抽象。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ul>
<li>里氏替换原则(LSP):子类型必须能够替换掉他们的父类型。<h1 id="Chapter6-装饰模式"><a href="#Chapter6-装饰模式" class="headerlink" title="Chapter6 装饰模式"></a>Chapter6 装饰模式</h1></li>
<li>装饰模式(Decorater):动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</li>
</ul>
<p>Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。<br>至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p>
<p>Component类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Operation（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcreteComponent类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Operation（）</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine（<span class="string">&quot;具体对象的操作&quot;</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Decorator类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Decorator</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">	protect Component component;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetComponent</span>(<span class="params">Component component</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.component = component;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(component != <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			component.Operation();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcreteDecoratorA类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//本类的独有功能，以区别于ConcreteDecoratorB</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> addedState;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//首先运行原Component的Operation()，再执行本类的功能，</span></span><br><span class="line">		<span class="comment">//如addedState,相当于对原Component进行了装饰。</span></span><br><span class="line">		<span class="keyword">base</span>.operation();</span><br><span class="line">		addedState = <span class="string">&quot;New State&quot;</span>;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;具体装饰对象A的操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">base</span>.operation();</span><br><span class="line">		AddedBehavior();</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;具体装饰对象B的操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddedBehavior</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ConcreteComponent c = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">	ConcreteDecoratorA d1 = <span class="keyword">new</span> ConcreteDecoratorA();</span><br><span class="line">	ConcreteDecoratorB d2 = <span class="keyword">new</span> ConcreteDecoratorB();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//装饰的方法是：首先用ConcreteComponent实例化对象c,</span></span><br><span class="line">	<span class="comment">//然后用ConcreteDecoratorA的实例化对象d1来包装c,</span></span><br><span class="line">	<span class="comment">//再用ConcreteDecoratorB的对象d2包装d1,</span></span><br><span class="line">	<span class="comment">//最终执行d2的Operation()</span></span><br><span class="line">	d1.SetComponent(c);</span><br><span class="line">	d2.SetComponent(d1);</span><br><span class="line">	d2.operation();</span><br><span class="line"></span><br><span class="line">	Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter7-代理模式"><a href="#Chapter7-代理模式" class="headerlink" title="Chapter7 代理模式"></a>Chapter7 代理模式</h1><p>代理模式(Proxy):为其他对象提供一种代理以控制对这个对象的访问。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png"><br>Subject类，定义了 RealSubject 和 Proxy 的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Request（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RealSubject类，定义Proxy所代表的真实实体。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RealSubject</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Request（）</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine（<span class="string">&quot;真实的请求&quot;</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Proxy</span> : <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">    RealSubject realSubject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> Request（）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>（realSubject == <span class="literal">null</span>）</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject（）;</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.Request（）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main（<span class="built_in">string</span>[] args）</span><br><span class="line">&#123;</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy（）;</span><br><span class="line">    proxy.Request（）;</span><br><span class="line"></span><br><span class="line">    Console.Read（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>1.远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</li>
<li>2.虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。</li>
<li>3.安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</li>
<li>4.智能指引，是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。<h1 id="Chapter8-工厂方法模式"><a href="#Chapter8-工厂方法模式" class="headerlink" title="Chapter8 工厂方法模式"></a>Chapter8 工厂方法模式</h1></li>
<li>工厂方法模式（Factory Method）: 定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png"><h2 id="简单工厂vs-工厂方法"><a href="#简单工厂vs-工厂方法" class="headerlink" title="简单工厂vs.工厂方法"></a>简单工厂vs.工厂方法</h2></li>
<li>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</li>
<li>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//雷锋工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学雷锋的大学生工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">UndergraduateFactory</span>:<span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Undergraduate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//社区志愿者工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">VolunteerFactory</span>:<span class="title">IFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> LeiFeng <span class="title">CreateLeiFeng</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Volunteer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter9-原型模式"><a href="#Chapter9-原型模式" class="headerlink" title="Chapter9 原型模式"></a>Chapter9 原型模式</h1>原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.png"><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2></li>
<li>原型类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span>(<span class="params"><span class="built_in">string</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>具体原型类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span>:<span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span>(<span class="params"><span class="built_in">string</span> id</span>) : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建当前对象的浅表副本。</span></span><br><span class="line">        <span class="comment">//方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。</span></span><br><span class="line">        <span class="comment">//如果字段是值类型的，则对该字段执行逐位复制。</span></span><br><span class="line">        <span class="comment">//如果字段是引用类型，则复制引用但不复制引用的对象；</span></span><br><span class="line">        <span class="comment">//因此，原始对象及其副本引用同一对象。</span></span><br><span class="line">        <span class="keyword">return</span> (Prototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端代码<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcretePrototype1 p1 = <span class="keyword">new</span> ConcretePrototype1(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">ConcretePrototype1 c1 = (ConcretePrototype1)p1.Clone();</span><br><span class="line"><span class="comment">//克隆类ConcretePrototype1的对象p1就能得到新的实例c1</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Cloned : &#123;0&#125;&quot;</span>,c1.Id);</span><br></pre></td></tr></table></figure>
<h1 id="Chapter10-模板方法模式"><a href="#Chapter10-模板方法模式" class="headerlink" title="Chapter10 模板方法模式"></a>Chapter10 模板方法模式</h1>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.png"><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2></li>
<li>AbstractClass</li>
</ul>
<p>AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模版方法。<br>这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。<br>顶级逻辑也有可能调用一些具体方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一些抽象行为，放到子类去实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法，给出了逻辑的骨架，而逻辑的组成是一些相应的抽象操作，它们都推迟到子类实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrimitiveOperation1();</span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> ConcreteClass</li>
</ul>
<p>实现父类所定义的一个或多个抽象方法。<br>每一个AbstractClass都可以有任意多个ConcreteClass。<br>与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConCreteClassA</span> : <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类A方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类A方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConCreteClassB</span> : <span class="title">AbstarctClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类B方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体类B方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter11-迪米特法则"><a href="#Chapter11-迪米特法则" class="headerlink" title="Chapter11 迪米特法则"></a>Chapter11 迪米特法则</h1><p>迪米特法则（LoD）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
<h1 id="Chapter12-外观模式"><a href="#Chapter12-外观模式" class="headerlink" title="Chapter12 外观模式"></a>Chapter12 外观模式</h1><p>外观模式（Facade）：为子系统中的一组接口提供一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.png"></p>
<h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><ul>
<li>四个子系统的类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SubSystemOne</span> </span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodOne</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法一&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemTwo</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodTwo</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法二&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemThree</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodThree</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法三&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">SubSystemFour</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodFour</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;子系统方法四&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>外观类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外观类，它需要了解所有的子系统的方法和属性，进行组合，以备外界调用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Facade</span></span><br><span class="line">&#123;</span><br><span class="line">    SubSystemOne one;</span><br><span class="line">    SubSystemTwo two;</span><br><span class="line">    SubSystemThree three;</span><br><span class="line">    SubSystemFour four;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = <span class="keyword">new</span> SubSystemOne();</span><br><span class="line">        two = <span class="keyword">new</span> SubSystemTwo();</span><br><span class="line">        three = <span class="keyword">new</span> SubSystemThree();</span><br><span class="line">        four = <span class="keyword">new</span> SubSystemFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法组A（）&quot;</span>);</span><br><span class="line">        one.MethodOne();</span><br><span class="line">        two.MethodTwo();</span><br><span class="line">        four.MethodFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法组B（）&quot;</span>);</span><br><span class="line">        two.MethodTwo();</span><br><span class="line">        three.MethodThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端调用<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">facade.MethodA();</span><br><span class="line">facade.MethodB();</span><br></pre></td></tr></table></figure>
<h1 id="Chapter13-建造者模式"><a href="#Chapter13-建造者模式" class="headerlink" title="Chapter13 建造者模式"></a>Chapter13 建造者模式</h1>建造者模式(Builder)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.png"><h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2></li>
<li>Product类——产品类，由多个部件组成。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span> </span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; parts = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">string</span> part</span>)<span class="comment">//添加产品部件</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        parts.Add(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)<span class="comment">//列举所有的产品部件</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n 产品 创建 ----&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> part <span class="keyword">in</span> parts)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(part);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Builder类——抽象建造者类，确定产品由两个部件PartA和PartB组成，并声明一个得到产品建造后结果的方法GetResult。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Builder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> : <span class="title">Builder</span><span class="comment">//创建具体的两个部件是部件A和部件B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            product.Add(<span class="string">&quot;部件A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            product.Add(<span class="string">&quot;部件B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBuilder2</span> : <span class="title">Builder</span><span class="comment">//创建具体的两个部件是部件X和部件Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartA</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        product.Add(<span class="string">&quot;部件X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildPartB</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        product.Add(<span class="string">&quot;部件Y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Product <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Director类——指挥者类。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Director</span><span class="comment">//用来指挥建造过程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span>(<span class="params">Builder builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.BuildPartA();</span><br><span class="line">        builder.BuildPartB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端代码，客户不需知道具体的建造过程。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Director director = <span class="keyword">new</span> Director();</span><br><span class="line">            Builder b1 = <span class="keyword">new</span> ConcreteBuilder1();</span><br><span class="line">            Builder b2 = <span class="keyword">new</span> ConcreteBuilder2();</span><br><span class="line"></span><br><span class="line">            director.Construct(b1);</span><br><span class="line">            Product p1 = b1.GetResult();</span><br><span class="line">            p1.Show();</span><br><span class="line"></span><br><span class="line">            director.Construct(b2);</span><br><span class="line">            Product p2 = b2.GetResult();</span><br><span class="line">            p2.Show();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">产品 创建 ----</span><br><span class="line">部件A</span><br><span class="line">部件B</span><br><span class="line"></span><br><span class="line">产品 创建 ----</span><br><span class="line">部件X</span><br><span class="line">部件Y</span><br></pre></td></tr></table></figure>
<h1 id="Chapter14-观察者模式"><a href="#Chapter14-观察者模式" class="headerlink" title="Chapter14 观察者模式"></a>Chapter14 观察者模式</h1>观察者模式（Observer）：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同事监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.png"></li>
<li>Subject类，可翻译为主题或抽象通知者，一般用一个抽象类或者一个接口实现。</li>
</ul>
<p>它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">Observer</span>&gt; observers</span> = <span class="keyword">new</span> List&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Observer observer</span>)</span> &#123; observers.Add(observer); &#125;</span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">Observer observer</span>)</span> &#123; observers.Remove(observer);&#125;</span><br><span class="line">    <span class="comment">//通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Observer o <span class="keyword">in</span> observers)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。</li>
</ul>
<p>这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update（）方法，这个方法叫做更新方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</li>
</ul>
<p>具体主题角色通常用一个具体子类实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> : <span class="title">Subject</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> subjectState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体被观察者状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> SubjectState</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> subjectState; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; subjectState = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。</li>
</ul>
<p>具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> : <span class="title">Observer</span> </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> observerState;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ConcreteSubject subject;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span>(<span class="params">ConcreteSubject subject,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.subject = subject;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           observerState = subject.SubjectState;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;观察者&#123;0&#125;的新状态是&#123;1&#125;&quot;</span>,name,observerState);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> ConcreteSubject Subject</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span> &#123; <span class="keyword">return</span> subject; &#125;</span><br><span class="line">           <span class="keyword">set</span> &#123; subject = <span class="keyword">value</span>; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteSubject s = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;X&quot;</span>));</span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;Y&quot;</span>));</span><br><span class="line">            s.Attach(<span class="keyword">new</span> ConcreteObserver(s,<span class="string">&quot;Z&quot;</span>));</span><br><span class="line"></span><br><span class="line">            s.SubjectState = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">            s.Notify();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">观察者X的新状态是ABC</span><br><span class="line">观察者Y的新状态是ABC</span><br><span class="line">观察者Z的新状态是ABC</span><br></pre></td></tr></table></figure>
<h1 id="Chapter15-抽象工厂模式"><a href="#Chapter15-抽象工厂模式" class="headerlink" title="Chapter15 抽象工厂模式"></a>Chapter15 抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory）：提供一个创建一个系列相关或互相依赖对象的接口，而无需指定他们具体的类。</p>
<h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><ul>
<li>1.最大的好处便是易于交换产品系列，由于具体工厂类 ，例如IFactory factory = new AccessFactory（），在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置 。我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库访问，我们只需要更改具体工厂就可以做到。</li>
<li>2.第二大好处是，它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。<h1 id="Chapter16-状态模式"><a href="#Chapter16-状态模式" class="headerlink" title="Chapter16 状态模式"></a>Chapter16 状态模式</h1>状态模式（State）：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</li>
</ul>
<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。<br>把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.png"></p>
<ul>
<li>State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class State</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void Handle(Context context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ConcreteState类，具体状态，每一个子类实现一个与Context的一个状态相关的行为。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置ConcreteStateA的下一状态是ConcreteStateB</span></span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置ConcreteStateB的下一状态是ConcreteStateA</span></span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义Context的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">State state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可读写的状态属性,用于读取当前状态和设置新状态</span></span><br><span class="line">    <span class="keyword">public</span> State State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line">            state = <span class="keyword">value</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;当前状态:&quot;</span>+state.GetType().Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对请求做处理,并设置下一状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">//设置Context的初始状态为ConcreteStateA</span></span><br><span class="line">            Context c = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line"></span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line">            c.Request();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">当前状态:ConcreteStateB</span><br><span class="line">当前状态:ConcreteStateA</span><br><span class="line">当前状态:ConcreteStateB</span><br><span class="line">当前状态:ConcreteStateA</span><br></pre></td></tr></table></figure>
<h2 id="状态模式好处与用处"><a href="#状态模式好处与用处" class="headerlink" title="状态模式好处与用处"></a>状态模式好处与用处</h2><p>状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来[DP]。</p>
<p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。</p>
<p>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。</p>
<h1 id="Chapter17-适配器模式"><a href="#Chapter17-适配器模式" class="headerlink" title="Chapter17 适配器模式"></a>Chapter17 适配器模式</h1><p>适配器模式（Adapter）：将一个类的接口转换成成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP]<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.png"></p>
<h1 id="Chapter18-备忘录模式"><a href="#Chapter18-备忘录模式" class="headerlink" title="Chapter18 备忘录模式"></a>Chapter18 备忘录模式</h1><p>备忘录（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png"></p>
<ul>
<li>Originator（发起人）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Originator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; state = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建备忘录,将当前需要保存的信息导入并实例化出一个Memento对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">CreateMemento</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复备忘录,将Memento导入并将相关数据恢复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMemento</span>(<span class="params">Memento memento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        state = memento.State;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;State = &quot;</span>+state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。</li>
<li>Memento（备忘录）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Memento</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> state;</span><br><span class="line">    <span class="comment">//构造方法,将相关数据导入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span>(<span class="params"><span class="built_in">string</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要保存的数据，可以是多个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</li>
<li>Caretaker（管理者）<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">    <span class="keyword">public</span> Memento Memento</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> memento; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; memento = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            Originator o = <span class="keyword">new</span> Originator();</span><br><span class="line">            o.State = <span class="string">&quot;On&quot;</span>;</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            Caretaker c = <span class="keyword">new</span> Caretaker();</span><br><span class="line">            c.Memento = o.CreateMemento();</span><br><span class="line"></span><br><span class="line">            o.State = <span class="string">&quot;Off&quot;</span>;</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            o.SetMemento(c.Memento);</span><br><span class="line">            o.Show();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">State = On</span><br><span class="line">State = Off</span><br><span class="line">State = On</span><br></pre></td></tr></table></figure>
<h1 id="Chapter19-组合模式"><a href="#Chapter19-组合模式" class="headerlink" title="Chapter19 组合模式"></a>Chapter19 组合模式</h1><p>组合模式（Composite）：将对象组合成树形结构以表示’部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png"></p>
<ul>
<li><p>Component</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通常都用Add和Remove方法来提供增加或移除树叶或树枝的功能。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Component c</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Component为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。</p>
</li>
<li><p>Leaf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Leaf : Component</span><br><span class="line">&#123;</span><br><span class="line">    public Leaf(string name) : base(name)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //由于叶子节点没有再增加分枝和树叶,所以Add和Remove方法实现没有它没有意义。</span><br><span class="line">    //</span><br><span class="line">    public override void Add(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Cannot add to a leaf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Remove(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Cannot remove form a leaf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //叶节点的具体方法,此处是显示其名称和级别。</span><br><span class="line">    public override void Display(int depth)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;-&quot; + depth + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leaf在组合中表示叶节点对象，叶节点没有子节点。</p>
</li>
<li><p>Composite</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Composite</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一个子对象集合用来存储其下属的枝节点和叶节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Component</span>&gt; children</span> = <span class="keyword">new</span> List&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        children.Add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Component c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        children.Remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示其枝节点名称,并对其下级进行遍历。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-&quot;</span> + depth + name);</span><br><span class="line">        <span class="keyword">foreach</span> (Component component <span class="keyword">in</span> children)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Display(depth + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Composite定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove。</p>
</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">            Composite root = <span class="keyword">new</span> Composite(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf A&quot;</span>));</span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf B&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Composite comp = <span class="keyword">new</span> Composite(<span class="string">&quot;Composite X&quot;</span>);</span><br><span class="line">            comp.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XA&quot;</span>));</span><br><span class="line">            comp.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XB&quot;</span>));</span><br><span class="line">            root.Add(comp);</span><br><span class="line"></span><br><span class="line">            Composite comp2 = <span class="keyword">new</span> Composite(<span class="string">&quot;Composite XY&quot;</span>);</span><br><span class="line">            comp2.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XYA&quot;</span>));</span><br><span class="line">            comp2.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf XYB&quot;</span>));</span><br><span class="line">            root.Add(comp2);</span><br><span class="line"></span><br><span class="line">            root.Add(<span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf C&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Leaf leaf = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf D&quot;</span>);</span><br><span class="line">            root.Add(leaf);</span><br><span class="line">            root.Remove(leaf);</span><br><span class="line"></span><br><span class="line">            root.Display(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="number">-1</span>root</span><br><span class="line"><span class="number">-3L</span>eaf A</span><br><span class="line"><span class="number">-3L</span>eaf B</span><br><span class="line"><span class="number">-3</span>Composite X</span><br><span class="line"><span class="number">-5L</span>eaf XA</span><br><span class="line"><span class="number">-5L</span>eaf XB</span><br><span class="line"><span class="number">-3</span>Composite XY</span><br><span class="line"><span class="number">-5L</span>eaf XYA</span><br><span class="line"><span class="number">-5L</span>eaf XYB</span><br><span class="line"><span class="number">-3L</span>eaf C</span><br></pre></td></tr></table></figure>
<h2 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h2><ul>
<li><p>当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。</p>
<h1 id="Chapter20-迭代器模式"><a href="#Chapter20-迭代器模式" class="headerlink" title="Chapter20 迭代器模式"></a>Chapter20 迭代器模式</h1><p>迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png"></p>
</li>
<li><p>Iterator</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到开始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">First</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//得到下一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">Next</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//判断是否到结尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">IsDone</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//当前对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器抽象类</p>
</li>
<li><p>Aggregate</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">CreateIterator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聚集抽象类</p>
</li>
<li><p>ConcreteIterator</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义了一个具体聚集对象</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate aggregate;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化时将具体的聚集对象传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span>(<span class="params">ConcreteAggregate aggregate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到聚集的第一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">First</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到聚集的下一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> ret = <span class="literal">null</span>;</span><br><span class="line">        current++;</span><br><span class="line">        <span class="keyword">if</span> (current &lt; aggregate.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = aggregate[current];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前是否遍历到结尾,到结尾返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsDone</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> current &gt;= aggregate.Count ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前的聚集对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate[current];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体迭代器类，继承Iterator</p>
</li>
<li><p>ConcreteAggregate</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> : <span class="title">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个IList泛型变量,用于存放聚合对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">object</span>&gt; items</span> = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Iterator <span class="title">CreateIterator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回聚集总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> items.Count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个索引器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> items[index]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; items.Insert(index, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体聚集类 继承Aggregate</p>
</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteAggregate a = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">            a[<span class="number">0</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">            a[<span class="number">2</span>] = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">            a[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            a[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"></span><br><span class="line">            Iterator i = <span class="keyword">new</span> ConcreteIterator(a);</span><br><span class="line">            <span class="built_in">object</span> item = i.First();</span><br><span class="line">            <span class="keyword">while</span> (!i.IsDone())</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i.CurrentItem());</span><br><span class="line">                i.Next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>总地来说，迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h1 id="Chapter21-单例模式"><a href="#Chapter21-单例模式" class="headerlink" title="Chapter21 单例模式"></a>Chapter21 单例模式</h1><p>单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png"></p>
<ul>
<li>Singleton类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//构造方法让其private，这就堵死了外界利用new创建此类实例的可能。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//此方法是获得本类实例的唯一全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若实例不存在，则new一个新实例，否则返回已有的实例。</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
定义一个GetInstance操作，允许客户访问它的唯一实例。<br>GetInstance是一个静态方法，主要负责创建自己的唯一实例。<h2 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h2>lock语句：lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> syncRoot = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">//构造方法让其private，这就堵死了外界利用new创建此类实例的可能。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//此方法是获得本类实例的唯一全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">        <span class="keyword">lock</span> (syncRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若实例不存在，则new一个新实例，否则返回已有的实例。</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止发生派生，而派生可能会增加实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在第一次引用类的任何成员时创建实例。</span></span><br><span class="line">    <span class="comment">//公共语言运行库负责处理变量初始化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样的实现与前面的示例类似，也是解决了单例模式试图解决的两个基本问题：全局访问和实例化控制，公共静态属性为访问实例提供了一个全局访问点。<br>不同之处在于它依赖公共语言运行库来初始化变量。由于构造方法是私有的，因此不能在类本身以外实例化Singleton类；因此，变量引用的是可以在系统中存在的唯一的实例。<br>不过要注意，instance变量标记为readonly，这意味着只能在静态初始化期间或在类构造函数中分配变量。由于这种静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为饿汉式单例类，原先的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以就被称为懒汉式单例类。</p>
<p>由于饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。所以到底使用哪一种方式，取决于实际的需求。</p>
<h1 id="Chapter22-桥接模式"><a href="#Chapter22-桥接模式" class="headerlink" title="Chapter22 桥接模式"></a>Chapter22 桥接模式</h1><h2 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成/聚合复用原则"></a>合成/聚合复用原则</h2><ul>
<li>合成/聚合复用原则（CARP）：尽量使用合成/聚合，尽量不要使用类继承。</li>
</ul>
<p>合成（Composition）和聚合（Aggregation）都是关联的特殊种类。<br>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；<br>合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p>
<p>合成/聚合复用原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>
<p>桥接模式（Bridge）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png"></p>
<ul>
<li><p>Implementor类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ConcreteImplementorA和ConcreteImplementorB等派生类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span>:<span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体实现A的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> : <span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体实现B的方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Abstraction类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor implementor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetImplementor</span>(<span class="params">Implementor implementor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        implementor.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RefinedAbstraction类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> : <span class="title">Abstraction</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        implementor.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            Abstraction ab = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line">            ab.SetImplementor(<span class="keyword">new</span> ConcreteImplementorA());</span><br><span class="line">            ab.Operation();</span><br><span class="line">            ab.SetImplementor(<span class="keyword">new</span> ConcreteImplementorB());</span><br><span class="line">            ab.Operation();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">具体实现A的方法执行</span><br><span class="line">具体实现B的方法执行</span><br></pre></td></tr></table></figure>
<h1 id="Chapter23-命令模式"><a href="#Chapter23-命令模式" class="headerlink" title="Chapter23 命令模式"></a>Chapter23 命令模式</h1><p>命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png"></p>
</li>
<li><p>Command类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span>(<span class="params">Receiver receiver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来声明执行操作的接口。</p>
</li>
<li><p>ConcreteCommand类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span>(<span class="params">Receiver receiver</span>) : <span class="title">base</span>(<span class="params">receiver</span>)</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        receiver.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。</p>
</li>
<li><p>Invoker类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params">Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteCommand</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求该命令执行这个请求。</p>
</li>
<li><p>Receiver类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行请求！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p>
</li>
<li><p>客户端</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            Receiver r = <span class="keyword">new</span> Receiver();</span><br><span class="line">            Command c = <span class="keyword">new</span> ConcreteCommand(r);</span><br><span class="line">            Invoker i = <span class="keyword">new</span> Invoker();</span><br><span class="line"></span><br><span class="line">            i.SetCommand(c);</span><br><span class="line">            i.ExecuteCommand();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">执行请求！</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Chapter24-职责链模式"><a href="#Chapter24-职责链模式" class="headerlink" title="Chapter24 职责链模式"></a>Chapter24 职责链模式</h1><p>职责链模式（Chain of Responsibility）：使多个对象都有机会来处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png"></p>
<ul>
<li><p>Handler类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="comment">//设置继任者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSuccessor</span>(<span class="params">Handler successor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个处理请示的接口。</p>
</li>
<li><p>ConcreteHandler类 具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。</p>
</li>
</ul>
<p>ConcreteHandler1，当请求数在0到10之间则有权处理，否则转到下一位。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> : <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//0到10，处理此请求</span></span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>, <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">null</span>)<span class="comment">//转移到下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteHandler2，当请求数在10到20之间则有权处理，否则转到下一位。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> : <span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">HandleRequest</span>(<span class="params"><span class="built_in">int</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//10到20，处理此请求</span></span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;</span>, <span class="keyword">this</span>.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">null</span>)<span class="comment">//转移到下一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteHandler3，当请求数在20到30之间则有权处理，否则转到下一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteHandler3 : Handler</span><br><span class="line">&#123;</span><br><span class="line">    public override void HandleRequest(int request)</span><br><span class="line">    &#123;</span><br><span class="line">        //20到30，处理此请求</span><br><span class="line">        if (request &gt;= 20 &amp;&amp; request &lt; 30)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;处理请求&#123;1&#125;&quot;, this.GetType().Name, request);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (successor != null)//转移到下一位</span><br><span class="line">        &#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">            Handler h1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">            Handler h2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">            Handler h3 = <span class="keyword">new</span> ConcreteHandler3();</span><br><span class="line">            h1.SetSuccessor(h2);</span><br><span class="line">            h2.SetSuccessor(h3);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] requests = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">20</span> &#125;;</span><br><span class="line">            <span class="comment">//循环给最小处理者提交请求，不同的数额，由不同权限处理者处理。</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> request <span class="keyword">in</span> requests)</span><br><span class="line">            &#123;</span><br><span class="line">                h1.HandleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">ConcreteHandler1处理请求<span class="number">2</span></span><br><span class="line">ConcreteHandler1处理请求<span class="number">5</span></span><br><span class="line">ConcreteHandler2处理请求<span class="number">14</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">22</span></span><br><span class="line">ConcreteHandler2处理请求<span class="number">18</span></span><br><span class="line">ConcreteHandler1处理请求<span class="number">3</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">27</span></span><br><span class="line">ConcreteHandler3处理请求<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="职责链的好处"><a href="#职责链的好处" class="headerlink" title="职责链的好处"></a>职责链的好处</h2><p>这当中最关键的是当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>
<p>这就使得接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。这也就大大降低了耦合度了。</p>
<h1 id="Chapter25-中介者模式"><a href="#Chapter25-中介者模式" class="headerlink" title="Chapter25 中介者模式"></a>Chapter25 中介者模式</h1><p>中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png"></p>
<ul>
<li><p>Mediator类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象的发送消息方法，得到同事对象和发送信息</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message, Colleague colleague</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象中介者类</p>
</li>
<li><p>Colleague类 </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="comment">//构造方法，得到中介者对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span>(<span class="params">Mediator mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象同事类</p>
</li>
</ul>
<p>ConcreteColleague1和ConcreteColleague2等各种同事对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> : <span class="title">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span>(<span class="params">Mediator mediator</span>)</span></span><br><span class="line"><span class="function">    : <span class="title">base</span>(<span class="params">mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mediator.Send(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;同事1得到信息：&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteMediator类 具体中介者类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> : <span class="title">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague1 Colleague1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; colleague1 = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ConcreteColleague2 Colleague2</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; colleague2 = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> message, Colleague colleague</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleague1)</span><br><span class="line">        &#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            ConcreteMediator m = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">            <span class="comment">//让两个具体同事类认识中介者对象</span></span><br><span class="line">            ConcreteColleague1 c1 = <span class="keyword">new</span> ConcreteColleague1(m);</span><br><span class="line">            ConcreteColleague2 c2 = <span class="keyword">new</span> ConcreteColleague2(m);</span><br><span class="line">            <span class="comment">//让中介者认识各个具体通识类对象</span></span><br><span class="line">            m.Colleague1 = c1;</span><br><span class="line">            m.Colleague2 = c2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//具体同事类对象的发送消息都是通过中介者转发</span></span><br><span class="line">            c1.Send(<span class="string">&quot;吃过饭了吗?&quot;</span>);</span><br><span class="line">            c2.Send(<span class="string">&quot;没有呢，你打算请客?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">同事<span class="number">2</span>得到信息：吃过饭了吗?</span><br><span class="line">同事<span class="number">1</span>得到信息：没有呢，你打算请客?</span><br></pre></td></tr></table></figure>

<h1 id="Chapter26-享元模式"><a href="#Chapter26-享元模式" class="headerlink" title="Chapter26 享元模式"></a>Chapter26 享元模式</h1><p>享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png"></p>
<ul>
<li><p>Flyweight类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。</p>
</li>
<li><p>ConcreteFlyweight类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> : <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;具体Flyweight:&quot;</span> + extrinsicstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间。</p>
</li>
<li><p>UnsharedConcreteFlyweight类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> : <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> extrinsicstate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不共享的具体Flyweight:&quot;</span> + extrinsicstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指那些不需要共享的Flyweight子类。<br>因为Flyweight接口共享成为可能，但它并不强制共享。</p>
</li>
<li><p>FlyweightFactory类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable flyweights = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化工厂时，先生成三个实例。</span></span><br><span class="line">        flyweights.Add(<span class="string">&quot;X&quot;</span>,<span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.Add(<span class="string">&quot;Y&quot;</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.Add(<span class="string">&quot;Z&quot;</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据客户端请求，获得已经生成的实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">GetFlyweight</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Flyweight)flyweights[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个享元工厂，用来创建并管理Flyweight对象。<br>它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</p>
</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            <span class="built_in">int</span> extrinsicstate = <span class="number">22</span>;<span class="comment">//代码外部状态</span></span><br><span class="line"></span><br><span class="line">            FlyweightFactory f = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line"></span><br><span class="line">            Flyweight fx = f.GetFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">            fx.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight fy = f.GetFlyweight(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">            fy.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight fz = f.GetFlyweight(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">            fz.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Flyweight uf = <span class="keyword">new</span> UnsharedConcreteFlyweight();</span><br><span class="line">            uf.Operation(--extrinsicstate);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">具体Flyweight:<span class="number">21</span></span><br><span class="line">具体Flyweight:<span class="number">20</span></span><br><span class="line">具体Flyweight:<span class="number">19</span></span><br><span class="line">不共享的具体Flyweight:<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h2 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h2><p>在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。<br>事实上，享元模式可以避免大量非常相似类的开销。<br>在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。<br>如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p>
<p>也就是说，享元模式Flyweight执行时所需的状态是有内部的也可能有外部的，内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端对象存储或计算，当调用Flyweight对象的操作时，将该状态传递给它。</p>
<h1 id="Chapter27-解释器模式"><a href="#Chapter27-解释器模式" class="headerlink" title="Chapter27 解释器模式"></a>Chapter27 解释器模式</h1><p>解释器模式（interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p>解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。<br>这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png"></p>
<ul>
<li><p>AbstractExpression（抽象表达式）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractExpression</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</p>
</li>
<li><p>TerminalExpression（终结符表达式）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TerminalExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;终端解释器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现与文法中的终结符相关联的解释操作。<br>实现抽象表达式中所要求的接口，主要是一个interpret（）方法。<br>文法中每一个终结符都有一个具体终结表达式与之相对应。</p>
</li>
<li><p>NonterminalExpression（非终结符表达式）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">NontermianlExpression</span> : <span class="title">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Interpret</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;非终端解释器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为文法中的非终结符实现解释操作。<br>对文法中每一条规则R1、R2……Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的interpret（）方法实现解释操作。<br>解释操作以递归方式调用上面所提到的代表R1、R2……Rn中各个符号的实例变量。</p>
</li>
<li><p>Context</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Input &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> input; &#125; <span class="keyword">set</span> &#123; input = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> output;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Output &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> output; &#125; <span class="keyword">set</span> &#123; output = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含解释器之外的一些全局信息。</p>
</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            Interpreter.Context context = <span class="keyword">new</span> Interpreter.Context();</span><br><span class="line">            IList&lt;AbstractExpression&gt; list = <span class="keyword">new</span> List&lt;AbstractExpression&gt;();</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> NontermianlExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line">            list.Add(<span class="keyword">new</span> TerminalExpression());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (AbstractExpression exp <span class="keyword">in</span> list)</span><br><span class="line">            &#123;</span><br><span class="line">                exp.Interpret(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">终端解释器</span><br><span class="line">非终端解释器</span><br><span class="line">终端解释器</span><br><span class="line">终端解释器</span><br></pre></td></tr></table></figure>
<h2 id="解释器模式好处"><a href="#解释器模式好处" class="headerlink" title="解释器模式好处"></a>解释器模式好处</h2><p>用了解释器模式，就意味着可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</p>
<p>解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。</p>
<h1 id="Chapter28-访问者模式"><a href="#Chapter28-访问者模式" class="headerlink" title="Chapter28 访问者模式"></a>Chapter28 访问者模式</h1><p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br><img src="/img/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png"></p>
<p>访问者模式的目的是要把处理从数据结构分离出来。<br>很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。<br>反之，如果这样的系统的数据结构对象易于变化，经常要有新的数据对象增加进来，就不适合使用访问者模式。</p>
<ul>
<li>Visitor类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Visitor</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为该对象结构中ConcreteElement的每一个类声明一个Visit操作。</li>
</ul>
<p>ConcreteVisitor1和ConcreteVisitor2类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor1</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>,concreteElementA.GetType().Name,<span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementB.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor2</span> : <span class="title">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementA</span>(<span class="params">ConcreteElementA concreteElementA</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementA.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">VisitConcreteElementB</span>(<span class="params">ConcreteElementB concreteElementB</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;被&#123;1&#125;访问&quot;</span>, concreteElementB.GetType().Name, <span class="keyword">this</span>.GetType().Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。</p>
<ul>
<li>Element类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Element</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
定义一个Accept操作，它以一个访问者为参数。</li>
</ul>
<p>ConcreteElementA和ConcreteElementB类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> : <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//充分利用双分派技术，实现处理与数据结构的分离。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitConcreteElementA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他的相关方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationA</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> : <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitConcreteElementB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationA</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体元素，实现Accept操作。</p>
<ul>
<li>ObjectStructure类<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IList</span>&lt;<span class="title">Element</span>&gt; elements</span> = <span class="keyword">new</span> List&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        elements.Add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        elements.Remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">Visitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> elements)</span><br><span class="line">        &#123;</span><br><span class="line">            e.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。</li>
</ul>
<p>客户端代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ObjectStructure o = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">            o.Attach(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">            o.Attach(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line"></span><br><span class="line">            ConcreteVisitor1 v1 = <span class="keyword">new</span> ConcreteVisitor1();</span><br><span class="line">            ConcreteVisitor2 v2 = <span class="keyword">new</span> ConcreteVisitor2();</span><br><span class="line">            o.Accept(v1);</span><br><span class="line">            o.Accept(v2);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">ConcreteElementA被ConcreteVisitor1访问</span><br><span class="line">ConcreteElementB被ConcreteVisitor1访问</span><br><span class="line">ConcreteElementA被ConcreteVisitor2访问</span><br><span class="line">ConcreteElementB被ConcreteVisitor2访问</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愚人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://afoolzwt.github.io/2023/03/22/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://afoolzwt.github.io" target="_blank">愚人のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AF%BB%E7%89%A9/">学习读物</a></div><div class="post_share"><div class="social-share" data-image="/img/books/dhsjms.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%862)%20/"><img class="prev-cover" src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《U3D高级编程》- Unity3D中C#的底层原理2</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/"><img class="next-cover" src="/img/Lua.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Lua程序设计（语言特性18-23）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/01/CSharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B/" title="《C#图解教程》"><img class="cover" src="/img/books/csharpTJJC.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">《C#图解教程》</div></div></a></div><div><a href="/2022/05/14/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" title="《两周自制脚本语言》"><img class="cover" src="/img/books/ZZJBYY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">《两周自制脚本语言》</div></div></a></div><div><a href="/2022/07/21/CSDataStructure/DataStructure2(%E4%B8%B2)/" title="《大话数据结构》（串）"><img class="cover" src="/img/books/DHSJJG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">《大话数据结构》（串）</div></div></a></div><div><a href="/2022/11/02/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A718-23%EF%BC%89/" title="Lua程序设计（语言特性18-23）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">Lua程序设计（语言特性18-23）</div></div></a></div><div><a href="/2022/10/31/Lua/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A81-8%EF%BC%89/" title="Lua程序设计（Lua语言入门1-8）"><img class="cover" src="/img/Lua.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">Lua程序设计（Lua语言入门1-8）</div></div></a></div><div><a href="/2022/05/14/CSDataStructure/DataStructure1(%E7%BA%BF%E6%80%A7%E8%A1%A8)/" title="《大话数据结构》（线性表）"><img class="cover" src="/img/books/DHSJJG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">《大话数据结构》（线性表）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/headicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">愚人</div><div class="author-info__description">为做出理想游戏而不懈努力。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AFoolZWT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter3-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">Chapter3 单一职责原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter4-%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">Chapter4 开放-封闭原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter5-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-text">Chapter5 依赖倒转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">里氏替换原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter6-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter6 装饰模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter7-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter7 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter8-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter8 工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82vs-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-text">简单工厂vs.工厂方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter9-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter9 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter10 模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter11-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">Chapter11 迪米特法则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter12-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter12 外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter13-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter13 建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter14-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter14 观察者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter15-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter15 抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">抽象工厂模式的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter16-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter16 状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%A4%84%E4%B8%8E%E7%94%A8%E5%A4%84"><span class="toc-text">状态模式好处与用处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter17-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter17 适配器模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter18 备忘录模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter19-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter19 组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">何时使用组合模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter20-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter20 迭代器模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter21-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter21 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%B6%E7%9A%84%E5%8D%95%E4%BE%8B"><span class="toc-text">多线程时的单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">静态初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter22-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter22 桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90-%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-text">合成&#x2F;聚合复用原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter23-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter23 命令模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter24-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter24 职责链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">职责链的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter25-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter25 中介者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter26-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter26 享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81"><span class="toc-text">内部状态与外部状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter27-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter27 解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%A4%84"><span class="toc-text">解释器模式好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter28-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Chapter28 访问者模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI事件模块剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI事件模块剖析">《U3D高级编程》- UGUI事件模块剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- UGUI核心源码剖析"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(UGUI%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90)/" title="《U3D高级编程》- UGUI核心源码剖析">《U3D高级编程》- UGUI核心源码剖析</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- Unity3D中C#的底层原理"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(Unity3D%E4%B8%ADC#%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)%20/" title="《U3D高级编程》- Unity3D中C#的底层原理">《U3D高级编程》- Unity3D中C#的底层原理</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 数据表的种类"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB)%20/" title="《U3D高级编程》- 数据表的种类">《U3D高级编程》- 数据表的种类</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较"><img src="/img/books/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《U3D高级编程》- 用户界面系统的比较"/></a><div class="content"><a class="title" href="/2023/04/17/U3D%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/U3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83)%20/" title="《U3D高级编程》- 用户界面系统的比较">《U3D高级编程》- 用户界面系统的比较</a><time datetime="2023-04-16T16:00:00.000Z" title="发表于 2023-04-17 00:00:00">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 愚人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2L5WFGGosqmMsQkoWAORAVz8-gzGzoHsz',
      appKey: 'Aw2OnjzWeYL9LYdqwpwuVuXI',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>